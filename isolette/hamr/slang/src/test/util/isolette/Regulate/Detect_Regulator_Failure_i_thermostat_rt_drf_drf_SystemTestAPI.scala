// #Sireum

package isolette.Regulate

import org.sireum._
import art._
import isolette.SystemTestSuiteSlang.runtimeMonitorStream
import isolette._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object Detect_Regulator_Failure_i_thermostat_rt_drf_drf_SystemTestAPI {
  /** helper method to set the values of all incoming ports
    */
  def put_concrete_inputs(): Unit = {
  }



  def fetchContainer(): isolette.Regulate.Detect_Regulator_Failure_i_thermostat_rt_drf_drf_PostState_Container_PS = {
    if (runtimeMonitorStream.contains(Arch.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf.id)) {
      val (_, postContainer_) = runtimeMonitorStream.get(Arch.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf.id).get
      return postContainer_.asInstanceOf[isolette.Regulate.Detect_Regulator_Failure_i_thermostat_rt_drf_drf_PostState_Container_PS]
    }
    else {
      assert(F, s"No post state recorded for ${Arch.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf.name}")
      halt(s"No post state recorded for ${Arch.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf.name}")
    }
  }

  def check_concrete_outputs(api_internal_failure: Isolette_Data_Model.Failure_Flag_i): Unit = {
    var failureReasons: ISZ[ST] = ISZ()

    val actual_internal_failure = get_api_internal_failure()
    if (api_internal_failure != actual_internal_failure) {
      failureReasons = failureReasons :+ st"'internal_failure' did not match expected.  Expected: $api_internal_failure, Actual: $actual_internal_failure"
    }

    assert(failureReasons.isEmpty, st"${(failureReasons, "\n")}".render)
  }

  def get_api_internal_failure(): Isolette_Data_Model.Failure_Flag_i = {
    return fetchContainer().api_internal_failure
  }
}