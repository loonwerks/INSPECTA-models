// #Sireum

package isolette.runtimemonitor

import org.sireum._
import isolette._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object GumboXDispatcher {
  def checkContract(observationKind: ObservationKind.Type, preContainer: Option[art.DataContent], postContainer: Option[art.DataContent]): B = {
    observationKind match {
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postInit =>
        val result: B = isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PostState_Container_PS])
        //println(s"mri.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_preCompute =>
        val result: B = isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.compute_CEP_Pre_Container(preContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PreState_Container_PS])
        //println(s"mri.timeTriggered: Pre-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute =>
        val result: B = isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PostState_Container_PS])
        //println(s"mri.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postInit =>
        val result: B = isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PostState_Container_PS])
        //println(s"mhs.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_preCompute =>
        val result: B = isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.compute_CEP_Pre_Container(preContainer.get.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PreState_Container_PS])
        //println(s"mhs.timeTriggered: Pre-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute =>
        val result: B = isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PostState_Container_PS])
        //println(s"mhs.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postInit =>
        val result: B = isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PostState_Container_PS])
        //println(s"mrm.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_preCompute =>
        // checking the pre-state values of mrm's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postCompute =>
        val result: B = isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PostState_Container_PS])
        //println(s"mrm.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_postInit =>
        // checking the post-state values of drf's initialise entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_preCompute =>
        // checking the pre-state values of drf's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_postCompute =>
        // checking the post-state values of drf's compute entrypoint is not required
        return T

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postInit =>
        val result: B = isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PostState_Container_PS])
        //println(s"mmi.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_preCompute =>
        val result: B = isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.compute_CEP_Pre_Container(preContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PreState_Container_PS])
        //println(s"mmi.timeTriggered: Pre-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute =>
        val result: B = isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PostState_Container_PS])
        //println(s"mmi.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postInit =>
        val result: B = isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PostState_Container_PS])
        //println(s"ma.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_preCompute =>
        val result: B = isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.compute_CEP_Pre_Container(preContainer.get.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PreState_Container_PS])
        //println(s"ma.timeTriggered: Pre-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute =>
        val result: B = isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PostState_Container_PS])
        //println(s"ma.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postInit =>
        val result: B = isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PostState_Container_PS])
        //println(s"mmm.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_preCompute =>
        // checking the pre-state values of mmm's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postCompute =>
        val result: B = isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PostState_Container_PS])
        //println(s"mmm.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_postInit =>
        // checking the post-state values of dmf's initialise entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_preCompute =>
        // checking the pre-state values of dmf's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_postCompute =>
        // checking the post-state values of dmf's compute entrypoint is not required
        return T

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postInit =>
        val result: B = isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_GumboX.inititialize_IEP_Post_Container(postContainer.get.asInstanceOf[isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_PostState_Container_PS])
        //println(s"oit.initialise: Post-condition: ${if (result) "" else "un"}satisfied")
        return result
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_preCompute =>
        // checking the pre-state values of oit's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postCompute =>
        val result: B = isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_GumboX.compute_CEP_Post_Container(preContainer.get.asInstanceOf[isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_PreState_Container_PS], postContainer.get.asInstanceOf[isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_PostState_Container_PS])
        //println(s"oit.timeTriggered: Post-condition: ${if (result) "" else "un"}satisfied")
        return result

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_postInit =>
        // checking the post-state values of thermostat's initialise entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_preCompute =>
        // checking the pre-state values of thermostat's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_postCompute =>
        // checking the post-state values of thermostat's compute entrypoint is not required
        return T

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_postInit =>
        // checking the post-state values of heat_controller's initialise entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_preCompute =>
        // checking the pre-state values of heat_controller's compute entrypoint is not required
        return T
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_postCompute =>
        // checking the post-state values of heat_controller's compute entrypoint is not required
        return T

      case _ => halt("Infeasible")
    }
  }

  def genTestSuite(testCases: ISZ[(Z, ISZ[ST])]): Unit = {
    val tq = "\"\"\""

    val testRoot = Os.path(".") / "src" / "test" / "bridge"

    val Manage_Regulator_Interface_i_thermostat_rt_mri_mri_id = Arch.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri.id
    val Manage_Heat_Source_i_thermostat_rt_mhs_mhs_id = Arch.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs.id
    val Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_id = Arch.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm.id
    val Detect_Regulator_Failure_i_thermostat_rt_drf_drf_id = Arch.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf.id
    val Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_id = Arch.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi.id
    val Manage_Alarm_i_thermostat_mt_ma_ma_id = Arch.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma.id
    val Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_id = Arch.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm.id
    val Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_id = Arch.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf.id
    val Operator_Interface_Thread_i_operator_interface_oip_oit_id = Arch.Isolette_Single_Sensor_Instance_operator_interface_oip_oit.id
    val Temperature_Sensor_i_temperature_sensor_cpi_thermostat_id = Arch.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat.id
    val Heat_Source_i_heat_source_cpi_heat_controller_id = Arch.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller.id

    def genUniqueSuiteName(path: Os.Path, prefix: String): String = {
      var i = 0
      while(true) {
        val cand = path / s"${prefix}_${i}.scala"
        if (!cand.exists) {
          return s"${prefix}_${i}"
        }
        i = i + 1
      }
      halt("Infeasible")
    }

    for (p <- testCases) {
      art.Art.BridgeId.fromZ(p._1) match {
        case Manage_Regulator_Interface_i_thermostat_rt_mri_mri_id =>
          val prefix = "Manage_Regulator_Interface_i_thermostat_rt_mri_mri_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Regulate")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Regulate
                |
                |import org.sireum._
                |import isolette.Regulate._
                |
                |class ${suiteName} extends Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Manage_Heat_Source_i_thermostat_rt_mhs_mhs_id =>
          val prefix = "Manage_Heat_Source_i_thermostat_rt_mhs_mhs_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Regulate")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Regulate
                |
                |import org.sireum._
                |import isolette.Regulate._
                |
                |class ${suiteName} extends Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_id =>
          val prefix = "Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Regulate")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Regulate
                |
                |import org.sireum._
                |import isolette.Regulate._
                |
                |class ${suiteName} extends Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Detect_Regulator_Failure_i_thermostat_rt_drf_drf_id =>
          val prefix = "Detect_Regulator_Failure_i_thermostat_rt_drf_drf_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Regulate")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Regulate
                |
                |import org.sireum._
                |import isolette.Regulate._
                |
                |class ${suiteName} extends Detect_Regulator_Failure_i_thermostat_rt_drf_drf_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_id =>
          val prefix = "Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Monitor")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Monitor
                |
                |import org.sireum._
                |import isolette.Monitor._
                |
                |class ${suiteName} extends Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Manage_Alarm_i_thermostat_mt_ma_ma_id =>
          val prefix = "Manage_Alarm_i_thermostat_mt_ma_ma_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Monitor")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Monitor
                |
                |import org.sireum._
                |import isolette.Monitor._
                |
                |class ${suiteName} extends Manage_Alarm_i_thermostat_mt_ma_ma_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_id =>
          val prefix = "Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Monitor")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Monitor
                |
                |import org.sireum._
                |import isolette.Monitor._
                |
                |class ${suiteName} extends Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_id =>
          val prefix = "Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Monitor")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Monitor
                |
                |import org.sireum._
                |import isolette.Monitor._
                |
                |class ${suiteName} extends Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Operator_Interface_Thread_i_operator_interface_oip_oit_id =>
          val prefix = "Operator_Interface_Thread_i_operator_interface_oip_oit_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Operator_Interface")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Operator_Interface
                |
                |import org.sireum._
                |import isolette.Operator_Interface._
                |
                |class ${suiteName} extends Operator_Interface_Thread_i_operator_interface_oip_oit_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Temperature_Sensor_i_temperature_sensor_cpi_thermostat_id =>
          val prefix = "Temperature_Sensor_i_temperature_sensor_cpi_thermostat_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Devices")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Devices
                |
                |import org.sireum._
                |import isolette.Devices._
                |
                |class ${suiteName} extends Temperature_Sensor_i_temperature_sensor_cpi_thermostat_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case Heat_Source_i_heat_source_cpi_heat_controller_id =>
          val prefix = "Heat_Source_i_heat_source_cpi_heat_controller_RM_TestSuite"
          val path = testRoot /+ ISZ("isolette","Devices")
          val suiteName = genUniqueSuiteName(path, prefix)

          val testSuite =
            st"""package isolette.Devices
                |
                |import org.sireum._
                |import isolette.Devices._
                |
                |class ${suiteName} extends Heat_Source_i_heat_source_cpi_heat_controller_GumboX_TestHarness_ScalaTest {
                |  val verbose: B = T
                |
                |  ${p._2}
                |}"""
          val filename = path / s"${suiteName}.scala"
          filename.writeOver(testSuite.render)
          println(s"Wrote: ${filename.toUri}")
        case x => halt(s"Infeasible bridge id: $x")
      }
    }
  }

  def genTestCase(observationKind: ObservationKind.Type, preContainer: Option[String], postContainer: Option[String], testNameSuffix: Option[String]): ST = {
    val tq = "\"\"\""
    val suffix: String =
      if (testNameSuffix.nonEmpty) testNameSuffix.get
      else ""

    observationKind match {
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toRegulateManage_Regulator_Interface_i_thermostat_rt_mri_mri_PostState_Container_PS(postJson).left
                    |  assert(isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_preCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_preCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_preCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Regulator_Interface_i_thermostat_rt_mri_mri_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_preCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Regulator_Interface_i_thermostat_rt_mri_mri_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Regulator_Interface_i_thermostat_rt_mri_mri_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toRegulateManage_Regulator_Interface_i_thermostat_rt_mri_mri_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toRegulateManage_Heat_Source_i_thermostat_rt_mhs_mhs_PostState_Container_PS(postJson).left
                    |  assert(isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_preCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_preCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_preCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Heat_Source_i_thermostat_rt_mhs_mhs_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_preCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Heat_Source_i_thermostat_rt_mhs_mhs_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Heat_Source_i_thermostat_rt_mhs_mhs_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toRegulateManage_Heat_Source_i_thermostat_rt_mhs_mhs_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toRegulateManage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PostState_Container_PS(postJson).left
                    |  assert(isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toRegulateManage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toRegulateManage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postCompute""")

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toMonitorManage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PostState_Container_PS(postJson).left
                    |  assert(isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_preCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_preCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_preCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_preCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toMonitorManage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toMonitorManage_Alarm_i_thermostat_mt_ma_ma_PostState_Container_PS(postJson).left
                    |  assert(isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_preCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_preCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_preCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Alarm_i_thermostat_mt_ma_ma_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_preCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute: Check Pre-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Alarm_i_thermostat_mt_ma_ma_PreState_Container_PS(preJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |  }
                    |  assert(isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.compute_CEP_Pre_Container(preContainer))
                    |}
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Alarm_i_thermostat_mt_ma_ma_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toMonitorManage_Alarm_i_thermostat_mt_ma_ma_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toMonitorManage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PostState_Container_PS(postJson).left
                    |  assert(isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toMonitorManage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toMonitorManage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postCompute""")

      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postInit =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postInit
                    |
                    |test(s"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postInit: Check Post-condition$suffix") {
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val postContainer = isolette.JSON.toOperator_InterfaceOperator_Interface_Thread_i_operator_interface_oip_oit_PostState_Container_PS(postJson).left
                    |  assert(isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_GumboX.inititialize_IEP_Post_Container(postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postInit""")
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postCompute =>
        return (st"""// Begin test cases for Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postCompute
                    |
                    |test(s"Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postCompute: Check Post-condition$suffix") {
                    |  val preJson: String = st${tq}${preContainer.get}${tq}.render
                    |  val postJson: String = st${tq}${postContainer.get}${tq}.render
                    |  val preContainer = isolette.JSON.toOperator_InterfaceOperator_Interface_Thread_i_operator_interface_oip_oit_PreState_Container_PS(preJson).left
                    |  val postContainer = isolette.JSON.toOperator_InterfaceOperator_Interface_Thread_i_operator_interface_oip_oit_PostState_Container_PS(postJson).left
                    |  if (verbose) {
                    |    println("Pre-State Values:")
                    |    println(s"  $$preContainer")
                    |    println("Post-State Values:")
                    |    println(s"  $$postContainer");
                    |  }
                    |  assert(isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_GumboX.compute_CEP_Post_Container(preContainer, postContainer))
                    |}
                    |// End test cases for Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postCompute""")


      case _ => return st"// TODO ${observationKind}"
    }
  }

  def getUpdates(bridge_id: art.Art.BridgeId, observationKind: ObservationKind.Type, container: art.DataContent): Map[String, String] = {
    observationKind match {
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_upper_desired_temp" ~> postContainer.api_upper_desired_temp.string
        updates = updates + s"${bridge_id}_Out_lower_desired_temp" ~> postContainer.api_lower_desired_temp.string
        updates = updates + s"${bridge_id}_Out_displayed_temp" ~> postContainer.api_displayed_temp.string
        updates = updates + s"${bridge_id}_Out_regulator_status" ~> postContainer.api_regulator_status.string
        updates = updates + s"${bridge_id}_Out_interface_failure" ~> postContainer.api_interface_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastCmd" ~> postContainer.lastCmd.string
        updates = updates + s"${bridge_id}_Out_heat_control" ~> postContainer.api_heat_control.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastRegulatorMode" ~> postContainer.lastRegulatorMode.string
        updates = updates + s"${bridge_id}_Out_regulator_mode" ~> postContainer.api_regulator_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Detect_Regulator_Failure_i_thermostat_rt_drf_drf_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_internal_failure" ~> postContainer.api_internal_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastCmd" ~> postContainer.lastCmd.string
        updates = updates + s"${bridge_id}_Out_upper_alarm_temp" ~> postContainer.api_upper_alarm_temp.string
        updates = updates + s"${bridge_id}_Out_lower_alarm_temp" ~> postContainer.api_lower_alarm_temp.string
        updates = updates + s"${bridge_id}_Out_monitor_status" ~> postContainer.api_monitor_status.string
        updates = updates + s"${bridge_id}_Out_interface_failure" ~> postContainer.api_interface_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastCmd" ~> postContainer.lastCmd.string
        updates = updates + s"${bridge_id}_Out_alarm_control" ~> postContainer.api_alarm_control.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastMonitorMode" ~> postContainer.lastMonitorMode.string
        updates = updates + s"${bridge_id}_Out_monitor_mode" ~> postContainer.api_monitor_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_internal_failure" ~> postContainer.api_internal_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lower_desired_tempWstatus" ~> postContainer.api_lower_desired_tempWstatus.string
        updates = updates + s"${bridge_id}_Out_upper_desired_tempWstatus" ~> postContainer.api_upper_desired_tempWstatus.string
        updates = updates + s"${bridge_id}_Out_lower_alarm_tempWstatus" ~> postContainer.api_lower_alarm_tempWstatus.string
        updates = updates + s"${bridge_id}_Out_upper_alarm_tempWstatus" ~> postContainer.api_upper_alarm_tempWstatus.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Devices.Temperature_Sensor_i_temperature_sensor_cpi_thermostat_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_current_tempWstatus" ~> postContainer.api_current_tempWstatus.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_postInit =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Devices.Heat_Source_i_heat_source_cpi_heat_controller_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_heat_out" ~> postContainer.api_heat_out.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_upper_desired_tempWstatus" ~> preContainer.api_upper_desired_tempWstatus.string
        updates = updates + s"${bridge_id}_In_lower_desired_tempWstatus" ~> preContainer.api_lower_desired_tempWstatus.string
        updates = updates + s"${bridge_id}_In_current_tempWstatus" ~> preContainer.api_current_tempWstatus.string
        updates = updates + s"${bridge_id}_In_regulator_mode" ~> preContainer.api_regulator_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_lastCmd" ~> preContainer.In_lastCmd.string
        updates = updates + s"${bridge_id}_In_current_tempWstatus" ~> preContainer.api_current_tempWstatus.string
        updates = updates + s"${bridge_id}_In_lower_desired_temp" ~> preContainer.api_lower_desired_temp.string
        updates = updates + s"${bridge_id}_In_upper_desired_temp" ~> preContainer.api_upper_desired_temp.string
        updates = updates + s"${bridge_id}_In_regulator_mode" ~> preContainer.api_regulator_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_lastRegulatorMode" ~> preContainer.In_lastRegulatorMode.string
        updates = updates + s"${bridge_id}_In_current_tempWstatus" ~> preContainer.api_current_tempWstatus.string
        updates = updates + s"${bridge_id}_In_interface_failure" ~> preContainer.api_interface_failure.string
        updates = updates + s"${bridge_id}_In_internal_failure" ~> preContainer.api_internal_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Regulate.Detect_Regulator_Failure_i_thermostat_rt_drf_drf_PreState_Container_PS]
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_lastCmd" ~> preContainer.In_lastCmd.string
        updates = updates + s"${bridge_id}_In_upper_alarm_tempWstatus" ~> preContainer.api_upper_alarm_tempWstatus.string
        updates = updates + s"${bridge_id}_In_lower_alarm_tempWstatus" ~> preContainer.api_lower_alarm_tempWstatus.string
        updates = updates + s"${bridge_id}_In_current_tempWstatus" ~> preContainer.api_current_tempWstatus.string
        updates = updates + s"${bridge_id}_In_monitor_mode" ~> preContainer.api_monitor_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_lastCmd" ~> preContainer.In_lastCmd.string
        updates = updates + s"${bridge_id}_In_current_tempWstatus" ~> preContainer.api_current_tempWstatus.string
        updates = updates + s"${bridge_id}_In_lower_alarm_temp" ~> preContainer.api_lower_alarm_temp.string
        updates = updates + s"${bridge_id}_In_upper_alarm_temp" ~> preContainer.api_upper_alarm_temp.string
        updates = updates + s"${bridge_id}_In_monitor_mode" ~> preContainer.api_monitor_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_In_lastMonitorMode" ~> preContainer.In_lastMonitorMode.string
        updates = updates + s"${bridge_id}_In_current_tempWstatus" ~> preContainer.api_current_tempWstatus.string
        updates = updates + s"${bridge_id}_In_interface_failure" ~> preContainer.api_interface_failure.string
        updates = updates + s"${bridge_id}_In_internal_failure" ~> preContainer.api_internal_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Monitor.Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_PreState_Container_PS]
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_regulator_status" ~> preContainer.api_regulator_status.string
        updates = updates + s"${bridge_id}_In_monitor_status" ~> preContainer.api_monitor_status.string
        updates = updates + s"${bridge_id}_In_display_temperature" ~> preContainer.api_display_temperature.string
        updates = updates + s"${bridge_id}_In_alarm_control" ~> preContainer.api_alarm_control.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Devices.Temperature_Sensor_i_temperature_sensor_cpi_thermostat_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_air" ~> preContainer.api_air.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_preCompute =>
        var updates: Map[String, String] = Map.empty
        val preContainer = container.asInstanceOf[isolette.Devices.Heat_Source_i_heat_source_cpi_heat_controller_PreState_Container_PS]
        updates = updates + s"${bridge_id}_In_heat_control" ~> preContainer.api_heat_control.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mri_mri_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Manage_Regulator_Interface_i_thermostat_rt_mri_mri_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_upper_desired_temp" ~> postContainer.api_upper_desired_temp.string
        updates = updates + s"${bridge_id}_Out_lower_desired_temp" ~> postContainer.api_lower_desired_temp.string
        updates = updates + s"${bridge_id}_Out_displayed_temp" ~> postContainer.api_displayed_temp.string
        updates = updates + s"${bridge_id}_Out_regulator_status" ~> postContainer.api_regulator_status.string
        updates = updates + s"${bridge_id}_Out_interface_failure" ~> postContainer.api_interface_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mhs_mhs_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Manage_Heat_Source_i_thermostat_rt_mhs_mhs_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastCmd" ~> postContainer.lastCmd.string
        updates = updates + s"${bridge_id}_Out_heat_control" ~> postContainer.api_heat_control.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_mrm_mrm_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Manage_Regulator_Mode_i_thermostat_rt_mrm_mrm_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastRegulatorMode" ~> postContainer.lastRegulatorMode.string
        updates = updates + s"${bridge_id}_Out_regulator_mode" ~> postContainer.api_regulator_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_rt_drf_drf_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Regulate.Detect_Regulator_Failure_i_thermostat_rt_drf_drf_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_internal_failure" ~> postContainer.api_internal_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmi_mmi_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Manage_Monitor_Interface_i_thermostat_mt_mmi_mmi_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastCmd" ~> postContainer.lastCmd.string
        updates = updates + s"${bridge_id}_Out_upper_alarm_temp" ~> postContainer.api_upper_alarm_temp.string
        updates = updates + s"${bridge_id}_Out_lower_alarm_temp" ~> postContainer.api_lower_alarm_temp.string
        updates = updates + s"${bridge_id}_Out_monitor_status" ~> postContainer.api_monitor_status.string
        updates = updates + s"${bridge_id}_Out_interface_failure" ~> postContainer.api_interface_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_ma_ma_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Manage_Alarm_i_thermostat_mt_ma_ma_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastCmd" ~> postContainer.lastCmd.string
        updates = updates + s"${bridge_id}_Out_alarm_control" ~> postContainer.api_alarm_control.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_mmm_mmm_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Manage_Monitor_Mode_i_thermostat_mt_mmm_mmm_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lastMonitorMode" ~> postContainer.lastMonitorMode.string
        updates = updates + s"${bridge_id}_Out_monitor_mode" ~> postContainer.api_monitor_mode.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_thermostat_mt_dmf_dmf_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Monitor.Detect_Monitor_Failure_i_thermostat_mt_dmf_dmf_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_internal_failure" ~> postContainer.api_internal_failure.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_operator_interface_oip_oit_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Operator_Interface.Operator_Interface_Thread_i_operator_interface_oip_oit_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_lower_desired_tempWstatus" ~> postContainer.api_lower_desired_tempWstatus.string
        updates = updates + s"${bridge_id}_Out_upper_desired_tempWstatus" ~> postContainer.api_upper_desired_tempWstatus.string
        updates = updates + s"${bridge_id}_Out_lower_alarm_tempWstatus" ~> postContainer.api_lower_alarm_tempWstatus.string
        updates = updates + s"${bridge_id}_Out_upper_alarm_tempWstatus" ~> postContainer.api_upper_alarm_tempWstatus.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_temperature_sensor_cpi_thermostat_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Devices.Temperature_Sensor_i_temperature_sensor_cpi_thermostat_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_current_tempWstatus" ~> postContainer.api_current_tempWstatus.string
        return updates
      case isolette.runtimemonitor.ObservationKind.Isolette_Single_Sensor_Instance_heat_source_cpi_heat_controller_postCompute =>
        var updates: Map[String, String] = Map.empty
        val postContainer = container.asInstanceOf[isolette.Devices.Heat_Source_i_heat_source_cpi_heat_controller_PostState_Container_PS]
        updates = updates + s"${bridge_id}_Out_heat_out" ~> postContainer.api_heat_out.string
        return updates
      case _ => return Map.empty
    }
  }
}