// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn timeout_condition_satisfied() -> bool
{
  false
}

/** Initialize EntryPointContract
  *
  * guarantee REQ_MMM_1
  *   Upon the first dispatch of the thread, the monitor mode is Init.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param api_monitor_mode outgoing data port
  */
pub fn initialize_REQ_MMM_1(api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode
}

/** IEP-Guar: Initialize Entrypoint for mmm
  *
  * @param lastMonitorMode post-state state variable
  * @param api_monitor_mode outgoing data port
  */
pub fn initialize_IEP_Guar(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  initialize_REQ_MMM_1(api_monitor_mode)
}

/** IEP-Post: Initialize Entrypoint Post-Condition
  *
  * @param lastMonitorMode post-state state variable
  * @param api_monitor_mode outgoing data port
  */
pub fn initialize_IEP_Post(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  initialize_IEP_Guar(lastMonitorMode, api_monitor_mode)
}

/** guarantee REQ_MMM_2
  *   If the current mode is Init, then
  *   the mode is set to NORMAL iff the monitor status is true (valid) (see Table A-15), i.e.,
  *   if  NOT (Monitor Interface Failure OR Monitor Internal Failure)
  *   AND Current Temperature.Status = Valid
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_case_REQ_MMM_2(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  implies!(
    lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,
    implies!(
      !(api_interface_failure.flag || api_internal_failure.flag) &&
        (api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),
      (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode)))
}

/** guarantee REQ_MMM_3
  *   If the current Monitor mode is Normal, then
  *   the Monitor mode is set to Failed iff
  *   the Monitor status is false, i.e.,
  *   if  (Monitor Interface Failure OR Monitor Internal Failure)
  *   OR NOT(Current Temperature.Status = Valid)
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_case_REQ_MMM_3(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  implies!(
    lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode,
    implies!(
      api_interface_failure.flag || api_internal_failure.flag ||
        (api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),
      (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode)))
}

/** guarantee REQ_MMM_4
  *   If the current mode is Init, then
  *   the mode is set to Failed iff the time during
  *   which the thread has been in Init mode exceeds the
  *   Monitor Init Timeout value.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param lastMonitorMode post-state state variable
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_case_REQ_MMM_4(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  implies!(
    lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,
    false == (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode))
}

/** CEP-T-Case: Top-Level case contracts for mmm's compute entrypoint
  *
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_CEP_T_Case(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  let r0: bool = compute_case_REQ_MMM_2(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);
  let r1: bool = compute_case_REQ_MMM_3(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);
  let r2: bool = compute_case_REQ_MMM_4(lastMonitorMode, api_monitor_mode);

  return r0 && r1 && r2;
}

/** CEP-Post: Compute Entrypoint Post-Condition for mmm
  *
  * @param In_lastMonitorMode pre-state state variable
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_CEP_Post(
  In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool
{
  // CEP-T-Case: case clauses of mmm's compute entrypoint
  let r0: bool = compute_CEP_T_Case(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);

  return r0;
}
