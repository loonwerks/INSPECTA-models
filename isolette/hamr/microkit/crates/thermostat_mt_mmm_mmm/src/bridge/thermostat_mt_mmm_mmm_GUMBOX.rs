// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

/** Initialize EntryPointContract
  *
  * guarantee REQ_MMM_1
  *   Upon the first dispatch of the thread, the monitor mode is Init.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param api_monitor_mode outgoing data port
  */
pub fn initialize_REQ_MMM_1(api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode
 }

/** IEP-Guar: Initialize Entrypoint for mmm
  *
  * @param lastMonitorMode post-state state variable
  * @param api_monitor_mode outgoing data port
  */
pub fn initialize_IEP_Guar(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   initialize_REQ_MMM_1(api_monitor_mode)
 }

/** IEP-Post: Initialize Entrypoint Post-Condition
  *
  * @param lastMonitorMode post-state state variable
  * @param api_monitor_mode outgoing data port
  */
pub fn initialize_IEP_Post(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   initialize_IEP_Guar(lastMonitorMode, api_monitor_mode)
 }

/** guarantee REQ_MMM_2
  *   If the current mode is Init, then
  *   the mode is set to NORMAL iff the monitor status is true (valid) (see Table A-15), i.e.,
  *   if  NOT (Monitor Interface Failure OR Monitor Internal Failure)
  *   AND Current Temperature.Status = Valid
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_case_REQ_MMM_2(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   implies(
     lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,
     implies(
       !(api_interface_failure.flag || api_internal_failure.flag) &&
         api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid,
       api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode))
 }

/** guarantee REQ_MMM_3
  *   If the current Monitor mode is Normal, then
  *   the Monitor mode is set to Failed iff
  *   the Monitor status is false, i.e.,
  *   if  (Monitor Interface Failure OR Monitor Internal Failure)
  *   OR NOT(Current Temperature.Status = Valid)
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_case_REQ_MMM_3(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   implies(
     lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Normal_Monitor_Mode,
     implies(
       api_interface_failure.flag || api_internal_failure.flag ||
         api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid,
       api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode))
 }

/** guarantee REQ_MMM_4
  *   If the current mode is Init, then
  *   the mode is set to Failed iff the time during
  *   which the thread has been in Init mode exceeds the
  *   Monitor Init Timeout value.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=114 
  * @param lastMonitorMode post-state state variable
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_case_REQ_MMM_4(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   implies(
     lastMonitorMode == Isolette_Data_Model::Monitor_Mode::Init_Monitor_Mode,
     true == (api_monitor_mode == Isolette_Data_Model::Monitor_Mode::Failed_Monitor_Mode))
 }

/** CEP-T-Case: Top-Level case contracts for mmm's compute entrypoint
  *
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_CEP_T_Case(
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   let r0: bool = compute_case_REQ_MMM_2(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);
   let r1: bool = compute_case_REQ_MMM_3(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);
   let r2: bool = compute_case_REQ_MMM_4(lastMonitorMode, api_monitor_mode);

   return r0 && r1 && r2;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for mmm
  *
  * @param In_lastMonitorMode pre-state state variable
  * @param lastMonitorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_monitor_mode outgoing data port
  */
pub fn compute_CEP_Post(
  In_lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  lastMonitorMode: Isolette_Data_Model::Monitor_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_monitor_mode: Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   // CEP-T-Case: case clauses of mmm's compute entrypoint
   let r0: bool = compute_CEP_T_Case(lastMonitorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_monitor_mode);

   return r0;
 }
