// Do not edit this file as it will be overwritten if codegen is rerun

//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to be verified by other means.

use crate::data::*;

#[cfg(test)]
use std::sync::Mutex;

#[cfg(not(test))]
extern "C" {
  fn get_regulator_status(value: *mut Isolette_Data_Model::Status) -> bool;
  fn get_heat_control(value: *mut Isolette_Data_Model::On_Off) -> bool;
  fn get_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool;
  fn get_regulator_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;
  fn get_monitor_status(value: *mut Isolette_Data_Model::Status) -> bool;
  fn get_alarm_control(value: *mut Isolette_Data_Model::On_Off) -> bool;
  fn get_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool;
  fn get_monitor_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;
  fn get_lower_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;
  fn get_upper_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;
  fn get_lower_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;
  fn get_upper_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;
  fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool;
  fn get_displayed_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool;
}

pub fn unsafe_get_regulator_status() -> Isolette_Data_Model::Status 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Status = &mut Isolette_Data_Model::Status::default();
     get_regulator_status(value);
     return *value;
   }
 }

pub fn unsafe_get_heat_control() -> Isolette_Data_Model::On_Off 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::On_Off = &mut Isolette_Data_Model::On_Off::default();
     get_heat_control(value);
     return *value;
   }
 }

pub fn unsafe_get_regulator_mode() -> Isolette_Data_Model::Regulator_Mode 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Regulator_Mode = &mut Isolette_Data_Model::Regulator_Mode::default();
     get_regulator_mode(value);
     return *value;
   }
 }

pub fn unsafe_get_regulator_internal_failure() -> Isolette_Data_Model::Failure_Flag_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Failure_Flag_i = &mut Isolette_Data_Model::Failure_Flag_i::default();
     get_regulator_internal_failure(value);
     return *value;
   }
 }

pub fn unsafe_get_monitor_status() -> Isolette_Data_Model::Status 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Status = &mut Isolette_Data_Model::Status::default();
     get_monitor_status(value);
     return *value;
   }
 }

pub fn unsafe_get_alarm_control() -> Isolette_Data_Model::On_Off 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::On_Off = &mut Isolette_Data_Model::On_Off::default();
     get_alarm_control(value);
     return *value;
   }
 }

pub fn unsafe_get_monitor_mode() -> Isolette_Data_Model::Monitor_Mode 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Monitor_Mode = &mut Isolette_Data_Model::Monitor_Mode::default();
     get_monitor_mode(value);
     return *value;
   }
 }

pub fn unsafe_get_monitor_internal_failure() -> Isolette_Data_Model::Failure_Flag_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Failure_Flag_i = &mut Isolette_Data_Model::Failure_Flag_i::default();
     get_monitor_internal_failure(value);
     return *value;
   }
 }

pub fn unsafe_get_lower_desired_tempWstatus() -> Isolette_Data_Model::TempWstatus_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();
     get_lower_desired_tempWstatus(value);
     return *value;
   }
 }

pub fn unsafe_get_upper_desired_tempWstatus() -> Isolette_Data_Model::TempWstatus_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();
     get_upper_desired_tempWstatus(value);
     return *value;
   }
 }

pub fn unsafe_get_lower_alarm_tempWstatus() -> Isolette_Data_Model::TempWstatus_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();
     get_lower_alarm_tempWstatus(value);
     return *value;
   }
 }

pub fn unsafe_get_upper_alarm_tempWstatus() -> Isolette_Data_Model::TempWstatus_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();
     get_upper_alarm_tempWstatus(value);
     return *value;
   }
 }

pub fn unsafe_get_current_tempWstatus() -> Isolette_Data_Model::TempWstatus_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::TempWstatus_i = &mut Isolette_Data_Model::TempWstatus_i::default();
     get_current_tempWstatus(value);
     return *value;
   }
 }

pub fn unsafe_get_displayed_temp() -> Isolette_Data_Model::Temp_i 
 {
   unsafe {
     let value: *mut Isolette_Data_Model::Temp_i = &mut Isolette_Data_Model::Temp_i::default();
     get_displayed_temp(value);
     return *value;
   }
 }

//////////////////////////////////////////////////////////////////////////////////
// Testing Versions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w,
  // but we couldn't do that for in ports since they are read-only
  pub static ref IN_regulator_status: Mutex<Option<Isolette_Data_Model::Status>> = Mutex::new(None);
  pub static ref IN_heat_control: Mutex<Option<Isolette_Data_Model::On_Off>> = Mutex::new(None);
  pub static ref IN_regulator_mode: Mutex<Option<Isolette_Data_Model::Regulator_Mode>> = Mutex::new(None);
  pub static ref IN_regulator_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);
  pub static ref IN_monitor_status: Mutex<Option<Isolette_Data_Model::Status>> = Mutex::new(None);
  pub static ref IN_alarm_control: Mutex<Option<Isolette_Data_Model::On_Off>> = Mutex::new(None);
  pub static ref IN_monitor_mode: Mutex<Option<Isolette_Data_Model::Monitor_Mode>> = Mutex::new(None);
  pub static ref IN_monitor_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);
  pub static ref IN_lower_desired_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);
  pub static ref IN_upper_desired_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);
  pub static ref IN_lower_alarm_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);
  pub static ref IN_upper_alarm_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);
  pub static ref IN_current_tempWstatus: Mutex<Option<Isolette_Data_Model::TempWstatus_i>> = Mutex::new(None);
  pub static ref IN_displayed_temp: Mutex<Option<Isolette_Data_Model::Temp_i>> = Mutex::new(None);
}

#[cfg(test)]
pub fn get_regulator_status(value: *mut Isolette_Data_Model::Status) -> bool 
 {
   unsafe {
     *value = IN_regulator_status.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_heat_control(value: *mut Isolette_Data_Model::On_Off) -> bool 
 {
   unsafe {
     *value = IN_heat_control.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_regulator_mode(value: *mut Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   unsafe {
     *value = IN_regulator_mode.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_regulator_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool 
 {
   unsafe {
     *value = IN_regulator_internal_failure.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_monitor_status(value: *mut Isolette_Data_Model::Status) -> bool 
 {
   unsafe {
     *value = IN_monitor_status.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_alarm_control(value: *mut Isolette_Data_Model::On_Off) -> bool 
 {
   unsafe {
     *value = IN_alarm_control.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_monitor_mode(value: *mut Isolette_Data_Model::Monitor_Mode) -> bool 
 {
   unsafe {
     *value = IN_monitor_mode.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_monitor_internal_failure(value: *mut Isolette_Data_Model::Failure_Flag_i) -> bool 
 {
   unsafe {
     *value = IN_monitor_internal_failure.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_lower_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   unsafe {
     *value = IN_lower_desired_tempWstatus.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_upper_desired_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   unsafe {
     *value = IN_upper_desired_tempWstatus.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_lower_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   unsafe {
     *value = IN_lower_alarm_tempWstatus.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_upper_alarm_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   unsafe {
     *value = IN_upper_alarm_tempWstatus.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_current_tempWstatus(value: *mut Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   unsafe {
     *value = IN_current_tempWstatus.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_displayed_temp(value: *mut Isolette_Data_Model::Temp_i) -> bool 
 {
   unsafe {
     *value = IN_displayed_temp.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }
