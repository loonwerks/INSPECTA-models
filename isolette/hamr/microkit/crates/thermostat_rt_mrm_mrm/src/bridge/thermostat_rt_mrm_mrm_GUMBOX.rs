// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

/** Initialize EntryPointContract
  *
  * guarantee REQ_MRM_1
  *   The initial mode of the regular is INIT
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param api_regulator_mode outgoing data port
  */
pub fn initialize_REQ_MRM_1(api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode
}

/** IEP-Guar: Initialize Entrypoint for mrm
  *
  * @param lastRegulatorMode post-state state variable
  * @param api_regulator_mode outgoing data port
  */
pub fn initialize_IEP_Guar(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  initialize_REQ_MRM_1(api_regulator_mode)
}

/** IEP-Post: Initialize Entrypoint Post-Condition
  *
  * @param lastRegulatorMode post-state state variable
  * @param api_regulator_mode outgoing data port
  */
pub fn initialize_IEP_Post(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  initialize_IEP_Guar(lastRegulatorMode, api_regulator_mode)
}

/** guarantee REQ_MRM_2
  *   'transition from Init to Normal'
  *   If the current regulator mode is Init, then
  *   the regulator mode is set to NORMAL iff the regulator status is valid (see Table A-10), i.e.,
  *     if NOT (Regulator Interface Failure OR Regulator Internal Failure)
  *        AND Current Temperature.Status = Valid
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_2(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  implies!(
    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,
    implies!(
      !(api_interface_failure.flag || api_internal_failure.flag) &&
        (api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),
      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&
        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode)))
}

/** guarantee REQ_MRM_Maintain_Normal
  *   'maintaining NORMAL, NORMAL to NORMAL'
  *   If the current regulator mode is Normal, then
  *   the regulator mode is stays normal iff
  *   the regulaor status is not false i.e.,
  *          if NOT(
  *              (Regulator Interface Failure OR Regulator Internal Failure)
  *              OR NOT(Current Temperature.Status = Valid)
  *          )
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_Maintain_Normal(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  implies!(
    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,
    implies!(
      !(api_interface_failure.flag || api_internal_failure.flag) &&
        (api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid),
      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode) &&
        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode)))
}

/** guarantee REQ_MRM_3
  *   'transition for NORMAL to FAILED'
  *   If the current regulator mode is Normal, then
  *   the regulator mode is set to Failed iff
  *   the regulator status is false, i.e.,
  *      if  (Regulator Interface Failure OR Regulator Internal Failure)
  *          OR NOT(Current Temperature.Status = Valid)
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_3(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  implies!(
    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,
    implies!(
      (api_interface_failure.flag || api_internal_failure.flag) &&
        (api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),
      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&
        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)))
}

/** guarantee REQ_MRM_4
  *   'transition from INIT to FAILED' 
  *   If the current regulator mode is Init, then
  *   the regulator mode and lastRegulatorMode state value is set to Failed iff
  *   the regulator status is false, i.e.,
  *          if  (Regulator Interface Failure OR Regulator Internal Failure)
  *          OR NOT(Current Temperature.Status = Valid)
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_4(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  implies!(
    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,
    implies!(
      (api_interface_failure.flag || api_internal_failure.flag) &&
        (api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),
      (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&
        (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)))
}

/** guarantee REQ_MRM_MaintainFailed
  *   'maintaining FAIL, FAIL to FAIL'
  *   If the current regulator mode is Failed, then
  *   the regulator mode remains in the Failed state and the LastRegulator mode remains Failed.REQ-MRM-Maintain-Failed
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109
  * @param lastRegulatorMode post-state state variable
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_MaintainFailed(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  implies!(
    lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode,
    (api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode) &&
      (lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode))
}

/** CEP-T-Case: Top-Level case contracts for mrm's compute entrypoint
  *
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_CEP_T_Case(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  let r0: bool = compute_case_REQ_MRM_2(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
  let r1: bool = compute_case_REQ_MRM_Maintain_Normal(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
  let r2: bool = compute_case_REQ_MRM_3(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
  let r3: bool = compute_case_REQ_MRM_4(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
  let r4: bool = compute_case_REQ_MRM_MaintainFailed(lastRegulatorMode, api_regulator_mode);

  return r0 && r1 && r2 && r3 && r4;
}

/** CEP-Post: Compute Entrypoint Post-Condition for mrm
  *
  * @param In_lastRegulatorMode pre-state state variable
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_CEP_Post(
  In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool
{
  // CEP-T-Case: case clauses of mrm's compute entrypoint
  let r0: bool = compute_CEP_T_Case(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);

  return r0;
}
