// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

/** Initialize EntryPointContract
  *
  * guarantee REQ_MRM_1
  *   The initial mode of the regular is INIT
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param api_regulator_mode outgoing data port
  */
pub fn initialize_REQ_MRM_1(api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode
 }

/** IEP-Guar: Initialize Entrypoint for mrm
  *
  * @param lastRegulatorMode post-state state variable
  * @param api_regulator_mode outgoing data port
  */
pub fn initialize_IEP_Guar(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   initialize_REQ_MRM_1(api_regulator_mode)
 }

/** IEP-Post: Initialize Entrypoint Post-Condition
  *
  * @param lastRegulatorMode post-state state variable
  * @param api_regulator_mode outgoing data port
  */
pub fn initialize_IEP_Post(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   initialize_IEP_Guar(lastRegulatorMode, api_regulator_mode)
 }

/** guarantee REQ_MRM_2
  *   'transition from Init to Normal'
  *   If the current regulator mode is Init, then
  *   the regulator mode is set to NORMAL iff the regulator status is valid (see Table A-10), i.e.,
  *     if NOT (Regulator Interface Failure OR Regulator Internal Failure)
  *        AND Current Temperature.Status = Valid
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_2(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   implies(
     lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,
     implies(
       !(api_interface_failure.flag || api_internal_failure.flag) &&
         api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid,
       api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode &&
         lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode))
 }

/** guarantee REQ_MRM_Maintain_Normal
  *   'maintaining NORMAL, NORMAL to NORMAL'
  *   If the current regulator mode is Normal, then
  *   the regulator mode is stays normal iff
  *   the regulaor status is not false i.e.,
  *          if NOT(
  *              (Regulator Interface Failure OR Regulator Internal Failure)
  *              OR NOT(Current Temperature.Status = Valid)
  *          )
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_Maintain_Normal(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   implies(
     lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,
     implies(
       !(api_interface_failure.flag || api_internal_failure.flag) &&
         api_current_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid,
       api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode &&
         lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode))
 }

/** guarantee REQ_MRM_3
  *   'transition for NORMAL to FAILED'
  *   If the current regulator mode is Normal, then
  *   the regulator mode is set to Failed iff
  *   the regulator status is false, i.e.,
  *      if  (Regulator Interface Failure OR Regulator Internal Failure)
  *          OR NOT(Current Temperature.Status = Valid)
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109 
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_3(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   implies(
     lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,
     implies(
       (api_interface_failure.flag || api_internal_failure.flag) &&
         api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid,
       api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode &&
         lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode))
 }

/** guarantee REQ_MRM_4
  *   'transition from INIT to FAILED' 
  *   If the current regulator mode is Init, then
  *   the regulator mode and lastRegulatorMode state value is set to Failed iff
  *   the regulator status is false, i.e.,
  *          if  (Regulator Interface Failure OR Regulator Internal Failure)
  *          OR NOT(Current Temperature.Status = Valid)
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_4(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   implies(
     lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,
     implies(
       (api_interface_failure.flag || api_internal_failure.flag) &&
         api_current_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid,
       api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode &&
         lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode))
 }

/** guarantee REQ_MRM_MaintainFailed
  *   'maintaining FAIL, FAIL to FAIL'
  *   If the current regulator mode is Failed, then
  *   the regulator mode remains in the Failed state and the LastRegulator mode remains Failed.REQ-MRM-Maintain-Failed
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=109
  * @param lastRegulatorMode post-state state variable
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_case_REQ_MRM_MaintainFailed(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   implies(
     lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode,
     api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode &&
       lastRegulatorMode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode)
 }

/** CEP-T-Case: Top-Level case contracts for mrm's compute entrypoint
  *
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_CEP_T_Case(
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   let r0: bool = compute_case_REQ_MRM_2(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
   let r1: bool = compute_case_REQ_MRM_Maintain_Normal(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
   let r2: bool = compute_case_REQ_MRM_3(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
   let r3: bool = compute_case_REQ_MRM_4(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);
   let r4: bool = compute_case_REQ_MRM_MaintainFailed(lastRegulatorMode, api_regulator_mode);

   return r0 && r1 && r2 && r3 && r4;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for mrm
  *
  * @param In_lastRegulatorMode pre-state state variable
  * @param lastRegulatorMode post-state state variable
  * @param api_current_tempWstatus incoming data port
  * @param api_interface_failure incoming data port
  * @param api_internal_failure incoming data port
  * @param api_regulator_mode outgoing data port
  */
pub fn compute_CEP_Post(
  In_lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  lastRegulatorMode: Isolette_Data_Model::Regulator_Mode,
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_internal_failure: Isolette_Data_Model::Failure_Flag_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode) -> bool 
 {
   // CEP-T-Case: case clauses of mrm's compute entrypoint
   let r0: bool = compute_CEP_T_Case(lastRegulatorMode, api_current_tempWstatus, api_interface_failure, api_internal_failure, api_regulator_mode);

   return r0;
 }
