// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

/** Initialize EntryPointContract
  *
  * guarantee RegulatorStatusIsInitiallyInit
  * @param api_regulator_status outgoing data port
  */
pub fn initialize_RegulatorStatusIsInitiallyInit(api_regulator_status: Isolette_Data_Model::Status) -> bool 
 {
   api_regulator_status == Isolette_Data_Model::Status::Init_Status
 }

/** IEP-Guar: Initialize Entrypoint for mri
  *
  * @param api_displayed_temp outgoing data port
  * @param api_interface_failure outgoing data port
  * @param api_lower_desired_temp outgoing data port
  * @param api_regulator_status outgoing data port
  * @param api_upper_desired_temp outgoing data port
  */
pub fn initialize_IEP_Guar(
  api_displayed_temp: Isolette_Data_Model::Temp_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_lower_desired_temp: Isolette_Data_Model::Temp_i,
  api_regulator_status: Isolette_Data_Model::Status,
  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool 
 {
   initialize_RegulatorStatusIsInitiallyInit(api_regulator_status)
 }

/** IEP-Post: Initialize Entrypoint Post-Condition
  *
  * @param api_displayed_temp outgoing data port
  * @param api_interface_failure outgoing data port
  * @param api_lower_desired_temp outgoing data port
  * @param api_regulator_status outgoing data port
  * @param api_upper_desired_temp outgoing data port
  */
pub fn initialize_IEP_Post(
  api_displayed_temp: Isolette_Data_Model::Temp_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_lower_desired_temp: Isolette_Data_Model::Temp_i,
  api_regulator_status: Isolette_Data_Model::Status,
  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool 
 {
   initialize_IEP_Guar(api_displayed_temp, api_interface_failure, api_lower_desired_temp, api_regulator_status, api_upper_desired_temp)
 }

/** Compute Entrypoint Contract
  *
  * assumes lower_is_not_higher_than_upper
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  */
pub fn compute_spec_lower_is_not_higher_than_upper_assume(
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   api_lower_desired_tempWstatus.degrees <= api_upper_desired_tempWstatus.degrees
 }

/** CEP-T-Assm: Top-level assume contracts for mri's compute entrypoint
  *
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  */
pub fn compute_CEP_T_Assm(
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   let r0: bool = compute_spec_lower_is_not_higher_than_upper_assume(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus);

   return r0;
 }

/** CEP-Pre: Compute Entrypoint Pre-Condition for mri
  *
  * @param api_current_tempWstatus incoming data port
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_regulator_mode incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  */
pub fn compute_CEP_Pre(
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i) -> bool 
 {
   // CEP-Assm: assume clauses of mri's compute entrypoint
   let r0: bool = compute_CEP_T_Assm(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus);

   return r0;
 }

/** guarantee REQ_MRI_1
  *   If the Regulator Mode is INIT,
  *   the Regulator Status shall be set to Init.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=107 
  * @param api_regulator_mode incoming data port
  * @param api_regulator_status outgoing data port
  */
pub fn compute_case_REQ_MRI_1(
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_status: Isolette_Data_Model::Status) -> bool 
 {
   implies(
     api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Init_Regulator_Mode,
     api_regulator_status == Isolette_Data_Model::Status::Init_Status)
 }

/** guarantee REQ_MRI_2
  *   If the Regulator Mode is NORMAL,
  *   the Regulator Status shall be set to On
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=107 
  * @param api_regulator_mode incoming data port
  * @param api_regulator_status outgoing data port
  */
pub fn compute_case_REQ_MRI_2(
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_status: Isolette_Data_Model::Status) -> bool 
 {
   implies(
     api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,
     api_regulator_status == Isolette_Data_Model::Status::On_Status)
 }

/** guarantee REQ_MRI_3
  *   If the Regulator Mode is FAILED,
  *   the Regulator Status shall be set to Failed.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=107 
  * @param api_regulator_mode incoming data port
  * @param api_regulator_status outgoing data port
  */
pub fn compute_case_REQ_MRI_3(
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_regulator_status: Isolette_Data_Model::Status) -> bool 
 {
   implies(
     api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Failed_Regulator_Mode,
     api_regulator_status == Isolette_Data_Model::Status::Failed_Status)
 }

/** guarantee REQ_MRI_4
  *   If the Regulator Mode is NORMAL, the
  *   Display Temperature shall be set to the value of the
  *   Current Temperature rounded to the nearest integer.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=108 
  * @param api_current_tempWstatus incoming data port
  * @param api_regulator_mode incoming data port
  * @param api_displayed_temp outgoing data port
  */
pub fn compute_case_REQ_MRI_4(
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_displayed_temp: Isolette_Data_Model::Temp_i) -> bool 
 {
   implies(
     api_regulator_mode == Isolette_Data_Model::Regulator_Mode::Normal_Regulator_Mode,
     api_displayed_temp.degrees == api_current_tempWstatus.degrees)
 }

/** guarantee REQ_MRI_5
  *   If the Regulator Mode is not NORMAL,
  *   the value of the Display Temperature is UNSPECIFIED.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=108 
  */
pub fn compute_case_REQ_MRI_5() -> bool 
 {
   implies(
     true,
     true)
 }

/** guarantee REQ_MRI_6
  *   If the Status attribute of the Lower Desired Temperature
  *   or the Upper Desired Temperature is Invalid,
  *   the Regulator Interface Failure shall be set to True.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=108 
  * @param api_upper_desired_tempWstatus incoming data port
  * @param api_interface_failure outgoing data port
  */
pub fn compute_case_REQ_MRI_6(
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool 
 {
   implies(
     (api_upper_desired_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid) |
       (api_upper_desired_tempWstatus.status != Isolette_Data_Model::ValueStatus::Valid),
     api_interface_failure.flag)
 }

/** guarantee REQ_MRI_7
  *   If the Status attribute of the Lower Desired Temperature
  *   and the Upper Desired Temperature is Valid,
  *   the Regulator Interface Failure shall be set to False.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=108 
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  * @param api_interface_failure outgoing data port
  */
pub fn compute_case_REQ_MRI_7(
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i) -> bool 
 {
   implies(
     true,
     api_interface_failure.flag == !((api_upper_desired_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid) &
       (api_lower_desired_tempWstatus.status == Isolette_Data_Model::ValueStatus::Valid)))
 }

/** guarantee REQ_MRI_8
  *   If the Regulator Interface Failure is False,
  *   the Desired Range shall be set to the Desired Temperature Range.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=108 
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  * @param api_interface_failure outgoing data port
  * @param api_lower_desired_temp outgoing data port
  * @param api_upper_desired_temp outgoing data port
  */
pub fn compute_case_REQ_MRI_8(
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_lower_desired_temp: Isolette_Data_Model::Temp_i,
  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool 
 {
   implies(
     true,
     impliesL(
       !(api_interface_failure.flag),
       (api_lower_desired_temp.degrees == api_lower_desired_tempWstatus.degrees) &
         (api_upper_desired_temp.degrees == api_upper_desired_tempWstatus.degrees)))
 }

/** guarantee REQ_MRI_9
  *   If the Regulator Interface Failure is True,
  *   the Desired Range is UNSPECIFIED.
  *   the Desired Range shall be set to the Desired Temperature Range.
  *   http://pub.santoslab.org/high-assurance/module-requirements/reading/FAA-DoT-Requirements-AR-08-32.pdf#page=108 
  */
pub fn compute_case_REQ_MRI_9() -> bool 
 {
   implies(
     true,
     true)
 }

/** CEP-T-Case: Top-Level case contracts for mri's compute entrypoint
  *
  * @param api_current_tempWstatus incoming data port
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_regulator_mode incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  * @param api_displayed_temp outgoing data port
  * @param api_interface_failure outgoing data port
  * @param api_lower_desired_temp outgoing data port
  * @param api_regulator_status outgoing data port
  * @param api_upper_desired_temp outgoing data port
  */
pub fn compute_CEP_T_Case(
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_displayed_temp: Isolette_Data_Model::Temp_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_lower_desired_temp: Isolette_Data_Model::Temp_i,
  api_regulator_status: Isolette_Data_Model::Status,
  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool 
 {
   let r0: bool = compute_case_REQ_MRI_1(api_regulator_mode, api_regulator_status);
   let r1: bool = compute_case_REQ_MRI_2(api_regulator_mode, api_regulator_status);
   let r2: bool = compute_case_REQ_MRI_3(api_regulator_mode, api_regulator_status);
   let r3: bool = compute_case_REQ_MRI_4(api_current_tempWstatus, api_regulator_mode, api_displayed_temp);
   let r4: bool = compute_case_REQ_MRI_5();
   let r5: bool = compute_case_REQ_MRI_6(api_upper_desired_tempWstatus, api_interface_failure);
   let r6: bool = compute_case_REQ_MRI_7(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus, api_interface_failure);
   let r7: bool = compute_case_REQ_MRI_8(api_lower_desired_tempWstatus, api_upper_desired_tempWstatus, api_interface_failure, api_lower_desired_temp, api_upper_desired_temp);
   let r8: bool = compute_case_REQ_MRI_9();

   return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for mri
  *
  * @param api_current_tempWstatus incoming data port
  * @param api_lower_desired_tempWstatus incoming data port
  * @param api_regulator_mode incoming data port
  * @param api_upper_desired_tempWstatus incoming data port
  * @param api_displayed_temp outgoing data port
  * @param api_interface_failure outgoing data port
  * @param api_lower_desired_temp outgoing data port
  * @param api_regulator_status outgoing data port
  * @param api_upper_desired_temp outgoing data port
  */
pub fn compute_CEP_Post(
  api_current_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_lower_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_regulator_mode: Isolette_Data_Model::Regulator_Mode,
  api_upper_desired_tempWstatus: Isolette_Data_Model::TempWstatus_i,
  api_displayed_temp: Isolette_Data_Model::Temp_i,
  api_interface_failure: Isolette_Data_Model::Failure_Flag_i,
  api_lower_desired_temp: Isolette_Data_Model::Temp_i,
  api_regulator_status: Isolette_Data_Model::Status,
  api_upper_desired_temp: Isolette_Data_Model::Temp_i) -> bool 
 {
   // CEP-T-Case: case clauses of mri's compute entrypoint
   let r0: bool = compute_CEP_T_Case(api_current_tempWstatus, api_lower_desired_tempWstatus, api_regulator_mode, api_upper_desired_tempWstatus, api_displayed_temp, api_interface_failure, api_lower_desired_temp, api_regulator_status, api_upper_desired_temp);

   return r0;
 }
