// Do not edit this file as it will be overwritten if codegen is rerun

//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to be verified by other means.

use crate::data::*;

#[cfg(test)]
use std::sync::Mutex;

#[cfg(not(test))]
extern "C" {
  fn put_internal_failure(data: *mut Isolette_Data_Model::Failure_Flag_i) -> bool;
}

pub fn unsafe_put_internal_failure(data: &Isolette_Data_Model::Failure_Flag_i) -> bool 
 {
   unsafe {
     return put_internal_failure(data as *const Isolette_Data_Model::Failure_Flag_i as *mut Isolette_Data_Model::Failure_Flag_i);
   }
 }

//////////////////////////////////////////////////////////////////////////////////
// Testing Versions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w,
  // but we couldn't do that for in ports since they are read-only
  pub static ref OUT_internal_failure: Mutex<Option<Isolette_Data_Model::Failure_Flag_i>> = Mutex::new(None);
}

#[cfg(test)]
pub fn put_internal_failure(data: *mut Isolette_Data_Model::Failure_Flag_i) -> bool 
 {
   unsafe {
     *OUT_internal_failure.lock().unwrap() = Some(*data);
     return true;
   }
 }
