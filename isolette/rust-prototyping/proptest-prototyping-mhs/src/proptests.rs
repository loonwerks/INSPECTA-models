// Prototyping concepts for the HAMR/Rust automated property testing framework
// using the Rust propTest framework.  https://proptest-rs.github.io/proptest/intro.html
//
// This leverages the auto-generated GUMBOX Rust executable contracts, which implement
// an "executable" semantics for the GUMBO auto-generated Verus contracts.
//
// Key capabilities of the proposed framework.
//  - The developer gets (completely automatically - due to HAMR code generation), 
//    a "push-button" facility for launching randomized (fuzzing) tests on a 
//    components application where the executable GUMBOX contracts act as test oracles.
//    The semantics of the test oracles matches the model-level GUMBO contracts and code-level
//    Verus contracts.
//  - The developer can customize the default generated testing configurations with 
//    different random value generation strategies (e.g., different ranges for numeric types)
//    for each component input port and local state variable.
//  - PropTest features...
//      - automatically "simplifies" a failing test vector to get a test that is 
//        easier for the developer to understand
//      - caches randomizing seeds and test vectors for failing tests for each replay
//        and incorporation into regression tests
//      - has easy-to-use configurations that enable developers (or continuous integration
//        frameworks) to configure desired number of random tests etc.
//   - Uses the testing framework to provide counterexamples for Verus verification failures
//   - Uses LLM technology to explain failing tests and contract violations and to propose
//     fixes (see the file ./grok-explain-mhs-2-bug.md)
// 
// The implementation approach is very similar to the HAMR Slang automated property testing
// framework.
//   - Default random value generation strategies are auto-generated by HAMR for each
//     AADL-level type (e.g., port types)
//   - These data type strategies are aggregated into "tuple strategies" to form
//     a random generator for input test vectors match the component type signature for
//     input ports and GUMBO declared local state
//   - Random test vectors are fed into an HAMR-auto-generated test harness that
//     invokes the developer's application code for the component while automatically
//     applying auto-generated GUMBOX pre/post conditions for the component
//   - all of the above is set up automatically via HAMR code generation;
//     the developer only needs to "push a button" or run "cargo test" to invoke.
//     And then defaults can be customized.
//
//  It appears possible to also integrate coverage reporting from lower level LVM 
//  converage tools, but I will look at that in the future.
//
//  

#[cfg(test)]

mod proptests {
    // NOTE: need to run tests sequentially to prevent race conditions
    //       on the app and the testing apis which are static
  use serial_test::serial;
  
  use crate::component::thermostat_rt_mhs_mhs_app::thermostat_rt_mhs_mhs;
  
  use crate::bridge::extern_c_api as extern_api;
  use crate::bridge::thermostat_rt_mhs_mhs_GUMBOX as GUMBOX;

  use crate::data::*;
  use crate::data::Isolette_Data_Model::*;  

  const failOnUnsatPrecondition: bool = false;

  use proptest::prelude::*;

  // Define a simple function used to illustrate proptest features on the Temp_i data type.
fn is_temp_below_500(temp: Temp_i) -> bool {
    temp.degrees < 500
 }

 // proptest API documentation - https://docs.rs/proptest/latest/proptest/index.html
 //
 //  
 #[test]
 #[serial]
 // Define a non-proptest test that succeeds (with value less that 500).
 fn test_temp_below_500() {
    let temp = Temp_i { degrees: 300 };
    assert!(is_temp_below_500(temp), "Temp of 300 should be below 500");
 }
     
 #[test]
 #[serial]
 // Define a non-proptest test that succeeds (with value over 500)
 fn test_temp_above_500() {
    let temp = Temp_i { degrees: 600 };
    assert!(!is_temp_below_500(temp), "Temp of 600 should not be below 500");
 }

 // Use proptest! macro to configure an automated proptest that will 
 // test test_temp_above_500 on degree values between 0 and 1000.
 // (with a precondition/filter also configured to weed out 
 // values less than 500).
 proptest! {
    #![proptest_config(ProptestConfig::with_cases(100))]
    #[test]
    fn test_is_temp_below_500_prop_1(degrees in 0i32..1000i32) {
        // Use a proptest filter (prop_assume!) to model a pre-condition
        // for the method that ensures that the method result is always "true"

        // Input illegal if degrees < 500.
        // Equivalent to
        // if (degrees < 500) { return Err(TestCaseError::Reject(...)); }
        prop_assume!(degrees < 500);

        // contruct the argument to the function being tested.
        let temp = Temp_i { degrees };
        assert!(
            is_temp_below_500(temp)
        );
    }
}

 proptest! {
    #![proptest_config(ProptestConfig::with_cases(100))]
    #[test]
    fn test_is_temp_below_500_prop_2(degrees in 0i32..1000i32) {
        let temp = Temp_i { degrees };
        prop_assert_eq!(
            is_temp_below_500(temp),
            degrees < 500, 
            "is_temp_below_500 should return true if degrees < 500, false otherwise"
        );
    }
}

proptest! {
    #![proptest_config(ProptestConfig {
        cases: 100,
        verbose: 2, // Enable verbose shrinking output
        ..ProptestConfig::default()
    })]
    #[test]
    fn test_is_temp_below_500_prop_3(degrees in 0i32..1000i32) {
        let temp = Temp_i { degrees };
        prop_assert!(
            is_temp_below_500(temp),
            "is_temp_below_500 should always return true (this is wrong to show shrinking)"
        );
    }
}

//=========================================================
//  Temp_i  Strategies
//=========================================================

// The above approach is using i32 strategies (phrased as ranges).   For the 
// HAMR testing framework, we want a strategy that returns values of Temp_i but still can be 
// parameterized on an i32 range.
// Grok suggested the following.

// To create a proptest strategy for the Temp_i type that allows configuring 
// an i32 range for the degrees field, you can use proptest's Arbitrary trait 
// and define a custom strategy using a range. Below is the complete code to achieve 
// this.


// Define a strategy for Temp_i with a configurable i32 range
prop_compose! {
    pub fn temp_i_strategy_range(min: i32, max: i32)
        (degrees in min..=max)
        -> Temp_i {
        Temp_i { degrees }
    }
}

// Example use
proptest! {
    #[test]
    fn test_temp_i(temp in temp_i_strategy_range(-100, 100)) {
        prop_assert!(temp.degrees >= -100 && temp.degrees <= 100);
    }
}

// Define a strategy with the same behavior but using prop_map directly without the prop_test! macro

// Define a strategy for Temp_i with a configurable i32 range using prop_map
pub fn temp_i_strategy_range_prop_map(min: i32, max: i32) -> impl Strategy<Value = Temp_i> {
    (min..=max).prop_map(|degrees| Temp_i { degrees })
}

// Example use
proptest! {
    #[test]
    fn test_temp_i_1(temp in temp_i_strategy_range(-100, 100)) {
        prop_assert!(temp.degrees >= -100 && temp.degrees <= 100);
    }
}


// In general, the proptest approach for building strategies for composite types 
// is explained here:  https://proptest-rs.github.io/proptest/proptest/tutorial/transforming-strategies.html
// This approach uses prop_map as the basic work horse to build strategies for new types.
// The prop_compose macro helps simplify the use of prop_map
// (see https://docs.rs/proptest/latest/proptest/macro.prop_compose.html).
// Regarding filters, the prop_compose macro doesn't work when you need to add a filter.
// In such cases, you need to define the strategy in the "long" (non-macro) way.


// From the proptest documentation (https://proptest-rs.github.io/proptest/proptest/tutorial/enums.html).
// "Enum cases with data generally require putting the data in a tuple and then using prop_map to 
//  map it into the enum case." (an example is given)

//=========================================================
//  ValueStatus  Strategies
//
//  (Generated by Grok by feeding it the data type definition)
//=========================================================

// Define a strategy for ValueStatus using prop_oneof!
// Notes (extracted from the Grok explanation)
//  - The Just constructor constructs a strategy that just returns a single value 
//      and includes no proptest simplification/complication infrastructure (we don't need simplification here 
//      because there is only a single value).
//  - prop_oneof! is a proptest macro that creates a strategy choosing randomly among the provided options.
//  - Just(ValueStatus::Valid) and Just(ValueStatus::Invalid) are strategies that always produce the specified variant.
//  - The strategy has a 50% chance of generating Valid and a 50% chance of generating Invalid.
//  - This is concise and idiomatic for enums with a small number of variants.
//  
//  When combining strategies using prop_oneof!, there is an alternate version that enables one
//  to assign weights (probabilities) to the different options.
//
//  prop_oneof![weight1 => strategy1, weight2 => strategy2, ..., weightN => strategyN]
//
//  For a more complex case, suppose you want a strategy for i32 that generates either small positive numbers, 
//  large negative numbers, or zero:
// 
// fn mixed_int_strategy() -> impl Strategy<Value = i32> {
//    prop_oneof![
//        2 => 1..10,          // Small positives, 50% chance (2/4)
//        1 => -100..=-50,     // Large negatives, 25% chance (1/4)
//        1 => Just(0),        // Zero, 25% chance (1/4)
//    ]
//
// The strategy picks between 1..10 (small positives), -100..=-50 (large negatives), or Just(0) (zero).
// Weights ensure 1..10 is twice as likely as the others.
//

pub fn value_status_strategy() -> impl Strategy<Value = ValueStatus> {
    prop_oneof![
        Just(ValueStatus::Valid),
        Just(ValueStatus::Invalid),
    ]
}

// Define a strategy for ValueStatus using prop_map
// In this version 
//   - any::<bool>() generates random bool values (true or false).
//   - .prop_map(|b| if b { ValueStatus::Valid } else { ValueStatus::Invalid }) 
//      maps true to ValueStatus::Valid and false to ValueStatus::Invalid.
//   - This approach avoids macros, making the logic more explicit for teammates unfamiliar with prop_oneof!.
//   - Alternatively, you could use 0..=1 (for i32) and map 0 to Valid and 1 to Invalid, 
//     but bool is simpler and aligns with the binary nature of the enum.

pub fn value_status_strategy_prop_map() -> impl Strategy<Value = ValueStatus> {
    any::<bool>().prop_map(|b| if b { ValueStatus::Valid } else { ValueStatus::Invalid })
}

// example test for the strategy defined above
proptest! {
  #[test]
  fn test_value_status(status in value_status_strategy()) {
     prop_assert!(status == ValueStatus::Valid || status == ValueStatus::Invalid);
  }
}

//=========================================================
//  TempWstatus_i  Strategies
//
//  (Generated by Grok by feeding it the data type definition)
//=========================================================

// Define a strategy for TempWstatus_i using prop_compose!
//  (making use of the previously defined value_status_strategy)
prop_compose! {
    pub fn temp_wstatus_i_strategy(min: i32, max: i32)
        (degrees in min..=max, status in value_status_strategy())
        -> TempWstatus_i {
        TempWstatus_i { degrees, status }
    }
}

// Define a strategy for TempWstatus_i using prop_map
pub fn temp_wstatus_i_strategy_prop_map(min: i32, max: i32) -> impl Strategy<Value = TempWstatus_i> {
    (min..=max, value_status_strategy()).prop_map(|(degrees, status)| TempWstatus_i { degrees, status })
}

// example test for the strategy defined above
proptest! {
    #[test]
    fn test_temp_wstatus_i(temp in temp_wstatus_i_strategy(-100, 100)) {
        prop_assert!(temp.degrees >= -100 && temp.degrees <= 100);
        prop_assert!(temp.status == ValueStatus::Valid || temp.status == ValueStatus::Invalid);
    }
}

//=========================================================
//  RegulatorMode  Strategies
//
//  (Generated by Grok by feeding it the data type definition)
//=========================================================

// Define a strategy for Regulator_Mode using prop_oneof!
pub fn regulator_mode_strategy() -> impl Strategy<Value = Regulator_Mode> {
    prop_oneof![
        Just(Regulator_Mode::Init_Regulator_Mode),
        Just(Regulator_Mode::Normal_Regulator_Mode),
        Just(Regulator_Mode::Failed_Regulator_Mode),
    ]
}

// Define a strategy for Regulator_Mode using prop_map
pub fn regulator_mode_strategy_prop_map() -> impl Strategy<Value = Regulator_Mode> {
    (0..=2).prop_map(|n| match n {
        0 => Regulator_Mode::Init_Regulator_Mode,
        1 => Regulator_Mode::Normal_Regulator_Mode,
        2 => Regulator_Mode::Failed_Regulator_Mode,
        _ => unreachable!(), // 0..=2 ensures n is 0, 1, or 2
    })
}

// Suggested (without prompt) by Grok (it must have picked up on the name "Normal")
pub fn regulator_mode_strategy_prefer_normal() -> impl Strategy<Value = Regulator_Mode> {
    prop_oneof![
        1 => Just(Regulator_Mode::Init_Regulator_Mode),   // 20% (1/5)
        3 => Just(Regulator_Mode::Normal_Regulator_Mode), // 60% (3/5)
        1 => Just(Regulator_Mode::Failed_Regulator_Mode), // 20% (1/5)
    ]
}

proptest! {
    #[test]
    fn test_regulator_mode(mode in regulator_mode_strategy()) {
        prop_assert!(
            mode == Regulator_Mode::Init_Regulator_Mode ||
            mode == Regulator_Mode::Normal_Regulator_Mode ||
            mode == Regulator_Mode::Failed_Regulator_Mode
        );
    }
}

//=========================================================
//  OnOff  Strategies
//
//  (Generated by Grok by feeding it the data type definition)
//=========================================================

// Define a strategy for On_Off using prop_oneof!
pub fn on_off_strategy() -> impl Strategy<Value = On_Off> {
    prop_oneof![
        Just(On_Off::Onn),
        Just(On_Off::Off),
    ]
}

// Define a strategy for On_Off using prop_map
pub fn on_off_strategy_prop_map() -> impl Strategy<Value = On_Off> {
    any::<bool>().prop_map(|b| if b { On_Off::Onn } else { On_Off::Off })
}

proptest! {
    #[test]
    fn test_on_off(state in on_off_strategy()) {
        prop_assert!(state == On_Off::Onn || state == On_Off::Off);
    }
}

//=========================================================
// C o m p o n e n t    I n p u t     C o n t a i n e r
//=========================================================

// Experiment with ways to combine strategies for each component input port/state type.
// These were constructed with Grok props.

// Build a strategy that generates a container (tuple) that has the following type...
//  On_Off  
//  TempWStatus_i
//  Temp_i
//  Regulator_Mode
//  Temp_i
// 
// The composite strategy bubbles up the range configuration to the top level.
// While this is convenient, I don't see a way to automate this in general
// because the presence of range configurations at the lower level is too irregular.
// The final proposal for calling the actual compute entry point for testing
// at the end of the file is more in line with what we likely want to do.

// Define the composite tuple strategy using prop_compose!
prop_compose! {
    pub fn mhs_inputs_config_temp_ranges_strategy(temp_wstatus_range: (i32, i32), temp_i_range: (i32, i32))
        (
            on_off in on_off_strategy(),
            temp_wstatus in temp_wstatus_i_strategy(temp_wstatus_range.0, temp_wstatus_range.1),
            temp_i_1 in temp_i_strategy_range(temp_i_range.0, temp_i_range.1),
            regulator_mode in regulator_mode_strategy(),
            temp_i_2 in temp_i_strategy_range(temp_i_range.0, temp_i_range.1)
        )
        -> (On_Off, TempWstatus_i, Temp_i, Regulator_Mode, Temp_i) {
        (on_off, temp_wstatus, temp_i_1, regulator_mode, temp_i_2)
    }
}

// Define the composite tuple strategy using prop_map
pub fn mhs_inputs_config_temp_range_strategy_prop_map(
    temp_wstatus_range: (i32, i32),
    temp_i_range: (i32, i32),
) -> impl Strategy<Value = (On_Off, TempWstatus_i, Temp_i, Regulator_Mode, Temp_i)> {
    (
        on_off_strategy(),
        temp_wstatus_i_strategy(temp_wstatus_range.0, temp_wstatus_range.1),
        temp_i_strategy_range(temp_i_range.0, temp_i_range.1),
        regulator_mode_strategy(),
        temp_i_strategy_range(temp_i_range.0, temp_i_range.1),
    )
    .prop_map(|(on_off, temp_wstatus, temp_i_1, regulator_mode, temp_i_2)| {
        (on_off, temp_wstatus, temp_i_1, regulator_mode, temp_i_2)
    })
}

// Illustrate the above tuple strategy with an example test.
proptest! {
    #[test]
    fn test_tuple_strategy(
        (on_off, temp_wstatus, temp_i_1, regulator_mode, temp_i_2)
        in mhs_inputs_config_temp_ranges_strategy((-50, 50), (-100, 100))
    ) {
        // Verify On_Off
        prop_assert!(on_off == On_Off::Onn || on_off == On_Off::Off);

        // Verify TempWstatus_i
        prop_assert!(temp_wstatus.degrees >= -50 && temp_wstatus.degrees <= 50);
        prop_assert!(
            temp_wstatus.status == ValueStatus::Valid ||
            temp_wstatus.status == ValueStatus::Invalid
        );

        // Verify first Temp_i
        prop_assert!(temp_i_1.degrees >= -100 && temp_i_1.degrees <= 100);

        // Verify Regulator_Mode
        prop_assert!(
            regulator_mode == Regulator_Mode::Init_Regulator_Mode ||
            regulator_mode == Regulator_Mode::Normal_Regulator_Mode ||
            regulator_mode == Regulator_Mode::Failed_Regulator_Mode
        );

        // Verify second Temp_i
        prop_assert!(temp_i_2.degrees >= -100 && temp_i_2.degrees <= 100);
    }
}


  // This function would be auto-generated by the GUMBOX framework.
  // It invokes the component compute entry point application code and applies
  // the executable contracts.
  //
  // This code is based on Jason's existing test harness for manual unit tests,
  // but is modified in a few places to use propTest framework concepts 
  // (for indicating that the pre condition should be considered a propTest "global filter"
  // and giving return values as needed by the propTest framework).
  //
  // Note: this method was generated by giving Grok Jason's original code with a 
  // few places marked "Grok?" in the comments that I thought Grok should consider
  // for refactoring.  For the prompt, I asked Grok to make the method suitable for 
  // propTest and to consider refactoring the places marked "Grok?" where I left
  // questions about the possible refactoring.
  //
 fn test_compute_CBwL(
    old_last_cmd: On_Off,
    current_temp_wstatus: TempWstatus_i,
    lower_desired_temp: Temp_i,
    regulator_mode: Regulator_Mode,
    upper_desired_temp: Temp_i,
    fail_on_unsat_precondition: bool, // Added to control behavior
) -> Result<(), TestCaseError> {
    // [CheckPre]: Use prop_assume! for precondition filtering (Grok? Answer)
    // Instead of an if-check, use prop_assume! to filter out invalid test cases.
    // This acts as a "global filter" in proptest, discarding cases where the
    // precondition fails without counting them as test failures.
    prop_assume!(
        GUMBOX::compute_CEP_Pre(
            old_last_cmd,
            current_temp_wstatus,
            lower_desired_temp,
            regulator_mode,
            upper_desired_temp
        ),
        "Precondition failed: invalid input combination"
    );

    // [Handle failOnUnsatPrecondition]: No longer needed (Grok? Answer)
    // Since prop_assume! filters out invalid cases, we don't need the
    // failOnUnsatPrecondition branch. However, to support the option of failing
    // explicitly (e.g., for debugging), we keep the parameter and return
    // TestCaseError::Reject if fail_on_unsat_precondition is true and the
    // precondition fails. In this implementation, prop_assume! handles the
    // filtering, so this branch is redundant unless you want to enforce failure
    // in specific cases. I've removed the if-else and assert!(false), as
    // prop_assume! is the proptest way to handle this.

    // [PutInPorts]: Set values on the input ports (unchanged)
    *extern_api::IN_current_tempWstatus.lock().unwrap() = Some(current_temp_wstatus);
    *extern_api::IN_lower_desired_temp.lock().unwrap() = Some(lower_desired_temp);
    *extern_api::IN_upper_desired_temp.lock().unwrap() = Some(upper_desired_temp);
    *extern_api::IN_regulator_mode.lock().unwrap() = Some(regulator_mode);

    unsafe {
        // Initialize the app (unchanged)
        crate::thermostat_rt_mhs_mhs_initialize();

        // [SetInStateVars]: Set the pre-state values (unchanged)
        set_lastCmd(old_last_cmd);

        // [InvokeEntryPoint]: Invoke the entry point (unchanged)
        crate::thermostat_rt_mhs_mhs_timeTriggered();

        // [RetrieveOutState]: Retrieve output values (unchanged)
        let api_heat_control = extern_api::OUT_heat_control
            .lock()
            .unwrap()
            .expect("Not expecting None");
        let last_cmd = get_lastCmd();

        // [CheckPost]: Use prop_assert! for postcondition (Grok? Answer)
        // Replace assert! with prop_assert! to integrate with proptest's error
        // reporting and shrinking. prop_assert! returns a Result<(), TestCaseError>,
        // which fits the function's return type. If the postcondition fails,
        // proptest will report the failure and attempt to shrink the inputs.
        prop_assert!(
            GUMBOX::compute_CEP_Post(
                old_last_cmd,
                last_cmd,
                current_temp_wstatus,
                lower_desired_temp,
                regulator_mode,
                upper_desired_temp,
                api_heat_control
            ),
            "Postcondition failed: incorrect output behavior"
        );
    }

    // Return Ok(()) if all assertions pass
    Ok(())
}

proptest! {
    #[test]
    fn prop_test_compute_CBwL_ranges(
        (old_last_cmd, current_temp_wstatus, lower_desired_temp, regulator_mode, upper_desired_temp)
        in mhs_inputs_config_temp_ranges_strategy((95, 103), (94,105))
    ) {
        // Call test_compute_CBwL with fail_on_unsat_precondition set to false
        // (since prop_assume! handles filtering)
        test_compute_CBwL(
            old_last_cmd,
            current_temp_wstatus,
            lower_desired_temp,
            regulator_mode,
            upper_desired_temp,
            false
        )?;
    }
}

// Alternate illustration of a propTest invocation of the compute entry point with contracts,
// where strategies are given for each input port and local state value.
// This is probably the style that is easiest for HAMR to generate while still being
// easy to express/customize by the user.
//
// Some parts of the method below would be manipulated by the developer, while other
// parts would not need to be changed (see code comments).  
// A Rust macro below focuses the developer attention on the configurable parts.
//
proptest! {
    // Proptest configuration (customizable by developer)
    #![proptest_config(ProptestConfig {
        cases: 1000,
        verbose: 2, // High verbosity for filtering details
        ..ProptestConfig::default()
    })]
    #[test]
    fn prop_test_compute_CBwL_strategies(
        (old_last_cmd, current_temp_wstatus, lower_desired_temp, regulator_mode, upper_desired_temp)
        // proptest generation strategies -- customizable by the developer.
        in (on_off_strategy(), // strategy for last cmd component local state
            temp_wstatus_i_strategy(95, 103), // strategy for current_temp_wstatus in port
            temp_i_strategy_range(94, 105), // strategy for lower_desired_temp in port
            regulator_mode_strategy(), // strategy for regulator mode in port
            temp_i_strategy_range(94,105)) // strategy for upper_desired_temp in port
    ) {
        // Invocation of component application code with contracts.
        // The developer should not modify this code.
        //
        // Call test_compute_CBwL with fail_on_unsat_precondition set to false
        // (since prop_assume! handles filtering)
        test_compute_CBwL(
            old_last_cmd,
            current_temp_wstatus,
            lower_desired_temp,
            regulator_mode,
            upper_desired_temp,
            false  // this is likely unnecessary and can be removed.
        )?;
    }
}

// Define a macro to make the repeated invocation of proptest more convenient (written by Grok)
// HAMR would generate one of these for each entry point for each component.

#[macro_export]
macro_rules! prop_test_cbwl {
    (
        $test_name:ident, // Name of the test function
        config: $config:expr, // ProptestConfig expression
        on_off: $on_off_strat:expr, // Strategy for old_last_cmd (On_Off)
        temp_wstatus: $temp_wstatus_strat:expr, // Strategy for current_temp_wstatus (TempWstatus_i)
        lower_temp: $lower_temp_strat:expr, // Strategy for lower_desired_temp (Temp_i)
        regulator: $regulator_strat:expr, // Strategy for regulator_mode (Regulator_Mode)
        upper_temp: $upper_temp_strat:expr // Strategy for upper_desired_temp (Temp_i)
    ) => {
        proptest! {
            #![proptest_config($config)]
            #[test]
            fn $test_name(
                (old_last_cmd, current_temp_wstatus, lower_desired_temp, regulator_mode, upper_desired_temp)
                in ($on_off_strat, $temp_wstatus_strat, $lower_temp_strat, $regulator_strat, $upper_temp_strat)
            ) {
                test_compute_CBwL(
                    old_last_cmd,
                    current_temp_wstatus,
                    lower_desired_temp,
                    regulator_mode,
                    upper_desired_temp,
                    false
                )?;
            }
        }
    };
}

// Apply dedicated prop_test macro for the MHS component.
// The macro allows the generation strategies to be specified for each of the input ports,
// and allows a local configuration spec for propTest
//
// This corresponds to what HAMR would auto-generate for the MHS component:
//  a custom macro with example application as below, that the user could copy and configure
//  for more tests.  It's not clear that the ranges uses below could be auto-generated.
//  This might be derived from model level GUMBO integration constraints, with some additional
//  annotations that more explicitly indicate lower and upper bounds of numerics.
//
prop_test_cbwl! {
    prop_test_compute_CBwL_w_macro, // test name
    config: ProptestConfig { // proptest configuration, built by overriding fields from default config
        cases: 500,
        verbose: 2,
        ..ProptestConfig::default()
    },
    // strategies for generating each component input
    on_off: on_off_strategy(),
    temp_wstatus: temp_wstatus_i_strategy(95, 103),
    lower_temp: temp_i_strategy_range(94, 105),
    regulator: regulator_mode_strategy(),
    upper_temp: temp_i_strategy_range(94, 105)
}


  fn set_lastCmd(value: On_Off) {
    unsafe {
        match &mut crate::app {
            Some(inner) => inner.lastCmd = value,
            None => panic!("The app is None")
        }
    }
  }

  // state variable
  fn get_lastCmd() -> On_Off {
    unsafe {
        match &crate::app {
            Some(inner) => inner.lastCmd,
            None => panic!("The app is None")
        }
    }
  }

  // output port
  fn get_heat_control() -> On_Off {
    extern_api::OUT_heat_control.lock().unwrap().expect("Not expecting None")
  }

}


