// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn three_bytes_to_u32(
  byte0: u8,
  byte1: u8,
  byte2: u8) -> u32
{
  ((byte2) as u32) * 65536u32 + ((byte1) as u32) * 256u32 + ((byte0) as u32)
}

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16
{
  ((byte1) as u16) * 256u16 + ((byte0) as u16)
}

pub fn msg_v1_is_command_int(msg: SW::UdpPayload) -> bool
{
  msg[5] == 75u8
}

pub fn command_int_msg_v1_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[33],msg[34]) == 42650u16
}

pub fn msg_v1_is_command_long(msg: SW::UdpPayload) -> bool
{
  msg[5] == 76u8
}

pub fn command_long_msg_v1_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[34],msg[35]) == 42650u16
}

pub fn msg_is_mavlinkv1(msg: SW::UdpPayload) -> bool
{
  msg[0] == 0xFEu8
}

pub fn msg_v2_is_command_int(msg: SW::UdpPayload) -> bool
{
  three_bytes_to_u32(msg[7],msg[8],msg[9]) == 75u32
}

pub fn command_int_msg_v2_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[37],msg[38]) == 42650u16
}

pub fn msg_v2_is_command_long(msg: SW::UdpPayload) -> bool
{
  three_bytes_to_u32(msg[7],msg[8],msg[9]) == 76u32
}

pub fn command_long_msg_v2_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[38],msg[39]) == 42650u16
}

pub fn msg_is_mavlinkv2(msg: SW::UdpPayload) -> bool
{
  msg[0] == 0xFDu8
}

pub fn msg_is_mav_v2_cmd_flash_bootloader(msg: SW::UdpPayload) -> bool
{
  msg_is_mavlinkv2(msg) &&
    (msg_v2_is_command_int(msg) && command_int_msg_v2_is_bootloader_flash(msg) ||
      msg_v2_is_command_long(msg) && command_long_msg_v2_is_bootloader_flash(msg))
}

pub fn msg_is_mav_v1_cmd_flash_bootloader(msg: SW::UdpPayload) -> bool
{
  msg_is_mavlinkv1(msg) &&
    (msg_v1_is_command_int(msg) && command_int_msg_v1_is_bootloader_flash(msg) ||
      msg_v1_is_command_long(msg) && command_long_msg_v1_is_bootloader_flash(msg))
}

pub fn msg_is_mav_cmd_flash_bootloader(msg: SW::UdpPayload) -> bool
{
  msg_is_mav_v2_cmd_flash_bootloader(msg) || msg_is_mav_v1_cmd_flash_bootloader(msg)
}

pub fn mav_input_headers_eq_output(
  headers: SW::EthIpUdpHeaders,
  frame: SW::RawEthernetMessage) -> bool
{
  (0..headers.len()).all(|i| headers[i] == frame[i])
}

pub fn mav_input_payload_eq_output(
  payload: SW::UdpPayload,
  headers: SW::EthIpUdpHeaders,
  frame: SW::RawEthernetMessage) -> bool
{
  (0..payload.len()).all(|i| frame[i + headers.len()] == payload[i])
}

pub fn mav_input_eq_output(
  input: SW::UdpFrame_Impl,
  frame: SW::RawEthernetMessage) -> bool
{
  mav_input_headers_eq_output(input.headers,frame) && mav_input_payload_eq_output(input.payload,input.headers,frame)
}

pub fn msg_is_blacklisted(msg: SW::UdpPayload) -> bool
{
  msg_is_mav_cmd_flash_bootloader(msg)
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_19_mav0_drop_mav_cmd_flash_bootloader
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_spec_hlr_19_mav0_drop_mav_cmd_flash_bootloader_guarantee(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In0.is_some() && msg_is_mav_cmd_flash_bootloader(api_In0.unwrap().payload),
    api_Out0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_21_mav0_no_input
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_spec_hlr_21_mav0_no_input_guarantee(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_In0.is_some()),
    api_Out0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_22_mav0_allow
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_spec_hlr_22_mav0_allow_guarantee(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In0.is_some() && !(msg_is_blacklisted(api_In0.unwrap().payload)),
    api_Out0.is_some() && mav_input_eq_output(api_In0.unwrap(),api_Out0.unwrap()))
}

/** CEP-T-Guar: Top-level guarantee contracts for MavlinkFirewall's compute entrypoint
  *
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  let r0: bool = compute_spec_hlr_19_mav0_drop_mav_cmd_flash_bootloader_guarantee(api_In0, api_Out0);
  let r1: bool = compute_spec_hlr_21_mav0_no_input_guarantee(api_In0, api_Out0);
  let r2: bool = compute_spec_hlr_22_mav0_allow_guarantee(api_In0, api_Out0);

  return r0 && r1 && r2;
}

/** CEP-Post: Compute Entrypoint Post-Condition for MavlinkFirewall
  *
  * @param api_In0 incoming event data port
  * @param api_In1 incoming event data port
  * @param api_In2 incoming event data port
  * @param api_In3 incoming event data port
  * @param api_Out0 outgoing event data port
  * @param api_Out1 outgoing event data port
  * @param api_Out2 outgoing event data port
  * @param api_Out3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_In1: Option<SW::UdpFrame_Impl>,
  api_In2: Option<SW::UdpFrame_Impl>,
  api_In3: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>,
  api_Out1: Option<SW::RawEthernetMessage>,
  api_Out2: Option<SW::RawEthernetMessage>,
  api_Out3: Option<SW::RawEthernetMessage>) -> bool
{
  // CEP-Guar: guarantee clauses of MavlinkFirewall's compute entrypoint
  let r0: bool = compute_CEP_T_Guar(api_In0, api_Out0);

  return r0;
}
