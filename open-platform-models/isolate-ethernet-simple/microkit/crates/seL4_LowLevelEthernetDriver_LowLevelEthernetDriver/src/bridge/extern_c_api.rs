// Do not edit this file as it will be overwritten if codegen is rerun

//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to be verified by other means.

use data::*;

#[cfg(test)]
use std::sync::Mutex;

#[cfg(not(test))]
extern "C" {
  fn get_TxData(value: *mut SW::EthernetMessages) -> bool;
  fn get_RxQueueFree(value: *mut SW::BufferQueue_Impl) -> bool;
  fn get_TxQueueAvail(value: *mut SW::BufferQueue_Impl) -> bool;
  fn put_RxData(value: *mut SW::EthernetMessages) -> bool;
  fn put_RxQueueAvail(value: *mut SW::BufferQueue_Impl) -> bool;
  fn put_TxQueueFree(value: *mut SW::BufferQueue_Impl) -> bool;
}

pub fn unsafe_get_TxData() -> SW::EthernetMessages 
 {
   unsafe {
     let value: *mut SW::EthernetMessages = &mut [[0; SW::SW_RawEthernetMessage_DIM_0]; SW::SW_EthernetMessages_DIM_0];
     get_TxData(value);
     return *value;
   }
 }

pub fn unsafe_get_RxQueueFree() -> Option<SW::BufferQueue_Impl> 
 {
   unsafe {
     let value: *mut SW::BufferQueue_Impl = &mut SW::BufferQueue_Impl::default();
     if (get_RxQueueFree(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_TxQueueAvail() -> Option<SW::BufferQueue_Impl> 
 {
   unsafe {
     let value: *mut SW::BufferQueue_Impl = &mut SW::BufferQueue_Impl::default();
     if (get_TxQueueAvail(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_put_RxData(value: &SW::EthernetMessages) -> bool 
 {
   unsafe {
     return put_RxData(value as *const SW::EthernetMessages as *mut SW::EthernetMessages);
   }
 }

pub fn unsafe_put_RxQueueAvail(value: &SW::BufferQueue_Impl) -> bool 
 {
   unsafe {
     return put_RxQueueAvail(value as *const SW::BufferQueue_Impl as *mut SW::BufferQueue_Impl);
   }
 }

pub fn unsafe_put_TxQueueFree(value: &SW::BufferQueue_Impl) -> bool 
 {
   unsafe {
     return put_TxQueueFree(value as *const SW::BufferQueue_Impl as *mut SW::BufferQueue_Impl);
   }
 }

//////////////////////////////////////////////////////////////////////////////////
// Testing Versions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w,
  // but we couldn't do that for in ports since they are read-only
  pub static ref IN_TxData: Mutex<Option<SW::EthernetMessages>> = Mutex::new(None);
  pub static ref IN_RxQueueFree: Mutex<Option<SW::BufferQueue_Impl>> = Mutex::new(None);
  pub static ref IN_TxQueueAvail: Mutex<Option<SW::BufferQueue_Impl>> = Mutex::new(None);
  pub static ref OUT_RxData: Mutex<Option<SW::EthernetMessages>> = Mutex::new(None);
  pub static ref OUT_RxQueueAvail: Mutex<Option<SW::BufferQueue_Impl>> = Mutex::new(None);
  pub static ref OUT_TxQueueFree: Mutex<Option<SW::BufferQueue_Impl>> = Mutex::new(None);
}

#[cfg(test)]
pub fn get_TxData(value: *mut SW::EthernetMessages) -> bool 
 {
   unsafe {
     *value = IN_TxData.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_RxQueueFree(value: *mut SW::BufferQueue_Impl) -> bool 
 {
   unsafe {
     match *IN_RxQueueFree.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_TxQueueAvail(value: *mut SW::BufferQueue_Impl) -> bool 
 {
   unsafe {
     match *IN_TxQueueAvail.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn put_RxData(value: *mut SW::EthernetMessages) -> bool 
 {
   unsafe {
     *OUT_RxData.lock().unwrap() = Some(*value);
     return true;
   }
 }

#[cfg(test)]
pub fn put_RxQueueAvail(value: *mut SW::BufferQueue_Impl) -> bool 
 {
   unsafe {
     *OUT_RxQueueAvail.lock().unwrap() = Some(*value);
     return true;
   }
 }

#[cfg(test)]
pub fn put_TxQueueFree(value: *mut SW::BufferQueue_Impl) -> bool 
 {
   unsafe {
     *OUT_TxQueueFree.lock().unwrap() = Some(*value);
     return true;
   }
 }
