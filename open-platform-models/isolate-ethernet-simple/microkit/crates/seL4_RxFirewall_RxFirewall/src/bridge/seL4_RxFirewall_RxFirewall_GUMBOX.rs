// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn TCP_ALLOWED_PORTS() -> SW::u16Array
{
  [5760u16]
}

pub fn UDP_ALLOWED_PORTS() -> SW::u16Array
{
  [68u16]
}

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16
{
  ((byte0) as u16) * 256u16 + ((byte1) as u16)
}

pub fn frame_is_wellformed_eth2(frame: SW::RawEthernetMessage) -> bool
{
  valid_frame_ethertype(frame) && valid_frame_dst_addr(frame)
}

pub fn valid_frame_ethertype(frame: SW::RawEthernetMessage) -> bool
{
  frame_has_ipv4(frame) || frame_has_arp(frame) ||
    frame_has_ipv6(frame)
}

pub fn valid_frame_dst_addr(frame: SW::RawEthernetMessage) -> bool
{
  !((frame[0] == 0u8) &&
    (frame[1] == 0u8) &&
    (frame[2] == 0u8) &&
    (frame[3] == 0u8) &&
    (frame[4] == 0u8) &&
    (frame[5] == 0u8))
}

pub fn frame_has_ipv4(frame: SW::RawEthernetMessage) -> bool
{
  (frame[12] == 8u8) &&
    (frame[13] == 0u8)
}

pub fn frame_has_ipv6(frame: SW::RawEthernetMessage) -> bool
{
  (frame[12] == 134u8) &&
    (frame[13] == 221u8)
}

pub fn frame_has_arp(frame: SW::RawEthernetMessage) -> bool
{
  (frame[12] == 8u8) &&
    (frame[13] == 6u8)
}

pub fn arp_has_ipv4(frame: SW::RawEthernetMessage) -> bool
{
  (frame[16] == 8u8) &&
    (frame[17] == 0u8)
}

pub fn arp_has_ipv6(frame: SW::RawEthernetMessage) -> bool
{
  (frame[16] == 134u8) &&
    (frame[17] == 221u8)
}

pub fn valid_arp_ptype(frame: SW::RawEthernetMessage) -> bool
{
  arp_has_ipv4(frame) || arp_has_ipv6(frame)
}

pub fn valid_arp_op(frame: SW::RawEthernetMessage) -> bool
{
  (frame[20] == 0u8) &&
    ((frame[21] == 1u8) ||
      (frame[21] == 2u8))
}

pub fn valid_arp_htype(frame: SW::RawEthernetMessage) -> bool
{
  (frame[14] == 0u8) &&
    (frame[15] == 1u8)
}

pub fn wellformed_arp_frame(frame: SW::RawEthernetMessage) -> bool
{
  valid_arp_op(frame) && valid_arp_htype(frame) &&
    valid_arp_ptype(frame)
}

pub fn valid_ipv4_length(frame: SW::RawEthernetMessage) -> bool
{
  two_bytes_to_u16(frame[16],frame[17]) <= 9000u16
}

pub fn valid_ipv4_protocol(frame: SW::RawEthernetMessage) -> bool
{
  (frame[23] == 0u8) ||
    (frame[23] == 1u8) ||
    (frame[23] == 2u8) ||
    (frame[23] == 6u8) ||
    (frame[23] == 17u8) ||
    (frame[23] == 43u8) ||
    (frame[23] == 44u8) ||
    (frame[23] == 58u8) ||
    (frame[23] == 59u8) ||
    (frame[23] == 60u8)
}

pub fn wellformed_ipv4_frame(frame: SW::RawEthernetMessage) -> bool
{
  valid_ipv4_protocol(frame) && valid_ipv4_length(frame)
}

pub fn ipv4_is_tcp(frame: SW::RawEthernetMessage) -> bool
{
  frame[23] == 6u8
}

pub fn ipv4_is_udp(frame: SW::RawEthernetMessage) -> bool
{
  frame[23] == 17u8
}

pub fn tcp_is_valid_port(frame: SW::RawEthernetMessage) -> bool
{
  two_bytes_to_u16(frame[36],frame[37]) == TCP_ALLOWED_PORTS()[0]
}

pub fn udp_is_valid_port(frame: SW::RawEthernetMessage) -> bool
{
  two_bytes_to_u16(frame[36],frame[37]) == UDP_ALLOWED_PORTS()[0]
}

pub fn udp_is_mavlink_port(frame: SW::RawEthernetMessage) -> bool
{
  two_bytes_to_u16(frame[34],frame[35]) == 14550
}

pub fn frame_has_ipv4_tcp_on_allowed_port_quant(frame: SW::RawEthernetMessage) -> bool
{
  (0..TCP_ALLOWED_PORTS().len()).any(|i| TCP_ALLOWED_PORTS()[i] == two_bytes_to_u16(frame[36],frame[37]))
}

pub fn frame_has_ipv4_udp_on_allowed_port_quant(frame: SW::RawEthernetMessage) -> bool
{
  (0..UDP_ALLOWED_PORTS().len()).any(|i| UDP_ALLOWED_PORTS()[i] == two_bytes_to_u16(frame[36],frame[37]))
}

pub fn valid_arp(frame: SW::RawEthernetMessage) -> bool
{
  frame_is_wellformed_eth2(frame) && frame_has_arp(frame) &&
    wellformed_arp_frame(frame)
}

pub fn valid_ipv4_tcp(frame: SW::RawEthernetMessage) -> bool
{
  frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
    wellformed_ipv4_frame(frame) &&
    ipv4_is_tcp(frame)
}

pub fn valid_ipv4_udp(frame: SW::RawEthernetMessage) -> bool
{
  frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
    wellformed_ipv4_frame(frame) &&
    ipv4_is_udp(frame)
}

pub fn valid_ipv4_tcp_port(frame: SW::RawEthernetMessage) -> bool
{
  valid_ipv4_tcp(frame) && frame_has_ipv4_tcp_on_allowed_port_quant(frame)
}

pub fn valid_ipv4_udp_port(frame: SW::RawEthernetMessage) -> bool
{
  valid_ipv4_udp(frame) && frame_has_ipv4_udp_on_allowed_port_quant(frame) &&
    !(udp_is_mavlink_port(frame))
}

pub fn valid_ipv4_udp_mavlink(frame: SW::RawEthernetMessage) -> bool
{
  valid_ipv4_udp(frame) && udp_is_mavlink_port(frame)
}

pub fn allow_outbound_frame(frame: SW::RawEthernetMessage) -> bool
{
  valid_arp(frame) || valid_ipv4_udp_mavlink(frame) ||
    valid_ipv4_udp_port(frame)
}

pub fn input_eq_mav_output(
  frame: SW::RawEthernetMessage,
  output: SW::UdpFrame_Impl) -> bool
{
  // frame == output
  true
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_05_rx0_can_send_arp_to_vmm
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  */
pub fn compute_spec_hlr_05_rx0_can_send_arp_to_vmm_guarantee(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn0.is_some() && valid_arp(api_EthernetFramesRxIn0.unwrap()),
    api_VmmOut0.is_some() &&
      (api_EthernetFramesRxIn0.unwrap() == api_VmmOut0.unwrap()) &&
      api_MavlinkOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_18_rx0_can_send_mavlink_udp
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  */
pub fn compute_spec_hlr_18_rx0_can_send_mavlink_udp_guarantee(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn0.is_some() && valid_ipv4_udp_mavlink(api_EthernetFramesRxIn0.unwrap()),
    api_MavlinkOut0.is_some() && input_eq_mav_output(api_EthernetFramesRxIn0.unwrap(),api_MavlinkOut0.unwrap()) &&
      api_VmmOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_13_rx0_can_send_ipv4_udp
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  */
pub fn compute_spec_hlr_13_rx0_can_send_ipv4_udp_guarantee(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn0.is_some() && valid_ipv4_udp_port(api_EthernetFramesRxIn0.unwrap()),
    api_VmmOut0.is_some() &&
      (api_EthernetFramesRxIn0.unwrap() == api_VmmOut0.unwrap()) &&
      api_MavlinkOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_15_rx0_disallow
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  */
pub fn compute_spec_hlr_15_rx0_disallow_guarantee(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn0.is_some() && !(allow_outbound_frame(api_EthernetFramesRxIn0.unwrap())),
    api_VmmOut0.is_none() && api_MavlinkOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_17_rx0_no_input
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  */
pub fn compute_spec_hlr_17_rx0_no_input_guarantee(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_EthernetFramesRxIn0.is_some()),
    api_VmmOut0.is_none() && api_MavlinkOut0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_05_rx1_can_send_arp_to_vmm
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  */
pub fn compute_spec_hlr_05_rx1_can_send_arp_to_vmm_guarantee(
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_VmmOut1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn1.is_some() && valid_arp(api_EthernetFramesRxIn1.unwrap()),
    api_VmmOut1.is_some() &&
      (api_EthernetFramesRxIn1.unwrap() == api_VmmOut1.unwrap()) &&
      api_MavlinkOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_18_rx1_can_send_mavlink_udp
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  */
pub fn compute_spec_hlr_18_rx1_can_send_mavlink_udp_guarantee(
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_VmmOut1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn1.is_some() && valid_ipv4_udp_mavlink(api_EthernetFramesRxIn1.unwrap()),
    api_MavlinkOut1.is_some() && input_eq_mav_output(api_EthernetFramesRxIn1.unwrap(),api_MavlinkOut1.unwrap()) &&
      api_VmmOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_13_rx1_can_send_ipv4_udp
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  */
pub fn compute_spec_hlr_13_rx1_can_send_ipv4_udp_guarantee(
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_VmmOut1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn1.is_some() && valid_ipv4_udp_port(api_EthernetFramesRxIn1.unwrap()),
    api_VmmOut1.is_some() &&
      (api_EthernetFramesRxIn1.unwrap() == api_VmmOut1.unwrap()) &&
      api_MavlinkOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_15_rx1_disallow
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  */
pub fn compute_spec_hlr_15_rx1_disallow_guarantee(
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_VmmOut1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn1.is_some() && !(allow_outbound_frame(api_EthernetFramesRxIn1.unwrap())),
    api_VmmOut1.is_none() && api_MavlinkOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_17_rx1_no_input
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  */
pub fn compute_spec_hlr_17_rx1_no_input_guarantee(
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_VmmOut1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_EthernetFramesRxIn1.is_some()),
    api_VmmOut1.is_none() && api_MavlinkOut1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_05_rx2_can_send_arp_to_vmm
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  */
pub fn compute_spec_hlr_05_rx2_can_send_arp_to_vmm_guarantee(
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_VmmOut2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn2.is_some() && valid_arp(api_EthernetFramesRxIn2.unwrap()),
    api_VmmOut2.is_some() &&
      (api_EthernetFramesRxIn2.unwrap() == api_VmmOut2.unwrap()) &&
      api_MavlinkOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_18_rx2_can_send_mavlink_udp
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  */
pub fn compute_spec_hlr_18_rx2_can_send_mavlink_udp_guarantee(
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_VmmOut2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn2.is_some() && valid_ipv4_udp_mavlink(api_EthernetFramesRxIn2.unwrap()),
    api_MavlinkOut2.is_some() && input_eq_mav_output(api_EthernetFramesRxIn2.unwrap(),api_MavlinkOut2.unwrap()) &&
      api_VmmOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_13_rx2_can_send_ipv4_udp
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  */
pub fn compute_spec_hlr_13_rx2_can_send_ipv4_udp_guarantee(
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_VmmOut2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn2.is_some() && valid_ipv4_udp_port(api_EthernetFramesRxIn2.unwrap()),
    api_VmmOut2.is_some() &&
      (api_EthernetFramesRxIn2.unwrap() == api_VmmOut2.unwrap()) &&
      api_MavlinkOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_15_rx2_disallow
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  */
pub fn compute_spec_hlr_15_rx2_disallow_guarantee(
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_VmmOut2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn2.is_some() && !(allow_outbound_frame(api_EthernetFramesRxIn2.unwrap())),
    api_VmmOut2.is_none() && api_MavlinkOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_17_rx2_no_input
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  */
pub fn compute_spec_hlr_17_rx2_no_input_guarantee(
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_VmmOut2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_EthernetFramesRxIn2.is_some()),
    api_VmmOut2.is_none() && api_MavlinkOut2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_05_rx3_can_send_arp_to_vmm
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_spec_hlr_05_rx3_can_send_arp_to_vmm_guarantee(
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn3.is_some() && valid_arp(api_EthernetFramesRxIn3.unwrap()),
    api_VmmOut3.is_some() &&
      (api_EthernetFramesRxIn3.unwrap() == api_VmmOut3.unwrap()) &&
      api_MavlinkOut3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_18_rx3_can_send_mavlink_udp
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_spec_hlr_18_rx3_can_send_mavlink_udp_guarantee(
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn3.is_some() && valid_ipv4_udp_mavlink(api_EthernetFramesRxIn3.unwrap()),
    api_MavlinkOut3.is_some() && input_eq_mav_output(api_EthernetFramesRxIn3.unwrap(),api_MavlinkOut3.unwrap()) &&
      api_VmmOut3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_13_rx3_can_send_ipv4_udp
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_spec_hlr_13_rx3_can_send_ipv4_udp_guarantee(
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn3.is_some() && valid_ipv4_udp_port(api_EthernetFramesRxIn3.unwrap()),
    api_VmmOut3.is_some() &&
      (api_EthernetFramesRxIn3.unwrap() == api_VmmOut3.unwrap()) &&
      api_MavlinkOut3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_15_rx3_disallow
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_spec_hlr_15_rx3_disallow_guarantee(
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_EthernetFramesRxIn3.is_some() && !(allow_outbound_frame(api_EthernetFramesRxIn3.unwrap())),
    api_VmmOut3.is_none() && api_MavlinkOut3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_17_rx3_no_input
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_spec_hlr_17_rx3_no_input_guarantee(
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_EthernetFramesRxIn3.is_some()),
    api_VmmOut3.is_none() && api_MavlinkOut3.is_none())
}

/** CEP-T-Guar: Top-level guarantee contracts for RxFirewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>,
  api_VmmOut1: Option<SW::RawEthernetMessage>,
  api_VmmOut2: Option<SW::RawEthernetMessage>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  let r0: bool = compute_spec_hlr_05_rx0_can_send_arp_to_vmm_guarantee(api_EthernetFramesRxIn0, api_MavlinkOut0, api_VmmOut0);
  let r1: bool = compute_spec_hlr_18_rx0_can_send_mavlink_udp_guarantee(api_EthernetFramesRxIn0, api_MavlinkOut0, api_VmmOut0);
  let r2: bool = compute_spec_hlr_13_rx0_can_send_ipv4_udp_guarantee(api_EthernetFramesRxIn0, api_MavlinkOut0, api_VmmOut0);
  let r3: bool = compute_spec_hlr_15_rx0_disallow_guarantee(api_EthernetFramesRxIn0, api_MavlinkOut0, api_VmmOut0);
  let r4: bool = compute_spec_hlr_17_rx0_no_input_guarantee(api_EthernetFramesRxIn0, api_MavlinkOut0, api_VmmOut0);
  let r5: bool = compute_spec_hlr_05_rx1_can_send_arp_to_vmm_guarantee(api_EthernetFramesRxIn1, api_MavlinkOut1, api_VmmOut1);
  let r6: bool = compute_spec_hlr_18_rx1_can_send_mavlink_udp_guarantee(api_EthernetFramesRxIn1, api_MavlinkOut1, api_VmmOut1);
  let r7: bool = compute_spec_hlr_13_rx1_can_send_ipv4_udp_guarantee(api_EthernetFramesRxIn1, api_MavlinkOut1, api_VmmOut1);
  let r8: bool = compute_spec_hlr_15_rx1_disallow_guarantee(api_EthernetFramesRxIn1, api_MavlinkOut1, api_VmmOut1);
  let r9: bool = compute_spec_hlr_17_rx1_no_input_guarantee(api_EthernetFramesRxIn1, api_MavlinkOut1, api_VmmOut1);
  let r10: bool = compute_spec_hlr_05_rx2_can_send_arp_to_vmm_guarantee(api_EthernetFramesRxIn2, api_MavlinkOut2, api_VmmOut2);
  let r11: bool = compute_spec_hlr_18_rx2_can_send_mavlink_udp_guarantee(api_EthernetFramesRxIn2, api_MavlinkOut2, api_VmmOut2);
  let r12: bool = compute_spec_hlr_13_rx2_can_send_ipv4_udp_guarantee(api_EthernetFramesRxIn2, api_MavlinkOut2, api_VmmOut2);
  let r13: bool = compute_spec_hlr_15_rx2_disallow_guarantee(api_EthernetFramesRxIn2, api_MavlinkOut2, api_VmmOut2);
  let r14: bool = compute_spec_hlr_17_rx2_no_input_guarantee(api_EthernetFramesRxIn2, api_MavlinkOut2, api_VmmOut2);
  let r15: bool = compute_spec_hlr_05_rx3_can_send_arp_to_vmm_guarantee(api_EthernetFramesRxIn3, api_MavlinkOut3, api_VmmOut3);
  let r16: bool = compute_spec_hlr_18_rx3_can_send_mavlink_udp_guarantee(api_EthernetFramesRxIn3, api_MavlinkOut3, api_VmmOut3);
  let r17: bool = compute_spec_hlr_13_rx3_can_send_ipv4_udp_guarantee(api_EthernetFramesRxIn3, api_MavlinkOut3, api_VmmOut3);
  let r18: bool = compute_spec_hlr_15_rx3_disallow_guarantee(api_EthernetFramesRxIn3, api_MavlinkOut3, api_VmmOut3);
  let r19: bool = compute_spec_hlr_17_rx3_no_input_guarantee(api_EthernetFramesRxIn3, api_MavlinkOut3, api_VmmOut3);

  return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8 && r9 && r10 && r11 && r12 && r13 && r14 && r15 && r16 && r17 && r18 && r19;
}

/** CEP-Post: Compute Entrypoint Post-Condition for RxFirewall
  *
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_MavlinkOut0 outgoing event data port
  * @param api_MavlinkOut1 outgoing event data port
  * @param api_MavlinkOut2 outgoing event data port
  * @param api_MavlinkOut3 outgoing event data port
  * @param api_VmmOut0 outgoing event data port
  * @param api_VmmOut1 outgoing event data port
  * @param api_VmmOut2 outgoing event data port
  * @param api_VmmOut3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_MavlinkOut0: Option<SW::UdpFrame_Impl>,
  api_MavlinkOut1: Option<SW::UdpFrame_Impl>,
  api_MavlinkOut2: Option<SW::UdpFrame_Impl>,
  api_MavlinkOut3: Option<SW::UdpFrame_Impl>,
  api_VmmOut0: Option<SW::RawEthernetMessage>,
  api_VmmOut1: Option<SW::RawEthernetMessage>,
  api_VmmOut2: Option<SW::RawEthernetMessage>,
  api_VmmOut3: Option<SW::RawEthernetMessage>) -> bool
{
  // CEP-Guar: guarantee clauses of RxFirewall's compute entrypoint
  let r0: bool = compute_CEP_T_Guar(api_EthernetFramesRxIn0, api_EthernetFramesRxIn1, api_EthernetFramesRxIn2, api_EthernetFramesRxIn3, api_MavlinkOut0, api_MavlinkOut1, api_MavlinkOut2, api_MavlinkOut3, api_VmmOut0, api_VmmOut1, api_VmmOut2, api_VmmOut3);

  return r0;
}
