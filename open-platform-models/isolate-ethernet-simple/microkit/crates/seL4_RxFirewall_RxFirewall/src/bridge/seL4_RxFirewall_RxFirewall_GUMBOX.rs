// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

pub fn TCP_ALLOWED_PORTS() -> SW::u16Array 
 {
   [5760u16, 0u16, 0u16, 0u16]
 }

pub fn UDP_ALLOWED_PORTS() -> SW::u16Array 
 {
   [68u16, 0u16, 0u16, 0u16]
 }

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16 
 {
   ((byte0) as u16) * 256u16 + ((byte1) as u16)
 }

pub fn frame_is_wellformed_eth2(frame: SW::RawEthernetMessage) -> bool 
 {
   if (!((frame[12] >= 6u8) &&
     (frame[13] >= 0u8))) {
     false
   } else {
     true
   }
 }

pub fn frame_has_ipv4(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 8u8) &&
       (frame[13] == 0u8))) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv4_tcp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame),
     (if (frame[23] != 6u8) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv4_udp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame),
     (if (!(frame[23] == 17u8)) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv4_tcp_on_allowed_port(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
       frame_has_ipv4_tcp(frame),
     (TCP_ALLOWED_PORTS()[0] == two_bytes_to_u16(frame[36],frame[37])))
 }

pub fn frame_has_ipv4_tcp_on_allowed_port_quant(frame: SW::RawEthernetMessage) -> bool 
 {
   for i in 0 .. TCP_ALLOWED_PORTS().len() - 1 {
     if TCP_ALLOWED_PORTS()[i] == two_bytes_to_u16(frame[36],frame[37]) {
       return true;
     }
   }
   return false;
 }

pub fn frame_has_ipv4_udp_on_allowed_port(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
       frame_has_ipv4_udp(frame),
     (UDP_ALLOWED_PORTS()[0] == two_bytes_to_u16(frame[36],frame[37])))
 }

pub fn frame_has_ipv4_udp_on_allowed_port_quant(frame: SW::RawEthernetMessage) -> bool 
 {
   for i in 0 .. UDP_ALLOWED_PORTS().len() - 1 {
     if UDP_ALLOWED_PORTS()[i] == two_bytes_to_u16(frame[36],frame[37]) {
       return true;
     }
   }
   return false;
 }

pub fn frame_has_ipv6(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 134u8) &&
       (frame[13] == 221u8))) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_arp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 8u8) &&
       (frame[13] == 6u8))) {
       false
     } else {
       true
     }))
 }

pub fn hlr_1_1(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (!(frame_is_wellformed_eth2(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_2(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_3(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     !(frame_has_ipv4_tcp(frame) || frame_has_ipv4_udp(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_4(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_tcp(frame) &&
     !(frame_has_ipv4_tcp_on_allowed_port(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_5(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_udp(frame) &&
     !(frame_has_ipv4_udp_on_allowed_port(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_6(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_arp(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn hlr_1_7(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_tcp(frame) &&
     frame_has_ipv4_tcp_on_allowed_port(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn hlr_1_8(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_udp(frame) &&
     frame_has_ipv4_udp_on_allowed_port(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn should_allow_inbound_frame_rx(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   hlr_1_1(frame,should_allow) && hlr_1_2(frame,should_allow) &&
     hlr_1_3(frame,should_allow) &&
     hlr_1_4(frame,should_allow) &&
     hlr_1_5(frame,should_allow) &&
     hlr_1_6(frame,should_allow) &&
     hlr_1_7(frame,should_allow) &&
     hlr_1_8(frame,should_allow)
 }

/** Compute Entrypoint Contract
  *
  * guarantee rx
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_EthernetFramesRxOut0 outgoing event data port
  */
pub fn compute_spec_rx_guarantee(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut0: Option<SW::RawEthernetMessage>) -> bool 
 {
   impliesL(
     api_EthernetFramesRxIn0.is_some(),
     (impliesL(
       api_EthernetFramesRxOut0.is_some(),
       should_allow_inbound_frame_rx(api_EthernetFramesRxIn0.unwrap(),true))) &&
       (impliesL(
         api_EthernetFramesRxOut0.is_none(),
         should_allow_inbound_frame_rx(api_EthernetFramesRxIn0.unwrap(),false))))
 }

/** CEP-T-Guar: Top-level guarantee contracts for RxFirewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_EthernetFramesRxOut0 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut0: Option<SW::RawEthernetMessage>) -> bool 
 {
   let r0: bool = compute_spec_rx_guarantee(api_EthernetFramesRxIn0, api_EthernetFramesRxOut0);

   return r0;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for RxFirewall
  *
  * @param api_EthernetFramesRxIn0 incoming event data port
  * @param api_EthernetFramesRxIn1 incoming event data port
  * @param api_EthernetFramesRxIn2 incoming event data port
  * @param api_EthernetFramesRxIn3 incoming event data port
  * @param api_EthernetFramesRxOut0 outgoing event data port
  * @param api_EthernetFramesRxOut1 outgoing event data port
  * @param api_EthernetFramesRxOut2 outgoing event data port
  * @param api_EthernetFramesRxOut3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesRxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut3: Option<SW::RawEthernetMessage>) -> bool 
 {
   // CEP-Guar: guarantee clauses of RxFirewall's compute entrypoint
   let r0: bool = compute_CEP_T_Guar(api_EthernetFramesRxIn0, api_EthernetFramesRxOut0);

   return r0;
 }
