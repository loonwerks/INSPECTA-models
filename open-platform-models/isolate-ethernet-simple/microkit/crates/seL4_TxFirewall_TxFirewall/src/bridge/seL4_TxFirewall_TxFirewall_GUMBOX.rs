// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16 
 {
   ((byte0) as u16) * 256u16 + ((byte1) as u16)
 }

pub fn frame_is_wellformed_eth2(frame: SW::RawEthernetMessage) -> bool 
 {
   if (!((frame[12] >= 6u8) &&
     (frame[13] >= 0u8))) {
     false
   } else {
     true
   }
 }

pub fn frame_has_ipv4(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 8u8) &&
       (frame[13] == 0u8))) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv6(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 134u8) &&
       (frame[13] == 221u8))) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_arp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 8u8) &&
       (frame[13] == 6u8))) {
       false
     } else {
       true
     }))
 }

pub fn hlr_2_1(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (!(frame_is_wellformed_eth2(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_2_2(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_2_3(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_arp(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn hlr_2_4(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn should_allow_outbound_frame_tx(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   hlr_2_1(frame,should_allow) && hlr_2_2(frame,should_allow) &&
     hlr_2_3(frame,should_allow) &&
     hlr_2_4(frame,should_allow)
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_tx_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn0.is_some(),
     (impliesL(
       api_EthernetFramesTxOut0.is_some(),
       should_allow_outbound_frame_tx(api_EthernetFramesTxIn0.unwrap(),true))) &&
       (impliesL(
         api_EthernetFramesTxOut0.is_none(),
         should_allow_outbound_frame_tx(api_EthernetFramesTxIn0.unwrap(),false))))
 }

/** CEP-T-Guar: Top-level guarantee contracts for TxFirewall's compute entrypoint
  *
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   let r0: bool = compute_spec_tx_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);

   return r0;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for TxFirewall
  *
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   // CEP-Guar: guarantee clauses of TxFirewall's compute entrypoint
   let r0: bool = compute_CEP_T_Guar(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);

   return r0;
 }
