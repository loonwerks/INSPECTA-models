// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16 
 {
   ((byte0) as u16) * 256u16 + ((byte1) as u16)
 }

pub fn frame_is_wellformed_eth2(frame: SW::RawEthernetMessage) -> bool 
 {
   valid_frame_ethertype(frame) && valid_frame_dst_addr(frame)
 }

pub fn valid_frame_ethertype(frame: SW::RawEthernetMessage) -> bool 
 {
   frame_has_ipv4(frame) || frame_has_arp(frame) ||
     frame_has_ipv6(frame)
 }

pub fn valid_frame_dst_addr(frame: SW::RawEthernetMessage) -> bool 
 {
   !((frame[0] == 0u8) &&
     (frame[1] == 0u8) &&
     (frame[2] == 0u8) &&
     (frame[3] == 0u8) &&
     (frame[4] == 0u8) &&
     (frame[5] == 0u8))
 }

pub fn frame_has_ipv4(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[12] == 8u8) &&
     (frame[13] == 0u8)
 }

pub fn frame_has_ipv6(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[12] == 134u8) &&
     (frame[13] == 221u8)
 }

pub fn frame_has_arp(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[12] == 8u8) &&
     (frame[13] == 6u8)
 }

pub fn arp_has_ipv4(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[16] == 8u8) &&
     (frame[17] == 0u8)
 }

pub fn arp_has_ipv6(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[16] == 134u8) &&
     (frame[17] == 221u8)
 }

pub fn valid_arp_ptype(frame: SW::RawEthernetMessage) -> bool 
 {
   arp_has_ipv4(frame) || arp_has_ipv6(frame)
 }

pub fn valid_arp_op(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[20] == 0u8) &&
     ((frame[21] == 1u8) ||
       (frame[21] == 2u8))
 }

pub fn valid_arp_htype(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[14] == 0u8) &&
     (frame[15] == 1u8)
 }

pub fn wellformed_arp_frame(frame: SW::RawEthernetMessage) -> bool 
 {
   valid_arp_op(frame) && valid_arp_htype(frame) &&
     valid_arp_ptype(frame)
 }

pub fn valid_ipv4_length(frame: SW::RawEthernetMessage) -> bool 
 {
   two_bytes_to_u16(frame[16],frame[17]) <= 9000u16
 }

pub fn valid_ipv4_protocol(frame: SW::RawEthernetMessage) -> bool 
 {
   (frame[23] == 0u8) ||
     (frame[23] == 1u8) ||
     (frame[23] == 2u8) ||
     (frame[23] == 6u8) ||
     (frame[23] == 17u8) ||
     (frame[23] == 43u8) ||
     (frame[23] == 44u8) ||
     (frame[23] == 58u8) ||
     (frame[23] == 59u8) ||
     (frame[23] == 60u8)
 }

pub fn wellformed_ipv4_frame(frame: SW::RawEthernetMessage) -> bool 
 {
   valid_ipv4_protocol(frame) && valid_ipv4_length(frame)
 }

pub fn valid_ipv6(frame: SW::RawEthernetMessage) -> bool 
 {
   frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)
 }

pub fn hlr_07(frame: SW::RawEthernetMessage) -> bool 
 {
   frame_is_wellformed_eth2(frame) && frame_has_arp(frame) &&
     wellformed_arp_frame(frame)
 }

pub fn hlr_12(frame: SW::RawEthernetMessage) -> bool 
 {
   frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     wellformed_ipv4_frame(frame)
 }

pub fn allow_outbound_frame(frame: SW::RawEthernetMessage) -> bool 
 {
   hlr_07(frame) || hlr_12(frame)
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx0_allow
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_tx0_allow_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn0.is_some() && allow_outbound_frame(api_EthernetFramesTxIn0.unwrap()),
     api_EthernetFramesTxOut0.is_some() &&
       (api_EthernetFramesTxIn0.unwrap() == api_EthernetFramesTxOut0.unwrap().message))
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx0_disallow
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_tx0_disallow_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn0.is_some() && !(allow_outbound_frame(api_EthernetFramesTxIn0.unwrap())),
     api_EthernetFramesTxOut0.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx0_no_input
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  */
pub fn compute_spec_tx0_no_input_guarantee(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     !(api_EthernetFramesTxIn0.is_some()),
     api_EthernetFramesTxOut0.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx1_allow
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_tx1_allow_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn1.is_some() && allow_outbound_frame(api_EthernetFramesTxIn1.unwrap()),
     api_EthernetFramesTxOut1.is_some() &&
       (api_EthernetFramesTxIn1.unwrap() == api_EthernetFramesTxOut1.unwrap().message))
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx1_disallow
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_tx1_disallow_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn1.is_some() && !(allow_outbound_frame(api_EthernetFramesTxIn1.unwrap())),
     api_EthernetFramesTxOut1.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx1_no_input
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  */
pub fn compute_spec_tx1_no_input_guarantee(
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     !(api_EthernetFramesTxIn1.is_some()),
     api_EthernetFramesTxOut1.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx2_allow
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_tx2_allow_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn2.is_some() && allow_outbound_frame(api_EthernetFramesTxIn2.unwrap()),
     api_EthernetFramesTxOut2.is_some() &&
       (api_EthernetFramesTxIn2.unwrap() == api_EthernetFramesTxOut2.unwrap().message))
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx2_disallow
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_tx2_disallow_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn2.is_some() && !(allow_outbound_frame(api_EthernetFramesTxIn2.unwrap())),
     api_EthernetFramesTxOut2.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx2_no_input
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  */
pub fn compute_spec_tx2_no_input_guarantee(
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     !(api_EthernetFramesTxIn2.is_some()),
     api_EthernetFramesTxOut2.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx3_allow
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_tx3_allow_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn3.is_some() && allow_outbound_frame(api_EthernetFramesTxIn3.unwrap()),
     api_EthernetFramesTxOut3.is_some() &&
       (api_EthernetFramesTxIn3.unwrap() == api_EthernetFramesTxOut3.unwrap().message))
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx3_disallow
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_tx3_disallow_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     api_EthernetFramesTxIn3.is_some() && !(allow_outbound_frame(api_EthernetFramesTxIn3.unwrap())),
     api_EthernetFramesTxOut3.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx3_no_input
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_spec_tx3_no_input_guarantee(
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   impliesL(
     !(api_EthernetFramesTxIn3.is_some()),
     api_EthernetFramesTxOut3.is_none())
 }

/** CEP-T-Guar: Top-level guarantee contracts for TxFirewall's compute entrypoint
  *
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   let r0: bool = compute_spec_tx0_allow_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
   let r1: bool = compute_spec_tx0_disallow_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
   let r2: bool = compute_spec_tx0_no_input_guarantee(api_EthernetFramesTxIn0, api_EthernetFramesTxOut0);
   let r3: bool = compute_spec_tx1_allow_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
   let r4: bool = compute_spec_tx1_disallow_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
   let r5: bool = compute_spec_tx1_no_input_guarantee(api_EthernetFramesTxIn1, api_EthernetFramesTxOut1);
   let r6: bool = compute_spec_tx2_allow_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
   let r7: bool = compute_spec_tx2_disallow_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
   let r8: bool = compute_spec_tx2_no_input_guarantee(api_EthernetFramesTxIn2, api_EthernetFramesTxOut2);
   let r9: bool = compute_spec_tx3_allow_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);
   let r10: bool = compute_spec_tx3_disallow_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);
   let r11: bool = compute_spec_tx3_no_input_guarantee(api_EthernetFramesTxIn3, api_EthernetFramesTxOut3);

   return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8 && r9 && r10 && r11;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for TxFirewall
  *
  * @param api_EthernetFramesTxIn0 incoming event data port
  * @param api_EthernetFramesTxIn1 incoming event data port
  * @param api_EthernetFramesTxIn2 incoming event data port
  * @param api_EthernetFramesTxIn3 incoming event data port
  * @param api_EthernetFramesTxOut0 outgoing event data port
  * @param api_EthernetFramesTxOut1 outgoing event data port
  * @param api_EthernetFramesTxOut2 outgoing event data port
  * @param api_EthernetFramesTxOut3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesTxIn0: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn1: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn2: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn3: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut0: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut1: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut2: Option<SW::SizedEthernetMessage_Impl>,
  api_EthernetFramesTxOut3: Option<SW::SizedEthernetMessage_Impl>) -> bool 
 {
   // CEP-Guar: guarantee clauses of TxFirewall's compute entrypoint
   let r0: bool = compute_CEP_T_Guar(api_EthernetFramesTxIn0, api_EthernetFramesTxIn1, api_EthernetFramesTxIn2, api_EthernetFramesTxIn3, api_EthernetFramesTxOut0, api_EthernetFramesTxOut1, api_EthernetFramesTxOut2, api_EthernetFramesTxOut3);

   return r0;
 }
