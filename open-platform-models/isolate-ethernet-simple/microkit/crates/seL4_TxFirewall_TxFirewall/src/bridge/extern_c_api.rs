// Do not edit this file as it will be overwritten if codegen is rerun

//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to be verified by other means.

use crate::data::*;

#[cfg(test)]
use std::sync::Mutex;

#[cfg(not(test))]
extern "C" {
  fn get_EthernetFramesTxIn0(value: *mut SW::RawEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesTxIn1(value: *mut SW::RawEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesTxIn2(value: *mut SW::RawEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesTxIn3(value: *mut SW::RawEthernetMessage_Impl) -> bool;
  fn put_EthernetFramesTxOut0(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn put_EthernetFramesTxOut1(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn put_EthernetFramesTxOut2(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn put_EthernetFramesTxOut3(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
}

pub fn unsafe_get_EthernetFramesTxIn0() -> Option<SW::RawEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage_Impl = &mut [0;                        st"${(ops.ISZOps(np.qualifiedRustNameS).dropRight(1), "::")}"::SW_RawEthernetMessage_Impl_DIM_0];
     if (get_EthernetFramesTxIn0(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxIn1() -> Option<SW::RawEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage_Impl = &mut [0;                        st"${(ops.ISZOps(np.qualifiedRustNameS).dropRight(1), "::")}"::SW_RawEthernetMessage_Impl_DIM_0];
     if (get_EthernetFramesTxIn1(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxIn2() -> Option<SW::RawEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage_Impl = &mut [0;                        st"${(ops.ISZOps(np.qualifiedRustNameS).dropRight(1), "::")}"::SW_RawEthernetMessage_Impl_DIM_0];
     if (get_EthernetFramesTxIn2(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxIn3() -> Option<SW::RawEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage_Impl = &mut [0;                        st"${(ops.ISZOps(np.qualifiedRustNameS).dropRight(1), "::")}"::SW_RawEthernetMessage_Impl_DIM_0];
     if (get_EthernetFramesTxIn3(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_put_EthernetFramesTxOut0(value: &SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     return put_EthernetFramesTxOut0(value as *const SW::SizedEthernetMessage_Impl as *mut SW::SizedEthernetMessage_Impl);
   }
 }

pub fn unsafe_put_EthernetFramesTxOut1(value: &SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     return put_EthernetFramesTxOut1(value as *const SW::SizedEthernetMessage_Impl as *mut SW::SizedEthernetMessage_Impl);
   }
 }

pub fn unsafe_put_EthernetFramesTxOut2(value: &SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     return put_EthernetFramesTxOut2(value as *const SW::SizedEthernetMessage_Impl as *mut SW::SizedEthernetMessage_Impl);
   }
 }

pub fn unsafe_put_EthernetFramesTxOut3(value: &SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     return put_EthernetFramesTxOut3(value as *const SW::SizedEthernetMessage_Impl as *mut SW::SizedEthernetMessage_Impl);
   }
 }

//////////////////////////////////////////////////////////////////////////////////
// Testing Versions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w,
  // but we couldn't do that for in ports since they are read-only
  pub static ref IN_EthernetFramesTxIn0: Mutex<Option<SW::RawEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxIn1: Mutex<Option<SW::RawEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxIn2: Mutex<Option<SW::RawEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxIn3: Mutex<Option<SW::RawEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref OUT_EthernetFramesTxOut0: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref OUT_EthernetFramesTxOut1: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref OUT_EthernetFramesTxOut2: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref OUT_EthernetFramesTxOut3: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
}

#[cfg(test)]
pub fn get_EthernetFramesTxIn0(value: *mut SW::RawEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *value = IN_EthernetFramesTxIn0.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxIn1(value: *mut SW::RawEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *value = IN_EthernetFramesTxIn1.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxIn2(value: *mut SW::RawEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *value = IN_EthernetFramesTxIn2.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxIn3(value: *mut SW::RawEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *value = IN_EthernetFramesTxIn3.lock().unwrap().expect("Not expecting None");
     return true;
   }
 }

#[cfg(test)]
pub fn put_EthernetFramesTxOut0(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *OUT_EthernetFramesTxOut0.lock().unwrap() = Some(*value);
     return true;
   }
 }

#[cfg(test)]
pub fn put_EthernetFramesTxOut1(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *OUT_EthernetFramesTxOut1.lock().unwrap() = Some(*value);
     return true;
   }
 }

#[cfg(test)]
pub fn put_EthernetFramesTxOut2(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *OUT_EthernetFramesTxOut2.lock().unwrap() = Some(*value);
     return true;
   }
 }

#[cfg(test)]
pub fn put_EthernetFramesTxOut3(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     *OUT_EthernetFramesTxOut3.lock().unwrap() = Some(*value);
     return true;
   }
 }
