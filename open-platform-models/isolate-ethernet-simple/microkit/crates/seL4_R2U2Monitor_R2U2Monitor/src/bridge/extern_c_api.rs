// Do not edit this file as it will be overwritten if codegen is rerun

//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to be verified by other means.

use data::*;

#[cfg(test)]
use std::sync::Mutex;

#[cfg(not(test))]
extern "C" {
  fn get_EthernetFramesTxArduPilot0(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesTxArduPilot1(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesTxArduPilot2(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesTxArduPilot3(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxArduPilot0(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxArduPilot1(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxArduPilot2(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxArduPilot3(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesTxDriver0(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesTxDriver1(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesTxDriver2(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesTxDriver3(value: *mut SW::SizedEthernetMessage_Impl) -> bool;
  fn get_EthernetFramesRxDriver0(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxDriver1(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxDriver2(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxDriver3(value: *mut SW::RawEthernetMessage) -> bool;
}

pub fn unsafe_get_EthernetFramesTxArduPilot0() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesTxArduPilot0(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxArduPilot1() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesTxArduPilot1(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxArduPilot2() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesTxArduPilot2(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxArduPilot3() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesTxArduPilot3(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxArduPilot0() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxArduPilot0(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxArduPilot1() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxArduPilot1(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxArduPilot2() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxArduPilot2(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxArduPilot3() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxArduPilot3(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxDriver0() -> Option<SW::SizedEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::SizedEthernetMessage_Impl = &mut SW::SizedEthernetMessage_Impl::default();
     if (get_EthernetFramesTxDriver0(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxDriver1() -> Option<SW::SizedEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::SizedEthernetMessage_Impl = &mut SW::SizedEthernetMessage_Impl::default();
     if (get_EthernetFramesTxDriver1(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxDriver2() -> Option<SW::SizedEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::SizedEthernetMessage_Impl = &mut SW::SizedEthernetMessage_Impl::default();
     if (get_EthernetFramesTxDriver2(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesTxDriver3() -> Option<SW::SizedEthernetMessage_Impl> 
 {
   unsafe {
     let value: *mut SW::SizedEthernetMessage_Impl = &mut SW::SizedEthernetMessage_Impl::default();
     if (get_EthernetFramesTxDriver3(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxDriver0() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxDriver0(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxDriver1() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxDriver1(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxDriver2() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxDriver2(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

pub fn unsafe_get_EthernetFramesRxDriver3() -> Option<SW::RawEthernetMessage> 
 {
   unsafe {
     let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
     if (get_EthernetFramesRxDriver3(value)) {
       return Some(*value);
     } else {
       return None;
     }
   }
 }

//////////////////////////////////////////////////////////////////////////////////
// Testing Versions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w,
  // but we couldn't do that for in ports since they are read-only
  pub static ref IN_EthernetFramesTxArduPilot0: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxArduPilot1: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxArduPilot2: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxArduPilot3: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxArduPilot0: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxArduPilot1: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxArduPilot2: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxArduPilot3: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxDriver0: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxDriver1: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxDriver2: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesTxDriver3: Mutex<Option<SW::SizedEthernetMessage_Impl>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxDriver0: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxDriver1: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxDriver2: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxDriver3: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
}

#[cfg(test)]
pub fn initialize_test_globals() {
  unsafe {
    *IN_EthernetFramesTxArduPilot0.lock().unwrap() = None;
    *IN_EthernetFramesTxArduPilot1.lock().unwrap() = None;
    *IN_EthernetFramesTxArduPilot2.lock().unwrap() = None;
    *IN_EthernetFramesTxArduPilot3.lock().unwrap() = None;
    *IN_EthernetFramesRxArduPilot0.lock().unwrap() = None;
    *IN_EthernetFramesRxArduPilot1.lock().unwrap() = None;
    *IN_EthernetFramesRxArduPilot2.lock().unwrap() = None;
    *IN_EthernetFramesRxArduPilot3.lock().unwrap() = None;
    *IN_EthernetFramesTxDriver0.lock().unwrap() = None;
    *IN_EthernetFramesTxDriver1.lock().unwrap() = None;
    *IN_EthernetFramesTxDriver2.lock().unwrap() = None;
    *IN_EthernetFramesTxDriver3.lock().unwrap() = None;
    *IN_EthernetFramesRxDriver0.lock().unwrap() = None;
    *IN_EthernetFramesRxDriver1.lock().unwrap() = None;
    *IN_EthernetFramesRxDriver2.lock().unwrap() = None;
    *IN_EthernetFramesRxDriver3.lock().unwrap() = None;
  }
}

#[cfg(test)]
pub fn get_EthernetFramesTxArduPilot0(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxArduPilot0.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxArduPilot1(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxArduPilot1.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxArduPilot2(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxArduPilot2.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxArduPilot3(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxArduPilot3.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxArduPilot0(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxArduPilot0.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxArduPilot1(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxArduPilot1.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxArduPilot2(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxArduPilot2.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxArduPilot3(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxArduPilot3.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxDriver0(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxDriver0.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxDriver1(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxDriver1.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxDriver2(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxDriver2.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesTxDriver3(value: *mut SW::SizedEthernetMessage_Impl) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesTxDriver3.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxDriver0(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxDriver0.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxDriver1(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxDriver1.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxDriver2(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxDriver2.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }

#[cfg(test)]
pub fn get_EthernetFramesRxDriver3(value: *mut SW::RawEthernetMessage) -> bool 
 {
   unsafe {
     match *IN_EthernetFramesRxDriver3.lock().unwrap() {
       Some(v) => {
         *value = v;
         return true;
       },
       None => return false,
     }
   }
 }
