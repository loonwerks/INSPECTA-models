// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::*;

pub fn implies(lhs: bool, rhs: bool) -> bool {
  return !lhs || rhs;
}

pub fn impliesL(lhs: bool, rhs: bool) -> bool {
  return !lhs | rhs;
}

/** CEP-Pre: Compute Entrypoint Pre-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_CEP_Pre(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   // CEP-Assm: assume clauses of Firewall's compute entrypoint
   let r0: bool = compute_CEP_T_Assm(api_EthernetFramesRxIn, api_EthernetFramesTxIn);

   return r0;
 }

/** Compute Entrypoint Contract
  *
  * assumes onlyOneInEvent
  *   Allow at most one incoming event per dispatch
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_spec_onlyOneInEvent_assume(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   !(api_EthernetFramesRxIn.is_some()) && !(api_EthernetFramesTxIn.is_some()) ||
     (api_EthernetFramesRxIn.is_some() ^ api_EthernetFramesTxIn.is_some())
 }

/** CEP-T-Assm: Top-level assume contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_CEP_T_Assm(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   compute_spec_onlyOneInEvent_assume(api_EthernetFramesRxIn, api_EthernetFramesTxIn)
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_2
  *   1.2 firewall: drop ipv6 frames (RC_INSPECTA_00-HLR-2) The firewall shall drop any frame that is type ipv6.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_2_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   implies(
     api_EthernetFramesRxIn.is_some(),
     impliesL(
       api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV6,
       api_EthernetFramesRxOut.is_none()))
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_4
  *   1.4 firewall: drop RxIn ipv4 tcp frames with unexpected ports (RC_INSPECTA_00-HLR-4) The firewall shall
  *   drop any frame from RxIn that is an Ipv4 frame whose protocol is TCP and whose port is not defined in the port whitelist.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_4_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   implies(
     api_EthernetFramesRxIn.is_some(),
     impliesL(
       api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV6 &&
         api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::TCP &&
         !(api_EthernetFramesRxIn.unwrap().portIsWhitelisted),
       api_EthernetFramesRxOut.is_none() ||
         api_EthernetFramesRxOut.unwrap() != api_EthernetFramesRxIn.unwrap()))
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_5
  *   1.5 firewall: reply to RxIn arp requests (RC_INSPECTA_00-HLR-5) If the firewall gets an Arp request frame from RxIn,
  *   the firewall shall send an Arp reply frame to TxOut.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_5_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   impliesL(
     implies(
       api_EthernetFramesRxIn.is_some(),
       api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4) &&
       api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::ARP,
     api_EthernetFramesTxOut.is_some() &&
       api_EthernetFramesTxOut.unwrap().arpType == SW::ARP_Type::REPLY)
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_6
  *   1.6 firewall: copy through allowed tcp port packets (RC_INSPECTA_00-HLR-6) The firewall shall copy any frame from RxIn 
  *   that is an Ipv4 frame with the TCP protocol and whose port is defined in the port whitelist to RxOut.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_6_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   implies(
     api_EthernetFramesRxIn.is_some(),
     impliesL(
       api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4 &&
         api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::TCP &&
         api_EthernetFramesRxIn.unwrap().portIsWhitelisted,
       api_EthernetFramesRxOut.is_some() &&
         api_EthernetFramesRxIn.unwrap() == api_EthernetFramesRxOut.unwrap()))
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_7
  *   1.7 firewall: copy out tx arp and ipv4 frames (RC_INSPECTA_00-HLR-7) The firewall shall copy any frame from TxIn that
  *   is an Ipv4 or Arp frame to TxOut.
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_7_guarantee(
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   implies(
     api_EthernetFramesTxIn.is_some(),
     impliesL(
       api_EthernetFramesTxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4 ||
         api_EthernetFramesTxIn.unwrap().frameProtocol == SW::FrameProtocol::ARP,
       api_EthernetFramesTxOut.is_some() &&
         api_EthernetFramesTxIn.unwrap() == api_EthernetFramesTxOut.unwrap()))
 }

/** CEP-T-Guar: Top-level guarantee contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   compute_spec_RC_INSPECTA_00_HLR_2_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut) &
   compute_spec_RC_INSPECTA_00_HLR_4_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut) &
   compute_spec_RC_INSPECTA_00_HLR_5_guarantee(api_EthernetFramesRxIn, api_EthernetFramesTxOut) &
   compute_spec_RC_INSPECTA_00_HLR_6_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut) &
   compute_spec_RC_INSPECTA_00_HLR_7_guarantee(api_EthernetFramesTxIn, api_EthernetFramesTxOut)
 }

/** CEP-Post: Compute Entrypoint Post-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   // CEP-Guar: guarantee clauses of Firewall's compute entrypoint
   let r0: bool = compute_CEP_T_Guar(api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesRxOut, api_EthernetFramesTxOut);

   return r0;
 }
