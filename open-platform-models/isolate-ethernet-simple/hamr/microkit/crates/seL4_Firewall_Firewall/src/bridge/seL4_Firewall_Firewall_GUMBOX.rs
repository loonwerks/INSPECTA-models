// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn isMalformedFrame(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.malformedFrame
}

pub fn getInternetProtocol(v: SW::StructuredEthernetMessage_i) -> SW::InternetProtocol
{
  v.internetProtocol
}

pub fn isIPV4(v: SW::StructuredEthernetMessage_i) -> bool
{
  getInternetProtocol(v) == SW::InternetProtocol::IPV4
}

pub fn isIPV6(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.internetProtocol == SW::InternetProtocol::IPV6
}

pub fn getFrameProtocol(v: SW::StructuredEthernetMessage_i) -> SW::FrameProtocol
{
  v.frameProtocol
}

pub fn isTCP(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.frameProtocol == SW::FrameProtocol::TCP
}

pub fn isARP(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.frameProtocol == SW::FrameProtocol::ARP
}

pub fn isPortWhitelisted(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.portIsWhitelisted
}

pub fn getARP_Type(v: SW::StructuredEthernetMessage_i) -> SW::ARP_Type
{
  v.arpType
}

pub fn isARP_Request(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.arpType == SW::ARP_Type::REQUEST
}

pub fn isARP_Reply(v: SW::StructuredEthernetMessage_i) -> bool
{
  v.arpType == SW::ARP_Type::REPLY
}

/** Compute Entrypoint Contract
  *
  * assumes onlyOneInEvent
  *   Allow at most one incoming event per dispatch
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_spec_onlyOneInEvent_assume(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  !(api_EthernetFramesRxIn.is_some()) & !(api_EthernetFramesTxIn.is_some()) |
    api_EthernetFramesRxIn.is_some() ^ api_EthernetFramesTxIn.is_some()
}

/** CEP-T-Assm: Top-level assume contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_CEP_T_Assm(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  let r0: bool = compute_spec_onlyOneInEvent_assume(api_EthernetFramesRxIn, api_EthernetFramesTxIn);

  return r0;
}

/** CEP-Pre: Compute Entrypoint Pre-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_CEP_Pre(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  // CEP-Assm: assume clauses of Firewall's compute entrypoint
  let r0: bool = compute_CEP_T_Assm(api_EthernetFramesRxIn, api_EthernetFramesTxIn);

  return r0;
}

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_2
  *   1.2 firewall: drop ipv6 frames (RC_INSPECTA_00-HLR-2) The firewall shall drop any frame that is type ipv6.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_2_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  impliesL!(
    (implies!(
      api_EthernetFramesRxIn.is_some(),
      (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV6))),
    api_EthernetFramesRxOut.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_4
  *   1.4 firewall: drop RxIn ipv4 tcp frames with unexpected ports (RC_INSPECTA_00-HLR-4) The firewall shall
  *   drop any frame from RxIn that is an Ipv4 frame whose protocol is TCP and whose port is not defined in the port whitelist.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_4_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  impliesL!(
    (implies!(
      api_EthernetFramesRxIn.is_some(),
      (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV6) &
        (api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::TCP) &
        !(api_EthernetFramesRxIn.unwrap().portIsWhitelisted))),
    api_EthernetFramesRxOut.is_none() ||
      (api_EthernetFramesRxOut.unwrap() != api_EthernetFramesRxIn.unwrap()))
}

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_5
  *   1.5 firewall: reply to RxIn arp requests (RC_INSPECTA_00-HLR-5) If the firewall gets an Arp request frame from RxIn,
  *   the firewall shall send an Arp reply frame to TxOut.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_5_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  impliesL!(
    (implies!(
      api_EthernetFramesRxIn.is_some(),
      isIPV4(api_EthernetFramesRxIn.unwrap()) & isARP(api_EthernetFramesRxIn.unwrap()))),
    api_EthernetFramesTxOut.is_some() && isARP_Reply(api_EthernetFramesTxOut.unwrap()))
}

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_6
  *   1.6 firewall: copy through allowed tcp port packets (RC_INSPECTA_00-HLR-6) The firewall shall copy any frame from RxIn 
  *   that is an Ipv4 frame with the TCP protocol and whose port is defined in the port whitelist to RxOut.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_6_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  impliesL!(
    (implies!(
      api_EthernetFramesRxIn.is_some(),
      (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4) &
        (api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::TCP) &
        api_EthernetFramesRxIn.unwrap().portIsWhitelisted)),
    api_EthernetFramesRxOut.is_some() &&
      (api_EthernetFramesRxIn.unwrap() == api_EthernetFramesRxOut.unwrap()))
}

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_7
  *   1.7 firewall: copy out tx arp and ipv4 frames (RC_INSPECTA_00-HLR-7) The firewall shall copy any frame from TxIn that
  *   is an Ipv4 or Arp frame to TxOut.
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_7_guarantee(
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  impliesL!(
    (implies!(
      api_EthernetFramesTxIn.is_some(),
      (api_EthernetFramesTxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4) |
        (api_EthernetFramesTxIn.unwrap().frameProtocol == SW::FrameProtocol::ARP))),
    api_EthernetFramesTxOut.is_some() &&
      (api_EthernetFramesTxIn.unwrap() == api_EthernetFramesTxOut.unwrap()))
}

/** CEP-T-Guar: Top-level guarantee contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  let r0: bool = compute_spec_RC_INSPECTA_00_HLR_2_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
  let r1: bool = compute_spec_RC_INSPECTA_00_HLR_4_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
  let r2: bool = compute_spec_RC_INSPECTA_00_HLR_5_guarantee(api_EthernetFramesRxIn, api_EthernetFramesTxOut);
  let r3: bool = compute_spec_RC_INSPECTA_00_HLR_6_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
  let r4: bool = compute_spec_RC_INSPECTA_00_HLR_7_guarantee(api_EthernetFramesTxIn, api_EthernetFramesTxOut);

  return r0 && r1 && r2 && r3 && r4;
}

/** CEP-Post: Compute Entrypoint Post-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool
{
  // CEP-Guar: guarantee clauses of Firewall's compute entrypoint
  let r0: bool = compute_CEP_T_Guar(api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesRxOut, api_EthernetFramesTxOut);

  return r0;
}
