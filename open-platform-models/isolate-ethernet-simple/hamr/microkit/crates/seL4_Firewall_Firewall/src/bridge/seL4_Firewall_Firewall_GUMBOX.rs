// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

/** Compute Entrypoint Contract
  *
  * assumes onlyOneInEvent
  *   Allow at most one incoming event per dispatch
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_spec_onlyOneInEvent_assume(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   !(api_EthernetFramesRxIn.is_some()) & !(api_EthernetFramesTxIn.is_some()) |
     api_EthernetFramesRxIn.is_some() ^ api_EthernetFramesTxIn.is_some()
 }

/** CEP-T-Assm: Top-level assume contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_CEP_T_Assm(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   let r0: bool = compute_spec_onlyOneInEvent_assume(api_EthernetFramesRxIn, api_EthernetFramesTxIn);

   return r0;
 }

/** CEP-Pre: Compute Entrypoint Pre-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  */
pub fn compute_CEP_Pre(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   // CEP-Assm: assume clauses of Firewall's compute entrypoint
   let r0: bool = compute_CEP_T_Assm(api_EthernetFramesRxIn, api_EthernetFramesTxIn);

   return r0;
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_2
  *   1.2 firewall: drop ipv6 frames (RC_INSPECTA_00-HLR-2) The firewall shall drop any frame that is type ipv6.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_2_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   impliesL!(
     (implies!(
       api_EthernetFramesRxIn.is_some(),
       (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV6))),
     api_EthernetFramesRxOut.is_none())
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_4
  *   1.4 firewall: drop RxIn ipv4 tcp frames with unexpected ports (RC_INSPECTA_00-HLR-4) The firewall shall
  *   drop any frame from RxIn that is an Ipv4 frame whose protocol is TCP and whose port is not defined in the port whitelist.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_4_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   impliesL!(
     (implies!(
       api_EthernetFramesRxIn.is_some(),
       (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV6) &
         (api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::TCP) &
         !(api_EthernetFramesRxIn.unwrap().portIsWhitelisted))),
     api_EthernetFramesRxOut.is_none() ||
       (api_EthernetFramesRxOut.unwrap() != api_EthernetFramesRxIn.unwrap()))
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_5
  *   1.5 firewall: reply to RxIn arp requests (RC_INSPECTA_00-HLR-5) If the firewall gets an Arp request frame from RxIn,
  *   the firewall shall send an Arp reply frame to TxOut.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_5_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   impliesL!(
     (implies!(
       api_EthernetFramesRxIn.is_some(),
       (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4) &
         (api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::ARP))),
     api_EthernetFramesTxOut.is_some() &&
       (api_EthernetFramesTxOut.unwrap().arpType == SW::ARP_Type::REPLY))
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_6
  *   1.6 firewall: copy through allowed tcp port packets (RC_INSPECTA_00-HLR-6) The firewall shall copy any frame from RxIn 
  *   that is an Ipv4 frame with the TCP protocol and whose port is defined in the port whitelist to RxOut.
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_6_guarantee(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   impliesL!(
     (implies!(
       api_EthernetFramesRxIn.is_some(),
       (api_EthernetFramesRxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4) &
         (api_EthernetFramesRxIn.unwrap().frameProtocol == SW::FrameProtocol::TCP) &
         api_EthernetFramesRxIn.unwrap().portIsWhitelisted)),
     api_EthernetFramesRxOut.is_some() &&
       (api_EthernetFramesRxIn.unwrap() == api_EthernetFramesRxOut.unwrap()))
 }

/** Compute Entrypoint Contract
  *
  * guarantee RC_INSPECTA_00_HLR_7
  *   1.7 firewall: copy out tx arp and ipv4 frames (RC_INSPECTA_00-HLR-7) The firewall shall copy any frame from TxIn that
  *   is an Ipv4 or Arp frame to TxOut.
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_RC_INSPECTA_00_HLR_7_guarantee(
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   impliesL!(
     (implies!(
       api_EthernetFramesTxIn.is_some(),
       (api_EthernetFramesTxIn.unwrap().internetProtocol == SW::InternetProtocol::IPV4) |
         (api_EthernetFramesTxIn.unwrap().frameProtocol == SW::FrameProtocol::ARP))),
     api_EthernetFramesTxOut.is_some() &&
       (api_EthernetFramesTxIn.unwrap() == api_EthernetFramesTxOut.unwrap()))
 }

/** CEP-T-Guar: Top-level guarantee contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   let r0: bool = compute_spec_RC_INSPECTA_00_HLR_2_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
   let r1: bool = compute_spec_RC_INSPECTA_00_HLR_4_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
   let r2: bool = compute_spec_RC_INSPECTA_00_HLR_5_guarantee(api_EthernetFramesRxIn, api_EthernetFramesTxOut);
   let r3: bool = compute_spec_RC_INSPECTA_00_HLR_6_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
   let r4: bool = compute_spec_RC_INSPECTA_00_HLR_7_guarantee(api_EthernetFramesTxIn, api_EthernetFramesTxOut);

   return r0 && r1 && r2 && r3 && r4;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesRxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxIn: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesRxOut: Option<SW::StructuredEthernetMessage_i>,
  api_EthernetFramesTxOut: Option<SW::StructuredEthernetMessage_i>) -> bool 
 {
   // CEP-Guar: guarantee clauses of Firewall's compute entrypoint
   let r0: bool = compute_CEP_T_Guar(api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesRxOut, api_EthernetFramesTxOut);

   return r0;
 }
