package SW
public

	with CASE_Scheduling;
	with Data_Model;
	with Base_Types;
	with HAMR;

  data u16Array
    properties
      Data_Model::Data_Representation => Array;
      Data_Model::Base_Type => (classifier (Base_Types::Unsigned_16));
      Data_Model::Dimension => (4);
      HAMR::Bit_Codec_Max_Size => 8 Bytes;
  end u16Array;

	data RawEthernetMessage
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (1600);
			HAMR::Bit_Codec_Max_Size => 1600 Bytes;
	end RawEthernetMessage;

	-- data implementation RawEthernetMessage
	-- end RawEthernetMessage;
	
	data SizedEthernetMessage
	properties
	  Data_Model::Data_Representation => Struct;
	end SizedEthernetMessage;
	
	data implementation SizedEthernetMessage.Impl
	subcomponents
		message : data RawEthernetMessage;
		size : data Base_types::Unsigned_16;
	end SizedEthernetMessage.Impl;

	thread LowLevelEthernetDriver
		features
			-- Ethernet Frames: Raw Ethernet frames received from the physical network interface. 	  
			EthernetFramesRx0: out event data port RawEthernetMessage;
			EthernetFramesRx1: out event data port RawEthernetMessage;
			EthernetFramesRx2: out event data port RawEthernetMessage;
			EthernetFramesRx3: out event data port RawEthernetMessage;
			EthernetFramesTx0: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx1: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx2: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx3: in event data port SizedEthernetMessage.Impl;
	end LowLevelEthernetDriver;

	thread implementation LowLevelEthernetDriver.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			HAMR::Microkit_Language => Rust;
	end LowLevelEthernetDriver.Impl;

	process LowLevelEthernetDriver_seL4
		features
			-- Ethernet Frames: Raw Ethernet frames received from the physical network interface.
			EthernetFramesRx0: out event data port RawEthernetMessage;
			EthernetFramesRx1: out event data port RawEthernetMessage;
			EthernetFramesRx2: out event data port RawEthernetMessage;
			EthernetFramesRx3: out event data port RawEthernetMessage;
			EthernetFramesTx0: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx1: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx2: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx3: in event data port SizedEthernetMessage.Impl;
	end LowLevelEthernetDriver_seL4;

	process implementation LowLevelEthernetDriver_seL4.Impl
		subcomponents
			LowLevelEthernetDriver: thread LowLevelEthernetDriver.Impl;
		connections
			c1: port EthernetFramesTx0 -> LowLevelEthernetDriver.EthernetFramesTx0;
			c2: port EthernetFramesTx1 -> LowLevelEthernetDriver.EthernetFramesTx1;
			c3: port EthernetFramesTx2 -> LowLevelEthernetDriver.EthernetFramesTx2;
			c4: port EthernetFramesTx3 -> LowLevelEthernetDriver.EthernetFramesTx3;
			c5: port LowLevelEthernetDriver.EthernetFramesRx0 -> EthernetFramesRx0;
			c6: port LowLevelEthernetDriver.EthernetFramesRx1 -> EthernetFramesRx1;
			c7: port LowLevelEthernetDriver.EthernetFramesRx2 -> EthernetFramesRx2;
			c8: port LowLevelEthernetDriver.EthernetFramesRx3 -> EthernetFramesRx3;
		properties
			CASE_Scheduling::Domain => 2;
			HAMR::Microkit_Language => Rust;
	end LowLevelEthernetDriver_seL4.Impl;

	thread RxFirewall
		features
			EthernetFramesRxIn0: in event data port RawEthernetMessage;
			EthernetFramesRxIn1: in event data port RawEthernetMessage;
			EthernetFramesRxIn2: in event data port RawEthernetMessage;
			EthernetFramesRxIn3: in event data port RawEthernetMessage;
			EthernetFramesRxOut0: out event data port RawEthernetMessage;
			EthernetFramesRxOut1: out event data port RawEthernetMessage;
			EthernetFramesRxOut2: out event data port RawEthernetMessage;
			EthernetFramesRxOut3: out event data port RawEthernetMessage;
	end RxFirewall;

	thread implementation RxFirewall.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			HAMR::Microkit_Language => Rust;
		    annex GUMBO {**
      functions
          -- TODO: add const/vals to gumbo
          --def MIN_ETH2_FRAME_LENGTH(): Base_Types::Integer := 64;
          --def MAX_ETH2_FRAME_LENGTH(): Base_Types::Integer := 1518;
          
          
          -- TODO: TCP_ALLOWED_PORTS and UDP_ALLOWED_PORTS should probably be sig/ui functions.
          --       HAMR would just emit the signature and and empty body that the developer must
          --       subsequently fill in
          def TCP_ALLOWED_PORTS(): u16Array := u16Array(u16"5760", u16"0", u16"0", u16"0");
          
          def UDP_ALLOWED_PORTS(): u16Array := u16Array(u16"68", u16"0", u16"0", u16"0");
          
          
          def two_bytes_to_u16(byte0: Base_Types::Unsigned_8, byte1: Base_Types::Unsigned_8): Base_Types::Unsigned_16 :=
            byte0.toU16 * u16"256" + byte1.toU16; 
          
          def frame_is_wellformed_eth2(frame: RawEthernetMessage): Base_Types::Boolean :=
            --if (!(MIN_ETH2_FRAME_LENGTH() <= frame.size && frame.size <= MAX_ETH2_FRAME_LENGTH())) F
            if (frame_has_ipv4(frame) || frame_has_arp(frame) || frame_has_ipv6(frame)) T
            else F; 
            
          def frame_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
            frame_is_wellformed_eth2(frame) ->: (
              if (!(frame(12) == u8"8" && frame(13) == u8"0")) false 
              else T);
          
          def frame_has_ipv4_tcp(frame: RawEthernetMessage): Base_Types::Boolean :=
            (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame)) ->: (
              if (frame(23) != u8"6") false
              else true);
          
          def frame_has_ipv4_udp(frame: RawEthernetMessage): Base_Types::Boolean :=
            (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame)) ->: (
                if (!(frame(23) == u8"17")) false
                else true);
            
          def frame_has_ipv4_tcp_on_allowed_port(frame: RawEthernetMessage): Base_Types::Boolean :=
            (frame_is_wellformed_eth2(frame) && 
              frame_has_ipv4(frame) &&
              frame_has_ipv4_tcp(frame)) ->:
            TCP_ALLOWED_PORTS()(0) == two_bytes_to_u16(frame(36), frame(37));
          
          def frame_has_ipv4_tcp_on_allowed_port_quant(frame: RawEthernetMessage): Base_Types::Boolean :=
            Exists(0 until TCP_ALLOWED_PORTS().size)(i => 
                TCP_ALLOWED_PORTS()(i) == two_bytes_to_u16(frame(36), frame(37)));
          
          def frame_has_ipv4_udp_on_allowed_port(frame: RawEthernetMessage): Base_Types::Boolean :=
            (frame_is_wellformed_eth2(frame) && 
              frame_has_ipv4(frame) &&
              frame_has_ipv4_udp(frame)) ->:
            UDP_ALLOWED_PORTS()(0) == two_bytes_to_u16(frame(36), frame(37));
          
          def frame_has_ipv4_udp_on_allowed_port_quant(frame: RawEthernetMessage): Base_Types::Boolean :=
            Exists(0 until UDP_ALLOWED_PORTS().size)(i => 
                UDP_ALLOWED_PORTS()(i) == two_bytes_to_u16(frame(36), frame(37)));
            
          def frame_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) ->: (
              if (!(frame(12) == u8"134" && frame(13) == u8"221")) false
              else true);
                    
          def frame_has_arp(frame: RawEthernetMessage): Base_Types::Boolean := 
            frame_is_wellformed_eth2(frame) ->: (
              if (!(frame(12) == u8"8" && frame(13) == u8"6")) false
              else true);
          
          
          --------------------------------------------------------------------------
          -- RX Firewall
          --------------------------------------------------------------------------

          def hlr_1_1(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (!frame_is_wellformed_eth2(frame)) should_allow == false
            else true;
          
          def hlr_1_2(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)) should_allow == false
            else true;
            
          def hlr_1_3(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && 
                frame_has_ipv4(frame) && 
                !(frame_has_ipv4_tcp(frame) || frame_has_ipv4_udp(frame))) should_allow == false
            else true;
                      
          def hlr_1_4(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && 
                frame_has_ipv4(frame) && 
                frame_has_ipv4_tcp(frame) &&
                !frame_has_ipv4_tcp_on_allowed_port(frame)) should_allow == false
            else true;
            
          def hlr_1_5(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && 
                frame_has_ipv4(frame) && 
                frame_has_ipv4_udp(frame) &&
                !frame_has_ipv4_udp_on_allowed_port(frame)) should_allow == false
            else true;
            
          def hlr_1_6(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && 
                frame_has_arp(frame)) should_allow == true
            else true;
          
          def hlr_1_7(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && 
                frame_has_ipv4(frame) &&
                frame_has_ipv4_tcp(frame) &&
                frame_has_ipv4_tcp_on_allowed_port(frame)) should_allow == true
            else true;
            
          def hlr_1_8(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && 
                frame_has_ipv4(frame) &&
                frame_has_ipv4_udp(frame) &&
                frame_has_ipv4_udp_on_allowed_port(frame)) should_allow == true
            else true;
            
          def should_allow_inbound_frame_rx(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
            hlr_1_1(frame, should_allow) &&
            hlr_1_2(frame, should_allow) &&
            hlr_1_3(frame, should_allow) &&
            hlr_1_4(frame, should_allow) &&
            hlr_1_5(frame, should_allow) &&
            hlr_1_6(frame, should_allow) &&
            hlr_1_7(frame, should_allow) &&
            hlr_1_8(frame, should_allow);
            
      compute

        guarantee rx:
          (HasEvent(EthernetFramesRxIn0) ->: (
            (HasEvent(EthernetFramesRxOut0) ->: should_allow_inbound_frame_rx(EthernetFramesRxIn0, T)) &&
            (NoSend(EthernetFramesRxOut0) ->: should_allow_inbound_frame_rx(EthernetFramesRxIn0, F))));
           
    **};

	end RxFirewall.Impl;

	process RxFirewall_seL4
		features
			EthernetFramesRxIn0: in event data port RawEthernetMessage;
			EthernetFramesRxIn1: in event data port RawEthernetMessage;
			EthernetFramesRxIn2: in event data port RawEthernetMessage;
			EthernetFramesRxIn3: in event data port RawEthernetMessage;
			EthernetFramesRxOut0: out event data port RawEthernetMessage;
			EthernetFramesRxOut1: out event data port RawEthernetMessage;
			EthernetFramesRxOut2: out event data port RawEthernetMessage;
			EthernetFramesRxOut3: out event data port RawEthernetMessage;
	end RxFirewall_seL4;

	process implementation RxFirewall_seL4.Impl
		subcomponents
			RxFirewall: thread RxFirewall.Impl;
		connections
			c1: port EthernetFramesRxIn0 -> RxFirewall.EthernetFramesRxIn0;
			c2: port EthernetFramesRxIn1 -> RxFirewall.EthernetFramesRxIn1;
			c3: port EthernetFramesRxIn2 -> RxFirewall.EthernetFramesRxIn2;
			c4: port EthernetFramesRxIn3 -> RxFirewall.EthernetFramesRxIn3;
			c5: port RxFirewall.EthernetFramesRxOut0 -> EthernetFramesRxOut0;
			c6: port RxFirewall.EthernetFramesRxOut1 -> EthernetFramesRxOut1;
			c7: port RxFirewall.EthernetFramesRxOut2 -> EthernetFramesRxOut2;
			c8: port RxFirewall.EthernetFramesRxOut3 -> EthernetFramesRxOut3;
		properties
			CASE_Scheduling::Domain => 3;
			HAMR::Microkit_Language => Rust;
	end RxFirewall_seL4.Impl;

	thread TxFirewall
		features
			EthernetFramesTxIn0: in event data port RawEthernetMessage;
			EthernetFramesTxIn1: in event data port RawEthernetMessage;
			EthernetFramesTxIn2: in event data port RawEthernetMessage;
			EthernetFramesTxIn3: in event data port RawEthernetMessage;
			EthernetFramesTxOut0: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut1: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut2: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut3: out event data port SizedEthernetMessage.Impl;
	end TxFirewall;

	thread implementation TxFirewall.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			HAMR::Microkit_Language => Rust;
		annex GUMBO {**
      functions
          -- TODO: add const/vals to gumbo
          --def MIN_ETH2_FRAME_LENGTH(): Base_Types::Integer := 64;
          --def MAX_ETH2_FRAME_LENGTH(): Base_Types::Integer := 1518;
          
          
          -- TODO: TCP_ALLOWED_PORTS and UDP_ALLOWED_PORTS should probably be sig/ui functions.
          --       HAMR would just emit the signature and and empty body that the developer must
          --       subsequently fill in
          
          def two_bytes_to_u16(byte0: Base_Types::Unsigned_8, byte1: Base_Types::Unsigned_8): Base_Types::Unsigned_16 :=
            byte0.toU16 * u16"256" + byte1.toU16; 
          
          def frame_is_wellformed_eth2(frame: RawEthernetMessage): Base_Types::Boolean :=
            --if (!(MIN_ETH2_FRAME_LENGTH() <= frame.size && frame.size <= MAX_ETH2_FRAME_LENGTH())) F
            if (valid_frame_ethertype(frame) && valid_frame_dst_addr(frame)) T
            else F; 

          def valid_frame_ethertype(frame: RawEthernetMessage): Base_Types::Boolean :=
            if (frame_has_ipv4(frame) || frame_has_arp(frame) || frame_has_ipv6(frame)) T
            else F; 
            
          def valid_frame_dst_addr(frame: RawEthernetMessage): Base_Types::Boolean :=
              if (!(frame(0) == u8"0" &&
					frame(1) == u8"0" &&
					frame(2) == u8"0" &&
					frame(3) == u8"0" &&
					frame(4) == u8"0" &&
					frame(5) == u8"0")) T 
              else F;

          def frame_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
              if (!(frame(12) == u8"8" && frame(13) == u8"0")) false 
              else T;
          
          def frame_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
              if (!(frame(12) == u8"134" && frame(13) == u8"221")) false
              else true;
                    
          def frame_has_arp(frame: RawEthernetMessage): Base_Types::Boolean := 
              if (!(frame(12) == u8"8" && frame(13) == u8"6")) false
              else true;

          def arp_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
              if (!(frame(16) == u8"8" && frame(17) == u8"0")) false 
              else T;
          
          def arp_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
              if (!(frame(16) == u8"134" && frame(17) == u8"221")) false
              else true;

	      def valid_arp_ptype(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(arp_has_ipv4(frame) || arp_has_ipv6(frame))) false
		      else true;

	      def valid_arp_op(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(frame(20) == u8"0" && (frame(21) == u8"1" || frame(21) == u8"2"))) false
		      else true;

	      def valid_arp_htype(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(frame(14) == u8"0" && frame(15) == u8"1")) false
		      else true;

	      def wellformed_arp_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(valid_arp_op(frame) && valid_arp_htype(frame) && valid_arp_ptype(frame))) false
		      else true;

	      def valid_ipv4_length(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(two_bytes_to_u16(frame(16),frame(17)) <= u16"9000")) false
		      else true;

	      def valid_ipv4_protocol(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(frame(23) == u8"0" || frame(23) == u8"1" || frame(23) == u8"2" || frame(23) == u8"6" || frame(23) == u8"17" || frame(23) == u8"43" || frame(23) == u8"44" || frame(23) == u8"58" || frame(23) == u8"59" || frame(23) == u8"60")) false
		      else true;

	      def wellformed_ipv4_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
		      if (!(valid_ipv4_protocol(frame) && valid_ipv4_length(frame))) false
		      else true;
            
          --------------------------------------------------------------------------
          -- TX Firewall
          --------------------------------------------------------------------------
          
          -- def hlr_2_1(frame: RawEthernetMessage, should_allow: Base_Types::Boolean): Base_Types::Boolean :=
          --   if (!frame_is_wellformed_eth2(frame)) should_allow == false
          --   else true;
            
          def hlr_2_2(frame: RawEthernetMessage): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)) T
            else F;
            
          def hlr_2_3(frame: RawEthernetMessage): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && frame_has_arp(frame) && wellformed_arp_frame(frame)) T
            else F;
            
          def hlr_2_4(frame: RawEthernetMessage): Base_Types::Boolean :=
            if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) && wellformed_ipv4_frame(frame)) T
            else F;
            
          def should_allow_outbound_frame_tx(frame: RawEthernetMessage): Base_Types::Boolean :=
            hlr_2_3(frame) ||
            hlr_2_4(frame);

          def should_disallow_outbound_frame_tx(frame: RawEthernetMessage): Base_Types::Boolean :=
            if (!hlr_2_3(frame) &&
               !hlr_2_4(frame) &&
			   hlr_2_2(frame)) T
				else F;
            
      compute

        guarantee tx0:
          ((HasEvent(EthernetFramesTxIn0) && should_allow_outbound_frame_tx(EthernetFramesTxIn0)) ->: 
            (HasEvent(EthernetFramesTxOut0) && (EthernetFramesTxIn0 == EthernetFramesTxOut0.message))) &&
	       ((HasEvent(EthernetFramesTxIn0) && should_disallow_outbound_frame_tx(EthernetFramesTxIn0)) ->: 
	         (NoSend(EthernetFramesTxOut0)) &&
           (!HasEvent(EthernetFramesTxIn0) ->: NoSend(EthernetFramesTxOut0)));

        guarantee tx1:
          ((HasEvent(EthernetFramesTxIn1) && should_allow_outbound_frame_tx(EthernetFramesTxIn1)) ->: 
            (HasEvent(EthernetFramesTxOut1) && (EthernetFramesTxIn1 == EthernetFramesTxOut1.message))) &&
	       ((HasEvent(EthernetFramesTxIn1) && should_disallow_outbound_frame_tx(EthernetFramesTxIn1)) ->: 
	         (NoSend(EthernetFramesTxOut1)) &&
           (!HasEvent(EthernetFramesTxIn1) ->: NoSend(EthernetFramesTxOut1)));
           
        guarantee tx2:
          ((HasEvent(EthernetFramesTxIn2) && should_allow_outbound_frame_tx(EthernetFramesTxIn2)) ->: 
            (HasEvent(EthernetFramesTxOut2) && (EthernetFramesTxIn2 == EthernetFramesTxOut2.message))) &&
	       ((HasEvent(EthernetFramesTxIn2) && should_disallow_outbound_frame_tx(EthernetFramesTxIn2)) ->: 
	         (NoSend(EthernetFramesTxOut2)) &&
           (!HasEvent(EthernetFramesTxIn2) ->: NoSend(EthernetFramesTxOut2)));

        guarantee tx3:
          ((HasEvent(EthernetFramesTxIn3) && should_allow_outbound_frame_tx(EthernetFramesTxIn3)) ->: 
            (HasEvent(EthernetFramesTxOut3) && (EthernetFramesTxIn3 == EthernetFramesTxOut3.message))) &&
	       ((HasEvent(EthernetFramesTxIn3) && should_disallow_outbound_frame_tx(EthernetFramesTxIn3)) ->: 
	         (NoSend(EthernetFramesTxOut3)) &&
           (!HasEvent(EthernetFramesTxIn3) ->: NoSend(EthernetFramesTxOut3)));
    **};

	end TxFirewall.Impl;

	process TxFirewall_seL4
		features
			EthernetFramesTxIn0: in event data port RawEthernetMessage;
			EthernetFramesTxIn1: in event data port RawEthernetMessage;
			EthernetFramesTxIn2: in event data port RawEthernetMessage;
			EthernetFramesTxIn3: in event data port RawEthernetMessage;
			EthernetFramesTxOut0: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut1: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut2: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut3: out event data port SizedEthernetMessage.Impl;
	end TxFirewall_seL4;

	process implementation TxFirewall_seL4.Impl
		subcomponents
			TxFirewall: thread TxFirewall.Impl;
		connections
			c1: port EthernetFramesTxIn0 -> TxFirewall.EthernetFramesTxIn0;
			c2: port EthernetFramesTxIn1 -> TxFirewall.EthernetFramesTxIn1;
			c3: port EthernetFramesTxIn2 -> TxFirewall.EthernetFramesTxIn2;
			c4: port EthernetFramesTxIn3 -> TxFirewall.EthernetFramesTxIn3;
			c5: port TxFirewall.EthernetFramesTxOut0 -> EthernetFramesTxOut0;
			c6: port TxFirewall.EthernetFramesTxOut1 -> EthernetFramesTxOut1;
			c7: port TxFirewall.EthernetFramesTxOut2 -> EthernetFramesTxOut2;
			c8: port TxFirewall.EthernetFramesTxOut3 -> EthernetFramesTxOut3;
		properties
			CASE_Scheduling::Domain => 5;
			HAMR::Microkit_Language => Rust;
	end TxFirewall_seL4.Impl;

	thread ArduPilot
		features
			EthernetFramesRx0: in event data port RawEthernetMessage;
			EthernetFramesRx1: in event data port RawEthernetMessage;
			EthernetFramesRx2: in event data port RawEthernetMessage;
			EthernetFramesRx3: in event data port RawEthernetMessage;
			EthernetFramesTx0: out event data port RawEthernetMessage;
			EthernetFramesTx1: out event data port RawEthernetMessage;
			EthernetFramesTx2: out event data port RawEthernetMessage;
			EthernetFramesTx3: out event data port RawEthernetMessage;
	end ArduPilot;

	thread implementation ArduPilot.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			Source_Text => ("src/Ardupilot.c");
			Initialize_Entrypoint_Source_Text => "init";
			Compute_Entrypoint_Source_Text => "compute";
	end ArduPilot.Impl;

	process ArduPilot_seL4
		features
			EthernetFramesRx0: in event data port RawEthernetMessage;
			EthernetFramesRx1: in event data port RawEthernetMessage;
			EthernetFramesRx2: in event data port RawEthernetMessage;
			EthernetFramesRx3: in event data port RawEthernetMessage;
			EthernetFramesTx0: out event data port RawEthernetMessage;
			EthernetFramesTx1: out event data port RawEthernetMessage;
			EthernetFramesTx2: out event data port RawEthernetMessage;
			EthernetFramesTx3: out event data port RawEthernetMessage;
	end ArduPilot_seL4;

	process implementation ArduPilot_seL4.Impl
		subcomponents
			ArduPilot: thread ArduPilot.Impl;
		connections
			c1: port EthernetFramesRx0 -> ArduPilot.EthernetFramesRx0;
			c2: port EthernetFramesRx1 -> ArduPilot.EthernetFramesRx1;
			c3: port EthernetFramesRx2 -> ArduPilot.EthernetFramesRx2;
			c4: port EthernetFramesRx3 -> ArduPilot.EthernetFramesRx3;
			c5: port ArduPilot.EthernetFramesTx0 -> EthernetFramesTx0;
			c6: port ArduPilot.EthernetFramesTx1 -> EthernetFramesTx1;
			c7: port ArduPilot.EthernetFramesTx2 -> EthernetFramesTx2;
			c8: port ArduPilot.EthernetFramesTx3 -> EthernetFramesTx3;
		properties
			CASE_Scheduling::Domain => 4;
	end ArduPilot_seL4.Impl;

	system seL4
	end seL4;

	system implementation seL4.Impl
		subcomponents
			--LowLevelEthernetDriver: process LowLevelEthernetDriver_seL4.Impl;
			--RxFirewall: process RxFirewall_seL4.Impl;
			--TxFirewall: process TxFirewall_seL4.Impl;
			--ArduPilot: process ArduPilot_seL4.Impl;
			ArduPilot: process ArduPilot_seL4.Impl;
			RxFirewall: process RxFirewall_seL4.Impl;
			TxFirewall: process TxFirewall_seL4.Impl;
			LowLevelEthernetDriver: process LowLevelEthernetDriver_seL4.Impl;
			
		connections
			-- Incoming traffic
			c1: port LowLevelEthernetDriver.EthernetFramesRx0 -> RxFirewall.EthernetFramesRxIn0;
			c2: port LowLevelEthernetDriver.EthernetFramesRx1 -> RxFirewall.EthernetFramesRxIn1;
			c3: port LowLevelEthernetDriver.EthernetFramesRx2 -> RxFirewall.EthernetFramesRxIn2;
			c4: port LowLevelEthernetDriver.EthernetFramesRx3 -> RxFirewall.EthernetFramesRxIn3;
			c5: port RxFirewall.EthernetFramesRxOut0 -> ArduPilot.EthernetFramesRx0;
			c6: port RxFirewall.EthernetFramesRxOut1 -> ArduPilot.EthernetFramesRx1;
			c7: port RxFirewall.EthernetFramesRxOut2 -> ArduPilot.EthernetFramesRx2;
			c8: port RxFirewall.EthernetFramesRxOut3 -> ArduPilot.EthernetFramesRx3;
			-- Outgoing traffic
			c9: port ArduPilot.EthernetFramesTx0 -> TxFirewall.EthernetFramesTxIn0;
			c10: port ArduPilot.EthernetFramesTx1 -> TxFirewall.EthernetFramesTxIn1;
			c11: port ArduPilot.EthernetFramesTx2 -> TxFirewall.EthernetFramesTxIn2;
			c12: port ArduPilot.EthernetFramesTx3 -> TxFirewall.EthernetFramesTxIn3;
			c13: port TxFirewall.EthernetFramesTxOut0 -> LowLevelEthernetDriver.EthernetFramesTx0;
			c14: port TxFirewall.EthernetFramesTxOut1 -> LowLevelEthernetDriver.EthernetFramesTx1;
			c15: port TxFirewall.EthernetFramesTxOut2 -> LowLevelEthernetDriver.EthernetFramesTx2;
			c16: port TxFirewall.EthernetFramesTxOut3 -> LowLevelEthernetDriver.EthernetFramesTx3;
	end seL4.Impl;
	
end SW;
