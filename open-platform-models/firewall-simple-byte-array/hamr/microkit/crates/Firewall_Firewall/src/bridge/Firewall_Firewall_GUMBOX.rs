// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn TCP_ALLOWED_PORTS() -> SW::u16Array 
 {
   [5760u16, 0u16, 0u16, 0u16]
 }

pub fn UDP_ALLOWED_PORTS() -> SW::u16Array 
 {
   [68u16, 0u16, 0u16, 0u16]
 }

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16 
 {
   ((byte0) as u16) * 256u16 + ((byte1) as u16)
 }

pub fn frame_is_wellformed_eth2(frame: SW::RawEthernetMessage) -> bool 
 {
   if (!((frame[12] >= 6u8) &&
     (frame[13] >= 0u8))) {
     false
   } else {
     true
   }
 }

pub fn frame_has_ipv4(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 8u8) &&
       (frame[13] == 0u8))) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv4_tcp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame),
     (if (frame[23] != 6u8) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv4_udp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame),
     (if (!(frame[23] == 17u8)) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_ipv4_tcp_on_allowed_port(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
       frame_has_ipv4_tcp(frame),
     (TCP_ALLOWED_PORTS()[0] == two_bytes_to_u16(frame[36],frame[37])))
 }

pub fn frame_has_ipv4_tcp_on_allowed_port_quant(frame: SW::RawEthernetMessage) -> bool 
 {
   for i in 0 .. TCP_ALLOWED_PORTS().len() - 1 {
     if TCP_ALLOWED_PORTS()[i] == two_bytes_to_u16(frame[36],frame[37]) {
       return true;
     }
   }
   return false;
 }

pub fn frame_has_ipv4_udp_on_allowed_port(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
       frame_has_ipv4_udp(frame),
     (UDP_ALLOWED_PORTS()[0] == two_bytes_to_u16(frame[36],frame[37])))
 }

pub fn frame_has_ipv4_udp_on_allowed_port_quant(frame: SW::RawEthernetMessage) -> bool 
 {
   for i in 0 .. UDP_ALLOWED_PORTS().len() - 1 {
     if UDP_ALLOWED_PORTS()[i] == two_bytes_to_u16(frame[36],frame[37]) {
       return true;
     }
   }
   return false;
 }

pub fn frame_has_ipv6(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 134u8) &&
       (frame[13] == 221u8))) {
       false
     } else {
       true
     }))
 }

pub fn frame_has_arp(frame: SW::RawEthernetMessage) -> bool 
 {
   impliesL!(
     frame_is_wellformed_eth2(frame),
     (if (!((frame[12] == 8u8) &&
       (frame[13] == 6u8))) {
       false
     } else {
       true
     }))
 }

pub fn hlr_1_1(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (!(frame_is_wellformed_eth2(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_2(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_3(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     !(frame_has_ipv4_tcp(frame) || frame_has_ipv4_udp(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_4(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_tcp(frame) &&
     !(frame_has_ipv4_tcp_on_allowed_port(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_5(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_udp(frame) &&
     !(frame_has_ipv4_udp_on_allowed_port(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_1_6(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_arp(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn hlr_1_7(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_tcp(frame) &&
     frame_has_ipv4_tcp_on_allowed_port(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn hlr_1_8(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) &&
     frame_has_ipv4_udp(frame) &&
     frame_has_ipv4_udp_on_allowed_port(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn should_allow_inbound_frame_rx(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   hlr_1_1(frame,should_allow) && hlr_1_2(frame,should_allow) &&
     hlr_1_3(frame,should_allow) &&
     hlr_1_4(frame,should_allow) &&
     hlr_1_5(frame,should_allow) &&
     hlr_1_6(frame,should_allow) &&
     hlr_1_7(frame,should_allow) &&
     hlr_1_8(frame,should_allow)
 }

pub fn hlr_2_1(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (!(frame_is_wellformed_eth2(frame))) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_2_2(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame)) {
     should_allow == false
   } else {
     true
   }
 }

pub fn hlr_2_3(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_arp(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn hlr_2_4(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   if (frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame)) {
     should_allow == true
   } else {
     true
   }
 }

pub fn should_allow_outbound_frame_tx(
  frame: SW::RawEthernetMessage,
  should_allow: bool) -> bool 
 {
   hlr_2_1(frame,should_allow) && hlr_2_2(frame,should_allow) &&
     hlr_2_3(frame,should_allow) &&
     hlr_2_4(frame,should_allow)
 }

/** Compute Entrypoint Contract
  *
  * guarantee rx
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  */
pub fn compute_spec_rx_guarantee(
  api_EthernetFramesRxIn: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut: Option<SW::RawEthernetMessage>) -> bool 
 {
   (implies!(
     api_EthernetFramesRxIn.is_some(),
     (implies!(
       api_EthernetFramesRxOut.is_some(),
       should_allow_inbound_frame_rx(api_EthernetFramesRxIn.unwrap(),true) &&
         (api_EthernetFramesRxIn.unwrap() == api_EthernetFramesRxOut.unwrap()))) &&
       (impliesL!(
         api_EthernetFramesRxOut.is_none(),
         should_allow_inbound_frame_rx(api_EthernetFramesRxIn.unwrap(),false))))) &&
     (impliesL!(
       !(api_EthernetFramesRxIn.is_some()),
       api_EthernetFramesRxOut.is_none()))
 }

/** Compute Entrypoint Contract
  *
  * guarantee tx
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_spec_tx_guarantee(
  api_EthernetFramesTxIn: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut: Option<SW::RawEthernetMessage>) -> bool 
 {
   (implies!(
     api_EthernetFramesTxIn.is_some(),
     (implies!(
       api_EthernetFramesTxOut.is_some(),
       should_allow_outbound_frame_tx(api_EthernetFramesTxIn.unwrap(),true) &&
         (api_EthernetFramesTxIn.unwrap() == api_EthernetFramesTxOut.unwrap()))) &&
       (impliesL!(
         api_EthernetFramesTxOut.is_none(),
         should_allow_outbound_frame_tx(api_EthernetFramesTxIn.unwrap(),false))))) &&
     (impliesL!(
       !(api_EthernetFramesTxIn.is_some()),
       api_EthernetFramesTxOut.is_none()))
 }

/** CEP-T-Guar: Top-level guarantee contracts for Firewall's compute entrypoint
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_EthernetFramesRxIn: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut: Option<SW::RawEthernetMessage>) -> bool 
 {
   let r0: bool = compute_spec_rx_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut);
   let r1: bool = compute_spec_tx_guarantee(api_EthernetFramesTxIn, api_EthernetFramesTxOut);

   return r0 && r1;
 }

/** CEP-Post: Compute Entrypoint Post-Condition for Firewall
  *
  * @param api_EthernetFramesRxIn incoming event data port
  * @param api_EthernetFramesTxIn incoming event data port
  * @param api_EthernetFramesRxOut outgoing event data port
  * @param api_EthernetFramesTxOut outgoing event data port
  */
pub fn compute_CEP_Post(
  api_EthernetFramesRxIn: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxIn: Option<SW::RawEthernetMessage>,
  api_EthernetFramesRxOut: Option<SW::RawEthernetMessage>,
  api_EthernetFramesTxOut: Option<SW::RawEthernetMessage>) -> bool 
 {
   // CEP-Guar: guarantee clauses of Firewall's compute entrypoint
   let r0: bool = compute_CEP_T_Guar(api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesRxOut, api_EthernetFramesTxOut);

   return r0;
 }
