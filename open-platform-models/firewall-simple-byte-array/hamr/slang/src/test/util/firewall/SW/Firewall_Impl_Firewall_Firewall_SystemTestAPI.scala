// #Sireum

package firewall.SW

import org.sireum._
import art._
import firewall.SystemTestSuiteSlang.runtimeMonitorStream
import firewall._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object Firewall_Impl_Firewall_Firewall_SystemTestAPI {
  /** helper method to set the values of all incoming ports
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesTxIn incoming event data port
    */
  def put_concrete_inputs(api_EthernetFramesRxIn: Option[SW.RawEthernetMessage],
                          api_EthernetFramesTxIn: Option[SW.RawEthernetMessage]): Unit = {
    put_EthernetFramesRxIn(api_EthernetFramesRxIn)
    put_EthernetFramesTxIn(api_EthernetFramesTxIn)
  }

  // setter for incoming event data port
  def put_EthernetFramesRxIn(value: Option[SW.RawEthernetMessage]): Unit = {
    value match {
      case Some(v) => Art.insertInInfrastructurePort(Arch.seL4_Impl_Instance_Firewall_Firewall.operational_api.EthernetFramesRxIn_Id, SW.RawEthernetMessage_Payload(v))
      case _ =>
    }
  }

  // setter for incoming event data port
  def put_EthernetFramesTxIn(value: Option[SW.RawEthernetMessage]): Unit = {
    value match {
      case Some(v) => Art.insertInInfrastructurePort(Arch.seL4_Impl_Instance_Firewall_Firewall.operational_api.EthernetFramesTxIn_Id, SW.RawEthernetMessage_Payload(v))
      case _ =>
    }
  }

  def fetchContainer(): firewall.SW.Firewall_Impl_Firewall_Firewall_PostState_Container_PS = {
    if (runtimeMonitorStream.contains(Arch.seL4_Impl_Instance_Firewall_Firewall.id)) {
      val (_, postContainer_) = runtimeMonitorStream.get(Arch.seL4_Impl_Instance_Firewall_Firewall.id).get
      return postContainer_.asInstanceOf[firewall.SW.Firewall_Impl_Firewall_Firewall_PostState_Container_PS]
    }
    else {
      assert(F, s"No post state recorded for ${Arch.seL4_Impl_Instance_Firewall_Firewall.name}")
      halt(s"No post state recorded for ${Arch.seL4_Impl_Instance_Firewall_Firewall.name}")
    }
  }

  def check_concrete_outputs(api_EthernetFramesRxOut: Option[SW.RawEthernetMessage],
                             api_EthernetFramesTxOut: Option[SW.RawEthernetMessage]): Unit = {
    var failureReasons: ISZ[ST] = ISZ()

    val actual_EthernetFramesRxOut = get_api_EthernetFramesRxOut()
    if (api_EthernetFramesRxOut != actual_EthernetFramesRxOut) {
      failureReasons = failureReasons :+ st"'EthernetFramesRxOut' did not match expected.  Expected: $api_EthernetFramesRxOut, Actual: $actual_EthernetFramesRxOut"
    }
    val actual_EthernetFramesTxOut = get_api_EthernetFramesTxOut()
    if (api_EthernetFramesTxOut != actual_EthernetFramesTxOut) {
      failureReasons = failureReasons :+ st"'EthernetFramesTxOut' did not match expected.  Expected: $api_EthernetFramesTxOut, Actual: $actual_EthernetFramesTxOut"
    }

    assert(failureReasons.isEmpty, st"${(failureReasons, "\n")}".render)
  }

  def get_api_EthernetFramesRxOut(): Option[SW.RawEthernetMessage] = {
    return fetchContainer().api_EthernetFramesRxOut
  }

  def get_api_EthernetFramesTxOut(): Option[SW.RawEthernetMessage] = {
    return fetchContainer().api_EthernetFramesTxOut
  }
}