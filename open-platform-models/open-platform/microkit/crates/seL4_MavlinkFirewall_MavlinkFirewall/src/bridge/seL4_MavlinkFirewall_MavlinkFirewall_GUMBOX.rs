// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn three_bytes_to_u32(
  byte0: u8,
  byte1: u8,
  byte2: u8) -> u32
{
  ((byte2) as u32) * 65536u32 + ((byte1) as u32) * 256u32 + ((byte0) as u32)
}

pub fn two_bytes_to_u16(
  byte0: u8,
  byte1: u8) -> u16
{
  ((byte1) as u16) * 256u16 + ((byte0) as u16)
}

pub fn msg_v1_is_command_int(msg: SW::UdpPayload) -> bool
{
  msg[5] == 75u8
}

pub fn command_int_msg_v1_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[33],msg[34]) == 42650u16
}

pub fn msg_v1_is_command_long(msg: SW::UdpPayload) -> bool
{
  msg[5] == 76u8
}

pub fn command_long_msg_v1_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[34],msg[35]) == 42650u16
}

pub fn msg_is_mavlinkv1(msg: SW::UdpPayload) -> bool
{
  msg[0] == 0xFEu8
}

pub fn msg_v2_is_command_int(msg: SW::UdpPayload) -> bool
{
  three_bytes_to_u32(msg[7],msg[8],msg[9]) == 75u32
}

pub fn command_int_msg_v2_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[37],msg[38]) == 42650u16
}

pub fn msg_v2_is_command_long(msg: SW::UdpPayload) -> bool
{
  three_bytes_to_u32(msg[7],msg[8],msg[9]) == 76u32
}

pub fn command_long_msg_v2_is_bootloader_flash(msg: SW::UdpPayload) -> bool
{
  two_bytes_to_u16(msg[38],msg[39]) == 42650u16
}

pub fn msg_is_mavlinkv2(msg: SW::UdpPayload) -> bool
{
  msg[0] == 0xFDu8
}

pub fn msg_is_mav_v2_cmd_flash_bootloader(msg: SW::UdpPayload) -> bool
{
  msg_is_mavlinkv2(msg) &&
    (msg_v2_is_command_int(msg) && command_int_msg_v2_is_bootloader_flash(msg) ||
      msg_v2_is_command_long(msg) && command_long_msg_v2_is_bootloader_flash(msg))
}

pub fn msg_is_mav_v1_cmd_flash_bootloader(msg: SW::UdpPayload) -> bool
{
  msg_is_mavlinkv1(msg) &&
    (msg_v1_is_command_int(msg) && command_int_msg_v1_is_bootloader_flash(msg) ||
      msg_v1_is_command_long(msg) && command_long_msg_v1_is_bootloader_flash(msg))
}

pub fn msg_is_mav_cmd_flash_bootloader(msg: SW::UdpPayload) -> bool
{
  msg_is_mav_v2_cmd_flash_bootloader(msg) || msg_is_mav_v1_cmd_flash_bootloader(msg)
}

pub fn mav_input_headers_eq_output(
  headers: SW::EthIpUdpHeaders,
  frame: SW::RawEthernetMessage) -> bool
{
  (0..headers.len()).all(|i| headers[i] == frame[i])
}

pub fn mav_input_payload_eq_output(
  payload: SW::UdpPayload,
  headers: SW::EthIpUdpHeaders,
  frame: SW::RawEthernetMessage) -> bool
{
  (0..payload.len()).all(|i| frame[i + headers.len()] == payload[i])
}

pub fn mav_input_eq_output(
  input: SW::UdpFrame_Impl,
  frame: SW::RawEthernetMessage) -> bool
{
  mav_input_headers_eq_output(input.headers,frame) && mav_input_payload_eq_output(input.payload,input.headers,frame)
}

pub fn msg_is_blacklisted(msg: SW::UdpPayload) -> bool
{
  msg_is_mav_cmd_flash_bootloader(msg)
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_19_mav0_drop_mav_cmd_flash_bootloader
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_spec_hlr_19_mav0_drop_mav_cmd_flash_bootloader_guarantee(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In0.is_some() && msg_is_mav_cmd_flash_bootloader(api_In0.unwrap().payload),
    api_Out0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_21_mav0_no_input
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_spec_hlr_21_mav0_no_input_guarantee(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_In0.is_some()),
    api_Out0.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_22_mav0_allow
  * @param api_In0 incoming event data port
  * @param api_Out0 outgoing event data port
  */
pub fn compute_spec_hlr_22_mav0_allow_guarantee(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In0.is_some() && !(msg_is_blacklisted(api_In0.unwrap().payload)),
    api_Out0.is_some() && mav_input_eq_output(api_In0.unwrap(),api_Out0.unwrap()))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_19_mav1_drop_mav_cmd_flash_bootloader
  * @param api_In1 incoming event data port
  * @param api_Out1 outgoing event data port
  */
pub fn compute_spec_hlr_19_mav1_drop_mav_cmd_flash_bootloader_guarantee(
  api_In1: Option<SW::UdpFrame_Impl>,
  api_Out1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In1.is_some() && msg_is_mav_cmd_flash_bootloader(api_In1.unwrap().payload),
    api_Out1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_21_mav1_no_input
  * @param api_In1 incoming event data port
  * @param api_Out1 outgoing event data port
  */
pub fn compute_spec_hlr_21_mav1_no_input_guarantee(
  api_In1: Option<SW::UdpFrame_Impl>,
  api_Out1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_In1.is_some()),
    api_Out1.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_22_mav1_allow
  * @param api_In1 incoming event data port
  * @param api_Out1 outgoing event data port
  */
pub fn compute_spec_hlr_22_mav1_allow_guarantee(
  api_In1: Option<SW::UdpFrame_Impl>,
  api_Out1: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In1.is_some() && !(msg_is_blacklisted(api_In1.unwrap().payload)),
    api_Out1.is_some() && mav_input_eq_output(api_In1.unwrap(),api_Out1.unwrap()))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_19_mav2_drop_mav_cmd_flash_bootloader
  * @param api_In2 incoming event data port
  * @param api_Out2 outgoing event data port
  */
pub fn compute_spec_hlr_19_mav2_drop_mav_cmd_flash_bootloader_guarantee(
  api_In2: Option<SW::UdpFrame_Impl>,
  api_Out2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In2.is_some() && msg_is_mav_cmd_flash_bootloader(api_In2.unwrap().payload),
    api_Out2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_21_mav2_no_input
  * @param api_In2 incoming event data port
  * @param api_Out2 outgoing event data port
  */
pub fn compute_spec_hlr_21_mav2_no_input_guarantee(
  api_In2: Option<SW::UdpFrame_Impl>,
  api_Out2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_In2.is_some()),
    api_Out2.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_22_mav2_allow
  * @param api_In2 incoming event data port
  * @param api_Out2 outgoing event data port
  */
pub fn compute_spec_hlr_22_mav2_allow_guarantee(
  api_In2: Option<SW::UdpFrame_Impl>,
  api_Out2: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In2.is_some() && !(msg_is_blacklisted(api_In2.unwrap().payload)),
    api_Out2.is_some() && mav_input_eq_output(api_In2.unwrap(),api_Out2.unwrap()))
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_19_mav3_drop_mav_cmd_flash_bootloader
  * @param api_In3 incoming event data port
  * @param api_Out3 outgoing event data port
  */
pub fn compute_spec_hlr_19_mav3_drop_mav_cmd_flash_bootloader_guarantee(
  api_In3: Option<SW::UdpFrame_Impl>,
  api_Out3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In3.is_some() && msg_is_mav_cmd_flash_bootloader(api_In3.unwrap().payload),
    api_Out3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_21_mav3_no_input
  * @param api_In3 incoming event data port
  * @param api_Out3 outgoing event data port
  */
pub fn compute_spec_hlr_21_mav3_no_input_guarantee(
  api_In3: Option<SW::UdpFrame_Impl>,
  api_Out3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    !(api_In3.is_some()),
    api_Out3.is_none())
}

/** Compute Entrypoint Contract
  *
  * guarantee hlr_22_mav3_allow
  * @param api_In3 incoming event data port
  * @param api_Out3 outgoing event data port
  */
pub fn compute_spec_hlr_22_mav3_allow_guarantee(
  api_In3: Option<SW::UdpFrame_Impl>,
  api_Out3: Option<SW::RawEthernetMessage>) -> bool
{
  impliesL!(
    api_In3.is_some() && !(msg_is_blacklisted(api_In3.unwrap().payload)),
    api_Out3.is_some() && mav_input_eq_output(api_In3.unwrap(),api_Out3.unwrap()))
}

/** CEP-T-Guar: Top-level guarantee contracts for MavlinkFirewall's compute entrypoint
  *
  * @param api_In0 incoming event data port
  * @param api_In1 incoming event data port
  * @param api_In2 incoming event data port
  * @param api_In3 incoming event data port
  * @param api_Out0 outgoing event data port
  * @param api_Out1 outgoing event data port
  * @param api_Out2 outgoing event data port
  * @param api_Out3 outgoing event data port
  */
pub fn compute_CEP_T_Guar(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_In1: Option<SW::UdpFrame_Impl>,
  api_In2: Option<SW::UdpFrame_Impl>,
  api_In3: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>,
  api_Out1: Option<SW::RawEthernetMessage>,
  api_Out2: Option<SW::RawEthernetMessage>,
  api_Out3: Option<SW::RawEthernetMessage>) -> bool
{
  let r0: bool = compute_spec_hlr_19_mav0_drop_mav_cmd_flash_bootloader_guarantee(api_In0, api_Out0);
  let r1: bool = compute_spec_hlr_21_mav0_no_input_guarantee(api_In0, api_Out0);
  let r2: bool = compute_spec_hlr_22_mav0_allow_guarantee(api_In0, api_Out0);
  let r3: bool = compute_spec_hlr_19_mav1_drop_mav_cmd_flash_bootloader_guarantee(api_In1, api_Out1);
  let r4: bool = compute_spec_hlr_21_mav1_no_input_guarantee(api_In1, api_Out1);
  let r5: bool = compute_spec_hlr_22_mav1_allow_guarantee(api_In1, api_Out1);
  let r6: bool = compute_spec_hlr_19_mav2_drop_mav_cmd_flash_bootloader_guarantee(api_In2, api_Out2);
  let r7: bool = compute_spec_hlr_21_mav2_no_input_guarantee(api_In2, api_Out2);
  let r8: bool = compute_spec_hlr_22_mav2_allow_guarantee(api_In2, api_Out2);
  let r9: bool = compute_spec_hlr_19_mav3_drop_mav_cmd_flash_bootloader_guarantee(api_In3, api_Out3);
  let r10: bool = compute_spec_hlr_21_mav3_no_input_guarantee(api_In3, api_Out3);
  let r11: bool = compute_spec_hlr_22_mav3_allow_guarantee(api_In3, api_Out3);

  return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8 && r9 && r10 && r11;
}

/** CEP-Post: Compute Entrypoint Post-Condition for MavlinkFirewall
  *
  * @param api_In0 incoming event data port
  * @param api_In1 incoming event data port
  * @param api_In2 incoming event data port
  * @param api_In3 incoming event data port
  * @param api_Out0 outgoing event data port
  * @param api_Out1 outgoing event data port
  * @param api_Out2 outgoing event data port
  * @param api_Out3 outgoing event data port
  */
pub fn compute_CEP_Post(
  api_In0: Option<SW::UdpFrame_Impl>,
  api_In1: Option<SW::UdpFrame_Impl>,
  api_In2: Option<SW::UdpFrame_Impl>,
  api_In3: Option<SW::UdpFrame_Impl>,
  api_Out0: Option<SW::RawEthernetMessage>,
  api_Out1: Option<SW::RawEthernetMessage>,
  api_Out2: Option<SW::RawEthernetMessage>,
  api_Out3: Option<SW::RawEthernetMessage>) -> bool
{
  // CEP-Guar: guarantee clauses of MavlinkFirewall's compute entrypoint
  let r0: bool = compute_CEP_T_Guar(api_In0, api_In1, api_In2, api_In3, api_Out0, api_Out1, api_Out2, api_Out3);

  return r0;
}
