// Do not edit this file as it will be overwritten if codegen is rerun

//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to be verified by other means.

use data::*;

#[cfg(test)]
use std::sync::Mutex;

#[cfg(not(test))]
extern "C" {
  fn get_EthernetFramesRxIn0(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxIn1(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxIn2(value: *mut SW::RawEthernetMessage) -> bool;
  fn get_EthernetFramesRxIn3(value: *mut SW::RawEthernetMessage) -> bool;
  fn put_VmmOut0(value: *mut SW::RawEthernetMessage) -> bool;
  fn put_VmmOut1(value: *mut SW::RawEthernetMessage) -> bool;
  fn put_VmmOut2(value: *mut SW::RawEthernetMessage) -> bool;
  fn put_VmmOut3(value: *mut SW::RawEthernetMessage) -> bool;
  fn put_MavlinkOut0(value: *mut SW::UdpFrame_Impl) -> bool;
  fn put_MavlinkOut1(value: *mut SW::UdpFrame_Impl) -> bool;
  fn put_MavlinkOut2(value: *mut SW::UdpFrame_Impl) -> bool;
  fn put_MavlinkOut3(value: *mut SW::UdpFrame_Impl) -> bool;
}

pub fn unsafe_get_EthernetFramesRxIn0() -> Option<SW::RawEthernetMessage>
{
  unsafe {
    let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
    if (get_EthernetFramesRxIn0(value)) {
      return Some(*value);
    } else {
      return None;
    }
  }
}

pub fn unsafe_get_EthernetFramesRxIn1() -> Option<SW::RawEthernetMessage>
{
  unsafe {
    let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
    if (get_EthernetFramesRxIn1(value)) {
      return Some(*value);
    } else {
      return None;
    }
  }
}

pub fn unsafe_get_EthernetFramesRxIn2() -> Option<SW::RawEthernetMessage>
{
  unsafe {
    let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
    if (get_EthernetFramesRxIn2(value)) {
      return Some(*value);
    } else {
      return None;
    }
  }
}

pub fn unsafe_get_EthernetFramesRxIn3() -> Option<SW::RawEthernetMessage>
{
  unsafe {
    let value: *mut SW::RawEthernetMessage = &mut [0; SW::SW_RawEthernetMessage_DIM_0];
    if (get_EthernetFramesRxIn3(value)) {
      return Some(*value);
    } else {
      return None;
    }
  }
}

pub fn unsafe_put_VmmOut0(value: &SW::RawEthernetMessage) -> bool
{
  unsafe {
    return put_VmmOut0(value as *const SW::RawEthernetMessage as *mut SW::RawEthernetMessage);
  }
}

pub fn unsafe_put_VmmOut1(value: &SW::RawEthernetMessage) -> bool
{
  unsafe {
    return put_VmmOut1(value as *const SW::RawEthernetMessage as *mut SW::RawEthernetMessage);
  }
}

pub fn unsafe_put_VmmOut2(value: &SW::RawEthernetMessage) -> bool
{
  unsafe {
    return put_VmmOut2(value as *const SW::RawEthernetMessage as *mut SW::RawEthernetMessage);
  }
}

pub fn unsafe_put_VmmOut3(value: &SW::RawEthernetMessage) -> bool
{
  unsafe {
    return put_VmmOut3(value as *const SW::RawEthernetMessage as *mut SW::RawEthernetMessage);
  }
}

pub fn unsafe_put_MavlinkOut0(value: &SW::UdpFrame_Impl) -> bool
{
  unsafe {
    return put_MavlinkOut0(value as *const SW::UdpFrame_Impl as *mut SW::UdpFrame_Impl);
  }
}

pub fn unsafe_put_MavlinkOut1(value: &SW::UdpFrame_Impl) -> bool
{
  unsafe {
    return put_MavlinkOut1(value as *const SW::UdpFrame_Impl as *mut SW::UdpFrame_Impl);
  }
}

pub fn unsafe_put_MavlinkOut2(value: &SW::UdpFrame_Impl) -> bool
{
  unsafe {
    return put_MavlinkOut2(value as *const SW::UdpFrame_Impl as *mut SW::UdpFrame_Impl);
  }
}

pub fn unsafe_put_MavlinkOut3(value: &SW::UdpFrame_Impl) -> bool
{
  unsafe {
    return put_MavlinkOut3(value as *const SW::UdpFrame_Impl as *mut SW::UdpFrame_Impl);
  }
}

//////////////////////////////////////////////////////////////////////////////////
// Testing Versions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w,
  // but we couldn't do that for in ports since they are read-only
  pub static ref IN_EthernetFramesRxIn0: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxIn1: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxIn2: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref IN_EthernetFramesRxIn3: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref OUT_VmmOut0: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref OUT_VmmOut1: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref OUT_VmmOut2: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref OUT_VmmOut3: Mutex<Option<SW::RawEthernetMessage>> = Mutex::new(None);
  pub static ref OUT_MavlinkOut0: Mutex<Option<SW::UdpFrame_Impl>> = Mutex::new(None);
  pub static ref OUT_MavlinkOut1: Mutex<Option<SW::UdpFrame_Impl>> = Mutex::new(None);
  pub static ref OUT_MavlinkOut2: Mutex<Option<SW::UdpFrame_Impl>> = Mutex::new(None);
  pub static ref OUT_MavlinkOut3: Mutex<Option<SW::UdpFrame_Impl>> = Mutex::new(None);
}

#[cfg(test)]
pub fn initialize_test_globals() {
  unsafe {
    *IN_EthernetFramesRxIn0.lock().unwrap() = None;
    *IN_EthernetFramesRxIn1.lock().unwrap() = None;
    *IN_EthernetFramesRxIn2.lock().unwrap() = None;
    *IN_EthernetFramesRxIn3.lock().unwrap() = None;
    *OUT_VmmOut0.lock().unwrap() = None;
    *OUT_VmmOut1.lock().unwrap() = None;
    *OUT_VmmOut2.lock().unwrap() = None;
    *OUT_VmmOut3.lock().unwrap() = None;
    *OUT_MavlinkOut0.lock().unwrap() = None;
    *OUT_MavlinkOut1.lock().unwrap() = None;
    *OUT_MavlinkOut2.lock().unwrap() = None;
    *OUT_MavlinkOut3.lock().unwrap() = None;
  }
}

#[cfg(test)]
pub fn get_EthernetFramesRxIn0(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    match *IN_EthernetFramesRxIn0.lock().unwrap() {
      Some(v) => {
        *value = v;
        return true;
      },
      None => return false,
    }
  }
}

#[cfg(test)]
pub fn get_EthernetFramesRxIn1(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    match *IN_EthernetFramesRxIn1.lock().unwrap() {
      Some(v) => {
        *value = v;
        return true;
      },
      None => return false,
    }
  }
}

#[cfg(test)]
pub fn get_EthernetFramesRxIn2(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    match *IN_EthernetFramesRxIn2.lock().unwrap() {
      Some(v) => {
        *value = v;
        return true;
      },
      None => return false,
    }
  }
}

#[cfg(test)]
pub fn get_EthernetFramesRxIn3(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    match *IN_EthernetFramesRxIn3.lock().unwrap() {
      Some(v) => {
        *value = v;
        return true;
      },
      None => return false,
    }
  }
}

#[cfg(test)]
pub fn put_VmmOut0(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    *OUT_VmmOut0.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_VmmOut1(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    *OUT_VmmOut1.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_VmmOut2(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    *OUT_VmmOut2.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_VmmOut3(value: *mut SW::RawEthernetMessage) -> bool
{
  unsafe {
    *OUT_VmmOut3.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_MavlinkOut0(value: *mut SW::UdpFrame_Impl) -> bool
{
  unsafe {
    *OUT_MavlinkOut0.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_MavlinkOut1(value: *mut SW::UdpFrame_Impl) -> bool
{
  unsafe {
    *OUT_MavlinkOut1.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_MavlinkOut2(value: *mut SW::UdpFrame_Impl) -> bool
{
  unsafe {
    *OUT_MavlinkOut2.lock().unwrap() = Some(*value);
    return true;
  }
}

#[cfg(test)]
pub fn put_MavlinkOut3(value: *mut SW::UdpFrame_Impl) -> bool
{
  unsafe {
    *OUT_MavlinkOut3.lock().unwrap() = Some(*value);
    return true;
  }
}
