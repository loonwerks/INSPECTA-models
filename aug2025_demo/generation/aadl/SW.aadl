package SW     
public

	with Data_Model;
	with Base_Types;
	with CASE_Scheduling;

	with HAMR;
	data u16Array
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_16));
			Data_Model::Dimension => (1);
			Memory_Properties::Data_Size => 2 Bytes;
      HAMR::Array_Size_Kind => Fixed;
	end u16Array;

	data RawEthernetMessage
		properties
			Data_Model::Data_Representation => Array;
			Data_Model::Base_Type => (classifier (Base_Types::Unsigned_8));
			Data_Model::Dimension => (1600);
			Memory_Properties::Data_Size => 1600 Bytes;
			HAMR::Array_Size_Kind => Fixed;
	end RawEthernetMessage;

	-- data implementation RawEthernetMessage
	-- end RawEthernetMessage;
	data SizedEthernetMessage
		properties
			Data_Model::Data_Representation => Struct;
	end SizedEthernetMessage;

	data implementation SizedEthernetMessage.Impl
		subcomponents
			message: data RawEthernetMessage;
			sz: data Base_types::Unsigned_16;
	end SizedEthernetMessage.Impl;

	thread LowLevelEthernetDriver
		features
			-- Ethernet Frames: Raw Ethernet frames received from the physical network interface. 	  
			EthernetFramesRx0: out event data port RawEthernetMessage;
			EthernetFramesRx1: out event data port RawEthernetMessage;
			EthernetFramesRx2: out event data port RawEthernetMessage;
			EthernetFramesRx3: out event data port RawEthernetMessage;
			EthernetFramesTx0: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx1: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx2: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx3: in event data port SizedEthernetMessage.Impl;
			
--		annex agree {**
--			assume hlr_07_tx0_can_send_valid_arp "hlr_07_tx0_can_send_valid_arp":
--				  (event(EthernetFramesTx0) and valid_arp(EthernetFramesTx0.message)) => valid_output_arp_size(EthernetFramesTx0);
--		**};
			
	end LowLevelEthernetDriver;

	thread implementation LowLevelEthernetDriver.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			HAMR::Microkit_Language => Rust;
	end LowLevelEthernetDriver.Impl;

	process LowLevelEthernetDriver_seL4
		features
			-- Ethernet Frames: Raw Ethernet frames received from the physical network interface.
			EthernetFramesRx0: out event data port RawEthernetMessage;
			EthernetFramesRx1: out event data port RawEthernetMessage;
			EthernetFramesRx2: out event data port RawEthernetMessage;
			EthernetFramesRx3: out event data port RawEthernetMessage;
			EthernetFramesTx0: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx1: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx2: in event data port SizedEthernetMessage.Impl;
			EthernetFramesTx3: in event data port SizedEthernetMessage.Impl;
	end LowLevelEthernetDriver_seL4;

	process implementation LowLevelEthernetDriver_seL4.Impl
		subcomponents
			LowLevelEthernetDriver: thread LowLevelEthernetDriver.Impl;
		connections
			c1: port EthernetFramesTx0 -> LowLevelEthernetDriver.EthernetFramesTx0;
			c2: port EthernetFramesTx1 -> LowLevelEthernetDriver.EthernetFramesTx1;
			c3: port EthernetFramesTx2 -> LowLevelEthernetDriver.EthernetFramesTx2;
			c4: port EthernetFramesTx3 -> LowLevelEthernetDriver.EthernetFramesTx3;
			c5: port LowLevelEthernetDriver.EthernetFramesRx0 -> EthernetFramesRx0;
			c6: port LowLevelEthernetDriver.EthernetFramesRx1 -> EthernetFramesRx1;
			c7: port LowLevelEthernetDriver.EthernetFramesRx2 -> EthernetFramesRx2;
			c8: port LowLevelEthernetDriver.EthernetFramesRx3 -> EthernetFramesRx3;
		properties
			CASE_Scheduling::Domain => 2;
			HAMR::Microkit_Language => Rust;
--		annex agree {**
--			lift contract;
--		**};
	end LowLevelEthernetDriver_seL4.Impl;

	thread RxFirewall
		features
			EthernetFramesRxIn0: in event data port RawEthernetMessage;
			EthernetFramesRxIn1: in event data port RawEthernetMessage;
			EthernetFramesRxIn2: in event data port RawEthernetMessage;
			EthernetFramesRxIn3: in event data port RawEthernetMessage;
			EthernetFramesRxOut0: out event data port RawEthernetMessage;
			EthernetFramesRxOut1: out event data port RawEthernetMessage;
			EthernetFramesRxOut2: out event data port RawEthernetMessage;
			EthernetFramesRxOut3: out event data port RawEthernetMessage;
			
		annex agree {**
			guarantee hlr_05_rx0_can_send_arp "hlr_05_rx0_can_send_arp" :
				  ((event(EthernetFramesRxIn0) and valid_arp(EthernetFramesRxIn0)) => 
			      (event(EthernetFramesRxOut0) and (EthernetFramesRxIn0 = EthernetFramesRxOut0)));
			guarantee hlr_06_rx0_can_send_ipv4_tcp "hlr_06_rx0_can_send_ipv4_tcp" :
			      ((event(EthernetFramesRxIn0) and valid_ipv4_tcp_port(EthernetFramesRxIn0)) => 
			      (event(EthernetFramesRxOut0) and (EthernetFramesRxIn0 = EthernetFramesRxOut0)));
			guarantee hlr_13_rx0_can_send_ipv4_udp "hlr_13_rx0_can_send_ipv4_udp" :
				  ((event(EthernetFramesRxIn0) and valid_ipv4_udp_port(EthernetFramesRxIn0)) => 
			      (event(EthernetFramesRxOut0) and (EthernetFramesRxIn0 = EthernetFramesRxOut0)));
			guarantee hlr_15_rx0_disallow "hlr_15_rx0_disallow" :
			     (event(EthernetFramesRxIn0) and not(allow_outbound_frame(EthernetFramesRxIn0))) => 
			       (not event(EthernetFramesRxOut0));
			guarantee hlr_17_rx0_no_input "hlr_17_rx0_no_input" :
				  (not event(EthernetFramesRxIn0)) => not(event(EthernetFramesRxOut0));
--			guarantee hlr_05_rx1_can_send_arp "hlr_05_rx1_can_send_arp" :((event(EthernetFramesRxIn1) and valid_arp(EthernetFramesRxIn1)) => 
--			      (event(EthernetFramesRxOut1) and (EthernetFramesRxIn1 = EthernetFramesRxOut1)));
--			guarantee hlr_06_rx1_can_send_ipv4_tcp "hlr_06_rx1_can_send_ipv4_tcp" :
--				  ((event(EthernetFramesRxIn1) and valid_ipv4_tcp_port(EthernetFramesRxIn1)) => 
--			      (event(EthernetFramesRxOut1) and (EthernetFramesRxIn1 = EthernetFramesRxOut1)));
--			guarantee hlr_13_rx1_can_send_ipv4_udp "hlr_13_rx1_can_send_ipv4_udp" :
--				  ((event(EthernetFramesRxIn1) and valid_ipv4_udp_port(EthernetFramesRxIn1)) => 
--			      (event(EthernetFramesRxOut1) and (EthernetFramesRxIn1 = EthernetFramesRxOut1)));
--			guarantee hlr_15_rx1_disallow "hlr_15_rx1_disallow" :
--			     (event(EthernetFramesRxIn1) and not allow_outbound_frame(EthernetFramesRxIn1)) => 
--			       (not event(EthernetFramesRxOut1));
--			guarantee hlr_17_rx1_no_input "hlr_17_rx1_no_input" :
--				  (not event(EthernetFramesRxIn1) => not(event(EthernetFramesRxOut1)));
--			guarantee hlr_05_rx2_can_send_arp "hlr_05_rx2_can_send_arp" :
--				  ((event(EthernetFramesRxIn2) and valid_arp(EthernetFramesRxIn2)) => 
--			      (event(EthernetFramesRxOut2) and (EthernetFramesRxIn2 = EthernetFramesRxOut2)));
--			guarantee hlr_06_rx2_can_send_ipv4_tcp "hlr_06_rx2_can_send_ipv4_tcp" :
--				  ((event(EthernetFramesRxIn2) and valid_ipv4_tcp_port(EthernetFramesRxIn2)) => 
--			      (event(EthernetFramesRxOut2) and (EthernetFramesRxIn2 = EthernetFramesRxOut2)));
--			guarantee hlr_13_rx2_can_send_ipv4_udp "hlr_13_rx2_can_send_ipv4_udp" :
--				  ((event(EthernetFramesRxIn2) and valid_ipv4_udp_port(EthernetFramesRxIn2)) => 
--			      (event(EthernetFramesRxOut2) and (EthernetFramesRxIn2 = EthernetFramesRxOut2)));
--			guarantee hlr_15_rx2_disallow "hlr_15_rx2_disallow" :
--			      (event(EthernetFramesRxIn2) and not allow_outbound_frame(EthernetFramesRxIn2)) => 
--			       (not event(EthernetFramesRxOut2));
--			guarantee hlr_17_rx2_no_input "hlr_17_rx2_no_input" :
--				  (not event(EthernetFramesRxIn2) => not event(EthernetFramesRxOut2));
--			guarantee hlr_05_rx3_can_send_arp "hlr_05_rx3_can_send_arp" :
--				  ((event(EthernetFramesRxIn3) and valid_arp(EthernetFramesRxIn3)) => 
--			      (event(EthernetFramesRxOut3) and (EthernetFramesRxIn3 = EthernetFramesRxOut3)));
--			guarantee hlr_06_rx3_can_send_ipv4_tcp "hlr_06_rx3_can_send_ipv4_tcp" :
--				  ((event(EthernetFramesRxIn3) and valid_ipv4_tcp_port(EthernetFramesRxIn3)) => 
--			      (event(EthernetFramesRxOut3) and (EthernetFramesRxIn3 = EthernetFramesRxOut3)));
--			guarantee hlr_13_rx3_can_send_ipv4_udp "hlr_13_rx3_can_send_ipv4_udp" :
--				  ((event(EthernetFramesRxIn3) and valid_ipv4_udp_port(EthernetFramesRxIn3)) => 
--			      (event(EthernetFramesRxOut3) and (EthernetFramesRxIn3 = EthernetFramesRxOut3)));
--			guarantee hlr_15_rx3_disallow "hlr_15_rx3_disallow" :
--			      (event(EthernetFramesRxIn3) and not allow_outbound_frame(EthernetFramesRxIn3)) => 
--			       (not event(EthernetFramesRxOut3));
--			guarantee hlr_17_rx3_no_input "hlr_17_rx3_no_input" :
--				  (not event(EthernetFramesRxIn3) => not event(EthernetFramesRxOut3));
		**};
			
	end RxFirewall;

	thread implementation RxFirewall.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			HAMR::Microkit_Language => Rust;
		annex GUMBO {**functions
          -- TODO: add const/vals to gumbo
          --def MIN_ETH2_FRAME_LENGTH(): Base_Types::Integer := 64;
          --def MAX_ETH2_FRAME_LENGTH(): Base_Types::Integer := 1518;
          
          
          -- TODO: TCP_ALLOWED_PORTS and UDP_ALLOWED_PORTS should probably be sig/ui functions.
          --       HAMR would just emit the signature and and empty body that the developer must
          --       subsequently fill in
          def TCP_ALLOWED_PORTS(): u16Array := u16Array(u16"5760");
          
          def UDP_ALLOWED_PORTS(): u16Array := u16Array(u16"68");
          
          
          def two_bytes_to_u16(byte0: Base_Types::Unsigned_8, byte1: Base_Types::Unsigned_8): Base_Types::Unsigned_16 :=
            byte0.toU16 * u16"256" + byte1.toU16; 
          
          def frame_is_wellformed_eth2(frame: RawEthernetMessage): Base_Types::Boolean :=
            valid_frame_ethertype(frame) && valid_frame_dst_addr(frame);

          def valid_frame_ethertype(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_has_ipv4(frame) || frame_has_arp(frame) || frame_has_ipv6(frame);
            
          def valid_frame_dst_addr(frame: RawEthernetMessage): Base_Types::Boolean :=
              !((frame(0) == u8"0") &&
				(frame(1) == u8"0") &&
				(frame(2) == u8"0") &&
				(frame(3) == u8"0") &&
				(frame(4) == u8"0") &&
				(frame(5) == u8"0"));

          def frame_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
              frame(12) == u8"8" && frame(13) == u8"0";
          
          def frame_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
              frame(12) == u8"134" && frame(13) == u8"221";
                    
          def frame_has_arp(frame: RawEthernetMessage): Base_Types::Boolean := 
              frame(12) == u8"8" && frame(13) == u8"6";

          def arp_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
              frame(16) == u8"8" && frame(17) == u8"0";
          
          def arp_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
              frame(16) == u8"134" && frame(17) == u8"221";

	      def valid_arp_ptype(frame: RawEthernetMessage): Base_Types::Boolean :=
		      arp_has_ipv4(frame) || arp_has_ipv6(frame);

	      def valid_arp_op(frame: RawEthernetMessage): Base_Types::Boolean :=
		      frame(20) == u8"0" && (frame(21) == u8"1" || frame(21) == u8"2");

	      def valid_arp_htype(frame: RawEthernetMessage): Base_Types::Boolean :=
		      frame(14) == u8"0" && frame(15) == u8"1";

	      def wellformed_arp_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
		      valid_arp_op(frame) && valid_arp_htype(frame) && valid_arp_ptype(frame);

	      def valid_ipv4_length(frame: RawEthernetMessage): Base_Types::Boolean :=
		      two_bytes_to_u16(frame(16),frame(17)) <= u16"9000";

	      def valid_ipv4_protocol(frame: RawEthernetMessage): Base_Types::Boolean :=
		      (frame(23) == u8"0")  ||
			  (frame(23) == u8"1")  ||
			  (frame(23) == u8"2")  ||
			  (frame(23) == u8"6")  ||
			  (frame(23) == u8"17") ||
			  (frame(23) == u8"43") ||
			  (frame(23) == u8"44") ||
			  (frame(23) == u8"58") ||
			  (frame(23) == u8"59") ||
			  (frame(23) == u8"60");

	      def wellformed_ipv4_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
		      valid_ipv4_protocol(frame) && valid_ipv4_length(frame);

	      def ipv4_is_tcp(frame: RawEthernetMessage): Base_Types::Boolean :=
			  frame(23) == u8"6";

	      def ipv4_is_udp(frame: RawEthernetMessage): Base_Types::Boolean :=
			  frame(23) == u8"17";
			
	      def tcp_is_valid_port(frame: RawEthernetMessage): Base_Types::Boolean :=
			  two_bytes_to_u16(frame(36),frame(37)) == TCP_ALLOWED_PORTS()(0);

	      def udp_is_valid_port(frame: RawEthernetMessage): Base_Types::Boolean :=
			  two_bytes_to_u16(frame(36),frame(37)) == UDP_ALLOWED_PORTS()(0);

          def frame_has_ipv4_tcp_on_allowed_port_quant(frame: RawEthernetMessage): Base_Types::Boolean :=
            Exists(0 until TCP_ALLOWED_PORTS().size)(i =>
                TCP_ALLOWED_PORTS()(i) == two_bytes_to_u16(frame(36), frame(37)));

          def frame_has_ipv4_udp_on_allowed_port_quant(frame: RawEthernetMessage): Base_Types::Boolean :=
            Exists(0 until UDP_ALLOWED_PORTS().size)(i =>
                UDP_ALLOWED_PORTS()(i) == two_bytes_to_u16(frame(36), frame(37)));
          
          --------------------------------------------------------------------------
          -- RX Firewall
          --------------------------------------------------------------------------

          def valid_arp(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) && frame_has_arp(frame) && wellformed_arp_frame(frame);
            
          def valid_ipv4_tcp(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) && wellformed_ipv4_frame(frame) && ipv4_is_tcp(frame);
            
          def valid_ipv4_udp(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) && wellformed_ipv4_frame(frame) && ipv4_is_udp(frame);

          def valid_ipv4_tcp_port(frame: RawEthernetMessage): Base_Types::Boolean :=
            valid_ipv4_tcp(frame) && frame_has_ipv4_tcp_on_allowed_port_quant(frame);

          def valid_ipv4_udp_port(frame: RawEthernetMessage): Base_Types::Boolean :=
            valid_ipv4_udp(frame) && frame_has_ipv4_udp_on_allowed_port_quant(frame);
            
          def allow_outbound_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
            valid_arp(frame) ||
            valid_ipv4_tcp_port(frame) ||
            valid_ipv4_udp_port(frame);
         
            
      compute

        guarantee hlr_05_rx0_can_send_arp:
          ((HasEvent(EthernetFramesRxIn0) && valid_arp(EthernetFramesRxIn0)) ->: 
            (HasEvent(EthernetFramesRxOut0) && (EthernetFramesRxIn0 == EthernetFramesRxOut0)));
        guarantee hlr_06_rx0_can_send_ipv4_tcp:
          ((HasEvent(EthernetFramesRxIn0) && valid_ipv4_tcp_port(EthernetFramesRxIn0)) ->: 
            (HasEvent(EthernetFramesRxOut0) && (EthernetFramesRxIn0 == EthernetFramesRxOut0)));
        guarantee hlr_13_rx0_can_send_ipv4_udp:
          ((HasEvent(EthernetFramesRxIn0) && valid_ipv4_udp_port(EthernetFramesRxIn0)) ->: 
            (HasEvent(EthernetFramesRxOut0) && (EthernetFramesRxIn0 == EthernetFramesRxOut0)));
        guarantee hlr_15_rx0_disallow:
	       (HasEvent(EthernetFramesRxIn0) && !allow_outbound_frame(EthernetFramesRxIn0)) ->: 
	         (NoSend(EthernetFramesRxOut0));
        guarantee hlr_17_rx0_no_input:
           (!HasEvent(EthernetFramesRxIn0) ->: NoSend(EthernetFramesRxOut0));

        guarantee hlr_05_rx1_can_send_arp:
          ((HasEvent(EthernetFramesRxIn1) && valid_arp(EthernetFramesRxIn1)) ->: 
            (HasEvent(EthernetFramesRxOut1) && (EthernetFramesRxIn1 == EthernetFramesRxOut1)));
        guarantee hlr_06_rx1_can_send_ipv4_tcp:
          ((HasEvent(EthernetFramesRxIn1) && valid_ipv4_tcp_port(EthernetFramesRxIn1)) ->: 
            (HasEvent(EthernetFramesRxOut1) && (EthernetFramesRxIn1 == EthernetFramesRxOut1)));
        guarantee hlr_13_rx1_can_send_ipv4_udp:
          ((HasEvent(EthernetFramesRxIn1) && valid_ipv4_udp_port(EthernetFramesRxIn1)) ->: 
            (HasEvent(EthernetFramesRxOut1) && (EthernetFramesRxIn1 == EthernetFramesRxOut1)));
        guarantee hlr_15_rx1_disallow:
	       (HasEvent(EthernetFramesRxIn1) && !allow_outbound_frame(EthernetFramesRxIn1)) ->: 
	         (NoSend(EthernetFramesRxOut1));
        guarantee hlr_17_rx1_no_input:
           (!HasEvent(EthernetFramesRxIn1) ->: NoSend(EthernetFramesRxOut1));

        guarantee hlr_05_rx2_can_send_arp:
          ((HasEvent(EthernetFramesRxIn2) && valid_arp(EthernetFramesRxIn2)) ->: 
            (HasEvent(EthernetFramesRxOut2) && (EthernetFramesRxIn2 == EthernetFramesRxOut2)));
        guarantee hlr_06_rx2_can_send_ipv4_tcp:
          ((HasEvent(EthernetFramesRxIn2) && valid_ipv4_tcp_port(EthernetFramesRxIn2)) ->: 
            (HasEvent(EthernetFramesRxOut2) && (EthernetFramesRxIn2 == EthernetFramesRxOut2)));
        guarantee hlr_13_rx2_can_send_ipv4_udp:
          ((HasEvent(EthernetFramesRxIn2) && valid_ipv4_udp_port(EthernetFramesRxIn2)) ->: 
            (HasEvent(EthernetFramesRxOut2) && (EthernetFramesRxIn2 == EthernetFramesRxOut2)));
        guarantee hlr_15_rx2_disallow:
	       (HasEvent(EthernetFramesRxIn2) && !allow_outbound_frame(EthernetFramesRxIn2)) ->: 
	         (NoSend(EthernetFramesRxOut2));
        guarantee hlr_17_rx2_no_input:
           (!HasEvent(EthernetFramesRxIn2) ->: NoSend(EthernetFramesRxOut2));

        guarantee hlr_05_rx3_can_send_arp:
          ((HasEvent(EthernetFramesRxIn3) && valid_arp(EthernetFramesRxIn3)) ->: 
            (HasEvent(EthernetFramesRxOut3) && (EthernetFramesRxIn3 == EthernetFramesRxOut3)));
        guarantee hlr_06_rx3_can_send_ipv4_tcp:
          ((HasEvent(EthernetFramesRxIn3) && valid_ipv4_tcp_port(EthernetFramesRxIn3)) ->: 
            (HasEvent(EthernetFramesRxOut3) && (EthernetFramesRxIn3 == EthernetFramesRxOut3)));
        guarantee hlr_13_rx3_can_send_ipv4_udp:
          ((HasEvent(EthernetFramesRxIn3) && valid_ipv4_udp_port(EthernetFramesRxIn3)) ->: 
            (HasEvent(EthernetFramesRxOut3) && (EthernetFramesRxIn3 == EthernetFramesRxOut3)));
        guarantee hlr_15_rx3_disallow:
	       (HasEvent(EthernetFramesRxIn3) && !allow_outbound_frame(EthernetFramesRxIn3)) ->: 
	         (NoSend(EthernetFramesRxOut3));
        guarantee hlr_17_rx3_no_input:
           (!HasEvent(EthernetFramesRxIn3) ->: NoSend(EthernetFramesRxOut3));
           
    **};

	end RxFirewall.Impl;

	process RxFirewall_seL4
		features
			EthernetFramesRxIn0: in event data port RawEthernetMessage;
			EthernetFramesRxIn1: in event data port RawEthernetMessage;
			EthernetFramesRxIn2: in event data port RawEthernetMessage;
			EthernetFramesRxIn3: in event data port RawEthernetMessage;
			EthernetFramesRxOut0: out event data port RawEthernetMessage;
			EthernetFramesRxOut1: out event data port RawEthernetMessage;
			EthernetFramesRxOut2: out event data port RawEthernetMessage;
			EthernetFramesRxOut3: out event data port RawEthernetMessage;

	end RxFirewall_seL4;

	process implementation RxFirewall_seL4.Impl
		subcomponents
			RxFirewall: thread RxFirewall.Impl;
		connections
			c1: port EthernetFramesRxIn0 -> RxFirewall.EthernetFramesRxIn0;
			c2: port EthernetFramesRxIn1 -> RxFirewall.EthernetFramesRxIn1;
			c3: port EthernetFramesRxIn2 -> RxFirewall.EthernetFramesRxIn2;
			c4: port EthernetFramesRxIn3 -> RxFirewall.EthernetFramesRxIn3;
			c5: port RxFirewall.EthernetFramesRxOut0 -> EthernetFramesRxOut0;
			c6: port RxFirewall.EthernetFramesRxOut1 -> EthernetFramesRxOut1;
			c7: port RxFirewall.EthernetFramesRxOut2 -> EthernetFramesRxOut2;
			c8: port RxFirewall.EthernetFramesRxOut3 -> EthernetFramesRxOut3;
		properties
			CASE_Scheduling::Domain => 3;
			HAMR::Microkit_Language => Rust;
			
		annex agree {**
			lift contract;
		**};
	end RxFirewall_seL4.Impl;

	thread TxFirewall
		features
			EthernetFramesTxIn0: in event data port RawEthernetMessage;
			EthernetFramesTxIn1: in event data port RawEthernetMessage;
			EthernetFramesTxIn2: in event data port RawEthernetMessage;
			EthernetFramesTxIn3: in event data port RawEthernetMessage;
			EthernetFramesTxOut0: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut1: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut2: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut3: out event data port SizedEthernetMessage.Impl;
--		annex agree {**
--			guarantee hlr_07_tx0_can_send_valid_arp "hlr_07_tx0_can_send_valid_arp" :
--          ((event(EthernetFramesTxIn0) and valid_arp(EthernetFramesTxIn0)) => 
--            (event(EthernetFramesTxOut0) and (EthernetFramesTxOut0.message = EthernetFramesTxIn0) and valid_output_arp_size(EthernetFramesTxOut0) ));
--        guarantee hlr_12_tx0_can_send_valid_ipv4 "hlr_12_tx0_can_send_valid_ipv4" :
--          ((event(EthernetFramesTxIn0) and valid_ipv4(EthernetFramesTxIn0)) => 
--            (event(EthernetFramesTxOut0) and (EthernetFramesTxIn0 = EthernetFramesTxOut0.message) and valid_output_ipv4_size(EthernetFramesTxIn0, EthernetFramesTxOut0) ));
--        guarantee hlr_14_tx0_disallow "hlr_14_tx0_disallow" :
--	       (event(EthernetFramesTxIn0) and not allow_outbound_frame(EthernetFramesTxIn0)) => 
--	         not event(EthernetFramesTxOut0);
--        guarantee hlr_16_tx0_no_input "hlr_16_tx0_no_input" :
--           not event(EthernetFramesTxIn0) => not event(EthernetFramesTxOut0);
--		**};
	end TxFirewall;

	thread implementation TxFirewall.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			HAMR::Microkit_Language => Rust;
			
		annex GUMBO {**functions
          -- TODO: add const/vals to gumbo
          --def MIN_ETH2_FRAME_LENGTH(): Base_Types::Integer := 64;
          --def MAX_ETH2_FRAME_LENGTH(): Base_Types::Integer := 1518;
          
          
          -- TODO: TCP_ALLOWED_PORTS and UDP_ALLOWED_PORTS should probably be sig/ui functions.
          --       HAMR would just emit the signature and and empty body that the developer must
          --       subsequently fill in
          
          def two_bytes_to_u16(byte0: Base_Types::Unsigned_8, byte1: Base_Types::Unsigned_8): Base_Types::Unsigned_16 :=
            byte0.toU16 * u16"256" + byte1.toU16; 
          
          def frame_is_wellformed_eth2(frame: RawEthernetMessage): Base_Types::Boolean :=
            valid_frame_ethertype(frame) && valid_frame_dst_addr(frame);

          def valid_frame_ethertype(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_has_ipv4(frame) || frame_has_arp(frame) || frame_has_ipv6(frame);
            
          def valid_frame_dst_addr(frame: RawEthernetMessage): Base_Types::Boolean :=
              !((frame(0) == u8"0") &&
				(frame(1) == u8"0") &&
				(frame(2) == u8"0") &&
				(frame(3) == u8"0") &&
				(frame(4) == u8"0") &&
				(frame(5) == u8"0"));

          def frame_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
              frame(12) == u8"8" && frame(13) == u8"0";
          
          def frame_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
              frame(12) == u8"134" && frame(13) == u8"221";
                    
          def frame_has_arp(frame: RawEthernetMessage): Base_Types::Boolean := 
              frame(12) == u8"8" && frame(13) == u8"6";

          def arp_has_ipv4(frame: RawEthernetMessage): Base_Types::Boolean := 
              frame(16) == u8"8" && frame(17) == u8"0";
          
          def arp_has_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
              frame(16) == u8"134" && frame(17) == u8"221";

	      def valid_arp_ptype(frame: RawEthernetMessage): Base_Types::Boolean :=
		      arp_has_ipv4(frame) || arp_has_ipv6(frame);

	      def valid_arp_op(frame: RawEthernetMessage): Base_Types::Boolean :=
		      frame(20) == u8"0" && (frame(21) == u8"1" || frame(21) == u8"2");

	      def valid_arp_htype(frame: RawEthernetMessage): Base_Types::Boolean :=
		      frame(14) == u8"0" && frame(15) == u8"1";

	      def wellformed_arp_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
		      valid_arp_op(frame) && valid_arp_htype(frame) && valid_arp_ptype(frame);

	      def ipv4_length(frame: RawEthernetMessage): Base_Types::Unsigned_16 :=
		      two_bytes_to_u16(frame(16),frame(17));

	      def valid_ipv4_length(frame: RawEthernetMessage): Base_Types::Boolean :=
		      ipv4_length(frame) <= u16"9000";

	      def valid_ipv4_protocol(frame: RawEthernetMessage): Base_Types::Boolean :=
		      (frame(23) == u8"0")  ||
			  (frame(23) == u8"1")  ||
			  (frame(23) == u8"2")  ||
			  (frame(23) == u8"6")  ||
			  (frame(23) == u8"17") ||
			  (frame(23) == u8"43") ||
			  (frame(23) == u8"44") ||
			  (frame(23) == u8"58") ||
			  (frame(23) == u8"59") ||
			  (frame(23) == u8"60");

	      def wellformed_ipv4_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
		      valid_ipv4_protocol(frame) && valid_ipv4_length(frame);
            
          --------------------------------------------------------------------------
          -- TX Firewall
          --------------------------------------------------------------------------
          
		  -- TODO: Do I need this?
          def valid_ipv6(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) && frame_has_ipv6(frame);
            
          def valid_arp(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) && frame_has_arp(frame) && wellformed_arp_frame(frame);
            
          def valid_ipv4(frame: RawEthernetMessage): Base_Types::Boolean :=
            frame_is_wellformed_eth2(frame) && frame_has_ipv4(frame) && wellformed_ipv4_frame(frame);

          def valid_output_arp_size(output: SizedEthernetMessage.Impl): Base_Types::Boolean :=
            output.sz == u16"64";

          def valid_output_ipv4_size(input: RawEthernetMessage, output: SizedEthernetMessage.Impl): Base_Types::Boolean :=
            output.sz == (ipv4_length(input)+u16"14");

          def allow_outbound_frame(frame: RawEthernetMessage): Base_Types::Boolean :=
            valid_arp(frame) ||
            valid_ipv4(frame); 

          -- def tx_disallow(input: in event data port RawEthernetMessage, output: out event data port SizedEthernetMessage.Impl): Base_Types::Boolean :=
	      --  (HasEvent(input) && !allow_outbound_frame(input)) ->: 
	      --    (NoSend(output));
            
      compute

        guarantee hlr_07_tx0_can_send_valid_arp:
          ((HasEvent(EthernetFramesTxIn0) && valid_arp(EthernetFramesTxIn0)) ->: 
            (HasEvent(EthernetFramesTxOut0) && (EthernetFramesTxIn0 == EthernetFramesTxOut0.message) && valid_output_arp_size(EthernetFramesTxOut0) ));
        guarantee hlr_12_tx0_can_send_valid_ipv4:
          ((HasEvent(EthernetFramesTxIn0) && valid_ipv4(EthernetFramesTxIn0)) ->: 
            (HasEvent(EthernetFramesTxOut0) && (EthernetFramesTxIn0 == EthernetFramesTxOut0.message) && valid_output_ipv4_size(EthernetFramesTxIn0, EthernetFramesTxOut0) ));
        guarantee hlr_14_tx0_disallow:
	       (HasEvent(EthernetFramesTxIn0) && !allow_outbound_frame(EthernetFramesTxIn0)) ->: 
	         (NoSend(EthernetFramesTxOut0));
        guarantee hlr_16_tx0_no_input:
           (!HasEvent(EthernetFramesTxIn0) ->: NoSend(EthernetFramesTxOut0));

        guarantee hlr_07_tx1_can_send_valid_arp:
          ((HasEvent(EthernetFramesTxIn1) && valid_arp(EthernetFramesTxIn1)) ->: 
            (HasEvent(EthernetFramesTxOut1) && (EthernetFramesTxIn1 == EthernetFramesTxOut1.message) && valid_output_arp_size(EthernetFramesTxOut1) ));
        guarantee hlr_12_tx1_can_send_valid_ipv4:
          ((HasEvent(EthernetFramesTxIn1) && valid_ipv4(EthernetFramesTxIn1)) ->: 
            (HasEvent(EthernetFramesTxOut1) && (EthernetFramesTxIn1 == EthernetFramesTxOut1.message) && valid_output_ipv4_size(EthernetFramesTxIn1, EthernetFramesTxOut1) ));
        guarantee hlr_14_tx1_disallow:
	       (HasEvent(EthernetFramesTxIn1) && !allow_outbound_frame(EthernetFramesTxIn1)) ->: 
	         (NoSend(EthernetFramesTxOut1));
        guarantee hlr_16_tx1_no_input:
           (!HasEvent(EthernetFramesTxIn1) ->: NoSend(EthernetFramesTxOut1));

        guarantee hlr_07_tx2_can_send_valid_arp:
          ((HasEvent(EthernetFramesTxIn2) && valid_arp(EthernetFramesTxIn2)) ->: 
            (HasEvent(EthernetFramesTxOut2) && (EthernetFramesTxIn2 == EthernetFramesTxOut2.message) && valid_output_arp_size(EthernetFramesTxOut2) ));
        guarantee hlr_12_tx2_can_send_valid_ipv4:
          ((HasEvent(EthernetFramesTxIn2) && valid_ipv4(EthernetFramesTxIn2)) ->: 
            (HasEvent(EthernetFramesTxOut2) && (EthernetFramesTxIn2 == EthernetFramesTxOut2.message) && valid_output_ipv4_size(EthernetFramesTxIn2, EthernetFramesTxOut2) ));
        guarantee hlr_14_tx2_disallow:
	       (HasEvent(EthernetFramesTxIn2) && !allow_outbound_frame(EthernetFramesTxIn2)) ->: 
	         (NoSend(EthernetFramesTxOut2));
        guarantee hlr_16_tx2_no_input:
           (!HasEvent(EthernetFramesTxIn2) ->: NoSend(EthernetFramesTxOut2));

        guarantee hlr_07_tx3_can_send_valid_arp:
          ((HasEvent(EthernetFramesTxIn3) && valid_arp(EthernetFramesTxIn3)) ->: 
            (HasEvent(EthernetFramesTxOut3) && (EthernetFramesTxIn3 == EthernetFramesTxOut3.message) && valid_output_arp_size(EthernetFramesTxOut3) ));
        guarantee hlr_12_tx3_can_send_valid_ipv4:
          ((HasEvent(EthernetFramesTxIn3) && valid_ipv4(EthernetFramesTxIn3)) ->: 
            (HasEvent(EthernetFramesTxOut3) && (EthernetFramesTxIn3 == EthernetFramesTxOut3.message) && valid_output_ipv4_size(EthernetFramesTxIn3, EthernetFramesTxOut3) ));
        guarantee hlr_14_tx3_disallow:
	       (HasEvent(EthernetFramesTxIn3) && !allow_outbound_frame(EthernetFramesTxIn3)) ->: 
	         (NoSend(EthernetFramesTxOut3));
        guarantee hlr_16_tx3_no_input:
           (!HasEvent(EthernetFramesTxIn3) ->: NoSend(EthernetFramesTxOut3));

    **};

	end TxFirewall.Impl;

	process TxFirewall_seL4
		features
			EthernetFramesTxIn0: in event data port RawEthernetMessage;
			EthernetFramesTxIn1: in event data port RawEthernetMessage;
			EthernetFramesTxIn2: in event data port RawEthernetMessage;
			EthernetFramesTxIn3: in event data port RawEthernetMessage;
			EthernetFramesTxOut0: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut1: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut2: out event data port SizedEthernetMessage.Impl;
			EthernetFramesTxOut3: out event data port SizedEthernetMessage.Impl;
	end TxFirewall_seL4;

	process implementation TxFirewall_seL4.Impl
		subcomponents
			TxFirewall: thread TxFirewall.Impl;
		connections
			c1: port EthernetFramesTxIn0 -> TxFirewall.EthernetFramesTxIn0;
			c2: port EthernetFramesTxIn1 -> TxFirewall.EthernetFramesTxIn1;
			c3: port EthernetFramesTxIn2 -> TxFirewall.EthernetFramesTxIn2;
			c4: port EthernetFramesTxIn3 -> TxFirewall.EthernetFramesTxIn3;
			c5: port TxFirewall.EthernetFramesTxOut0 -> EthernetFramesTxOut0;
			c6: port TxFirewall.EthernetFramesTxOut1 -> EthernetFramesTxOut1;
			c7: port TxFirewall.EthernetFramesTxOut2 -> EthernetFramesTxOut2;
			c8: port TxFirewall.EthernetFramesTxOut3 -> EthernetFramesTxOut3;
		properties
			CASE_Scheduling::Domain => 5;
			HAMR::Microkit_Language => Rust; 
--		annex agree {**
--			lift contract;
--		**};
	end TxFirewall_seL4.Impl;

	thread ArduPilot 
		features
			EthernetFramesRx0: in event data port RawEthernetMessage;
			EthernetFramesRx1: in event data port RawEthernetMessage;
			EthernetFramesRx2: in event data port RawEthernetMessage;
			EthernetFramesRx3: in event data port RawEthernetMessage;
			EthernetFramesTx0: out event data port RawEthernetMessage;
			EthernetFramesTx1: out event data port RawEthernetMessage;
			EthernetFramesTx2: out event data port RawEthernetMessage;
			EthernetFramesTx3: out event data port RawEthernetMessage;
			
		annex agree {**
			assume hlr_05_rx0_can_send_arp "hlr_05_rx0_can_send_arp" :
				  (event(EthernetFramesRx0) and valid_ipv4_tcp(EthernetFramesRx0)) => valid_ipv4_tcp_port(EthernetFramesRx0);
--			assume hlr_05_rx1_can_send_arp "hlr_05_rx1_can_send_arp" :
--				  (event(EthernetFramesRx1) and valid_ipv4_tcp(EthernetFramesRx1)) => valid_ipv4_tcp_port(EthernetFramesRx1);
--			assume hlr_05_rx2_can_send_arp "hlr_05_rx2_can_send_arp" :
--				  (event(EthernetFramesRx2) and valid_ipv4_tcp(EthernetFramesRx2)) => valid_ipv4_tcp_port(EthernetFramesRx2);
--			assume hlr_05_rx3_can_send_arp "hlr_05_rx3_can_send_arp" :
--				  (event(EthernetFramesRx3) and valid_ipv4_tcp(EthernetFramesRx3)) => valid_ipv4_tcp_port(EthernetFramesRx3);
		**};
			
	end ArduPilot;

	thread implementation ArduPilot.Impl
		properties
			Dispatch_Protocol => Periodic;
			Period => 1000ms;
			Compute_Execution_Time => 100ms .. 100ms;
			Stack_size => 1048576 Bytes;
			Source_Text => ("src/Ardupilot.c");
			Initialize_Entrypoint_Source_Text => "init";
			Compute_Entrypoint_Source_Text => "compute";
	end ArduPilot.Impl;

	process ArduPilot_seL4
		features
			EthernetFramesRx0: in event data port RawEthernetMessage;
			EthernetFramesRx1: in event data port RawEthernetMessage;
			EthernetFramesRx2: in event data port RawEthernetMessage;
			EthernetFramesRx3: in event data port RawEthernetMessage;
			EthernetFramesTx0: out event data port RawEthernetMessage;
			EthernetFramesTx1: out event data port RawEthernetMessage;
			EthernetFramesTx2: out event data port RawEthernetMessage;
			EthernetFramesTx3: out event data port RawEthernetMessage;
	end ArduPilot_seL4;

	process implementation ArduPilot_seL4.Impl
		subcomponents
			ArduPilot: thread ArduPilot.Impl;
		connections
			c1: port EthernetFramesRx0 -> ArduPilot.EthernetFramesRx0;
			c2: port EthernetFramesRx1 -> ArduPilot.EthernetFramesRx1;
			c3: port EthernetFramesRx2 -> ArduPilot.EthernetFramesRx2;
			c4: port EthernetFramesRx3 -> ArduPilot.EthernetFramesRx3;
			c5: port ArduPilot.EthernetFramesTx0 -> EthernetFramesTx0;
			c6: port ArduPilot.EthernetFramesTx1 -> EthernetFramesTx1;
			c7: port ArduPilot.EthernetFramesTx2 -> EthernetFramesTx2;
			c8: port ArduPilot.EthernetFramesTx3 -> EthernetFramesTx3;
		properties
			CASE_Scheduling::Domain => 4;
			
		annex agree {**
			lift contract;
		**};
			
	end ArduPilot_seL4.Impl;

	system seL4
	end seL4;

	system implementation seL4.Impl
		subcomponents
			ArduPilot: process ArduPilot_seL4.Impl;
			RxFirewall: process RxFirewall_seL4.Impl;
			TxFirewall: process TxFirewall_seL4.Impl;
			LowLevelEthernetDriver: process LowLevelEthernetDriver_seL4.Impl;

		connections
			-- Incoming traffic
			c1: port LowLevelEthernetDriver.EthernetFramesRx0 -> RxFirewall.EthernetFramesRxIn0;
			c2: port LowLevelEthernetDriver.EthernetFramesRx1 -> RxFirewall.EthernetFramesRxIn1;
			c3: port LowLevelEthernetDriver.EthernetFramesRx2 -> RxFirewall.EthernetFramesRxIn2;
			c4: port LowLevelEthernetDriver.EthernetFramesRx3 -> RxFirewall.EthernetFramesRxIn3;
			c5: port RxFirewall.EthernetFramesRxOut0 -> ArduPilot.EthernetFramesRx0;
			c6: port RxFirewall.EthernetFramesRxOut1 -> ArduPilot.EthernetFramesRx1;
			c7: port RxFirewall.EthernetFramesRxOut2 -> ArduPilot.EthernetFramesRx2;
			c8: port RxFirewall.EthernetFramesRxOut3 -> ArduPilot.EthernetFramesRx3;
			-- Outgoing traffic
			c9: port ArduPilot.EthernetFramesTx0 -> TxFirewall.EthernetFramesTxIn0;
			c10: port ArduPilot.EthernetFramesTx1 -> TxFirewall.EthernetFramesTxIn1;
			c11: port ArduPilot.EthernetFramesTx2 -> TxFirewall.EthernetFramesTxIn2;
			c12: port ArduPilot.EthernetFramesTx3 -> TxFirewall.EthernetFramesTxIn3;
			c13: port TxFirewall.EthernetFramesTxOut0 -> LowLevelEthernetDriver.EthernetFramesTx0;
			c14: port TxFirewall.EthernetFramesTxOut1 -> LowLevelEthernetDriver.EthernetFramesTx1;
			c15: port TxFirewall.EthernetFramesTxOut2 -> LowLevelEthernetDriver.EthernetFramesTx2;
			c16: port TxFirewall.EthernetFramesTxOut3 -> LowLevelEthernetDriver.EthernetFramesTx3;
	end seL4.Impl;
	
	annex agree {**
					
			const TCP_ALLOWED_PORTS: Base_Types::Integer[4] = [|5760, 5760, 5760, 5760|];
			const UDP_ALLOWED_PORTS: Base_Types::Integer[4] = [|68, 68, 68, 68|];
			fun is_tcp_allowed_port(port: Base_Types::Unsigned_16) : Base_Types::Boolean =
				exists p in TCP_ALLOWED_PORTS, p = port;
			fun is_udp_allowed_port(port: Base_Types::Unsigned_16) : Base_Types::Boolean =
				exists p in UDP_ALLOWED_PORTS, p = port;
			fun two_bytes_to_u16(byte0 : Base_Types::Unsigned_8, byte1 : Base_Types::Unsigned_8) : Base_Types::Unsigned_16 =
				byte0 * 256 + byte1;
			fun frame_is_wellformed_eth2(frame : RawEthernetMessage) : Base_Types::Boolean =
			    valid_frame_ethertype(frame) and valid_frame_dst_addr(frame);
			fun valid_frame_ethertype(frame : RawEthernetMessage) : Base_Types::Boolean =
			    frame_has_ipv4(frame) or frame_has_arp(frame) or frame_has_ipv6(frame);
			fun valid_frame_dst_addr(frame : RawEthernetMessage) : Base_Types::Boolean =
			      not(
					(frame[1] = 0) and
					(frame[2] = 0) and
					(frame[3] = 0) and
					(frame[4] = 0) and
					(frame[5] = 0) and
					(frame[6] = 0)
					);
			fun frame_has_ipv4(frame : RawEthernetMessage) : Base_Types::Boolean = 
			      frame[13] = 8 and frame[14] = 0;
			fun frame_has_ipv6(frame : RawEthernetMessage) : Base_Types::Boolean =
			      frame[13] = 134 and frame[14] = 221;
			fun frame_has_arp(frame : RawEthernetMessage) : Base_Types::Boolean = 
			      frame[13] = 8 and frame[14] = 6;
			fun arp_has_ipv4(frame : RawEthernetMessage) : Base_Types::Boolean = 
			      frame[17] = 8 and frame[18] = 0;
			fun arp_has_ipv6(frame : RawEthernetMessage) : Base_Types::Boolean =
			      frame[17] = 134 and frame[18] = 221;
			fun valid_arp_ptype(frame : RawEthernetMessage) : Base_Types::Boolean =
			      arp_has_ipv4(frame) or arp_has_ipv6(frame);
			fun valid_arp_op(frame : RawEthernetMessage) : Base_Types::Boolean =
			      frame[21] = 0 and (frame[22] = 1 or frame[22] = 2);
			fun valid_arp_htype(frame : RawEthernetMessage) : Base_Types::Boolean =
			      frame[15] = 0 and frame[16] = 1;
			fun wellformed_arp_frame(frame : RawEthernetMessage) : Base_Types::Boolean =
			      valid_arp_op(frame) and valid_arp_htype(frame) and valid_arp_ptype(frame);
			fun valid_ipv4_length(frame : RawEthernetMessage) : Base_Types::Boolean =
			      two_bytes_to_u16(frame[17], frame[18]) <= 9000;
			fun valid_ipv4_protocol(frame : RawEthernetMessage) : Base_Types::Boolean =
			      (frame[24] = 0)  or
				  (frame[24] = 1)  or
				  (frame[24] = 2)  or
				  (frame[24] = 6)  or
				  (frame[24] = 17) or
				  (frame[24] = 43) or
				  (frame[24] = 44) or
				  (frame[24] = 58) or
				  (frame[24] = 59) or
				  (frame[24] = 60);
			fun wellformed_ipv4_frame(frame : RawEthernetMessage) : Base_Types::Boolean =
			      valid_ipv4_protocol(frame) and valid_ipv4_length(frame);
			fun ipv4_is_tcp(frame : RawEthernetMessage) : Base_Types::Boolean =
				  frame[24] = 6;
			fun ipv4_is_udp(frame : RawEthernetMessage) : Base_Types::Boolean =
				  frame[24] = 17;
			fun frame_has_ipv4_tcp_on_allowed_port_quant(frame : RawEthernetMessage) : Base_Types::Boolean =
				  is_tcp_allowed_port(two_bytes_to_u16(frame[37], frame[38]));
			fun frame_has_ipv4_udp_on_allowed_port_quant(frame : RawEthernetMessage) : Base_Types::Boolean =
				  is_udp_allowed_port(two_bytes_to_u16(frame[37], frame[38]));

			fun valid_arp(frame : RawEthernetMessage) : Base_Types::Boolean =
			    frame_is_wellformed_eth2(frame) and frame_has_arp(frame) and wellformed_arp_frame(frame);
			fun valid_ipv4_tcp(frame : RawEthernetMessage) : Base_Types::Boolean =
			    frame_is_wellformed_eth2(frame) and frame_has_ipv4(frame) and wellformed_ipv4_frame(frame) and ipv4_is_tcp(frame);
			fun valid_ipv4_udp(frame : RawEthernetMessage) : Base_Types::Boolean =
			    frame_is_wellformed_eth2(frame) and frame_has_ipv4(frame) and wellformed_ipv4_frame(frame) and ipv4_is_udp(frame);
			fun valid_ipv4_tcp_port(frame : RawEthernetMessage) : Base_Types::Boolean =
			    valid_ipv4_tcp(frame) and frame_has_ipv4_tcp_on_allowed_port_quant(frame);
			fun valid_ipv4_udp_port(frame : RawEthernetMessage) : Base_Types::Boolean =
			    valid_ipv4_udp(frame) and frame_has_ipv4_udp_on_allowed_port_quant(frame);
			fun allow_outbound_frame(frame : RawEthernetMessage) : Base_Types::Boolean =
			    valid_arp(frame) or
			    valid_ipv4_tcp_port(frame) or
			    valid_ipv4_udp_port(frame);
			fun valid_output_arp_size(output : SizedEthernetMessage.Impl) : Base_Types::Boolean =
            	output.sz = 64;
            fun valid_ipv4(frame : RawEthernetMessage) : Base_Types::Boolean =
            	frame_is_wellformed_eth2(frame) and frame_has_ipv4(frame) and wellformed_ipv4_frame(frame);
            fun valid_output_ipv4_size(input : RawEthernetMessage, output : SizedEthernetMessage.Impl) : Base_Types::Boolean =
            	output.sz = (ipv4_length(input) + 14);
            fun ipv4_length(frame : RawEthernetMessage) : Base_Types::Unsigned_16 =
		      two_bytes_to_u16(frame[17], frame[18]);
	**};
end SW;
