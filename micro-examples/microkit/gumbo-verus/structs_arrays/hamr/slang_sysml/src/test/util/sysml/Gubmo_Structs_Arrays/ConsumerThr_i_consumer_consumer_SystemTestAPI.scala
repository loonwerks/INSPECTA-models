// #Sireum

package sysml.Gubmo_Structs_Arrays

import org.sireum._
import art._
import sysml.SystemTestSuiteSlang.runtimeMonitorStream
import sysml._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object ConsumerThr_i_consumer_consumer_SystemTestAPI {
  /** helper method to set the values of all incoming ports and state variables
    * @param In_myArrayInt32_StateVar pre-state state variable
    * @param In_myArrayStruct_StateVar pre-state state variable
    * @param In_myStructArray_StateVar pre-state state variable
    * @param api_c_myArrayInt32_EventDataPort incoming event data port
    * @param api_c_myArrayStruct_EventDataPort incoming event data port
    * @param api_c_myStructArray_EventDataPort incoming event data port
    * @param api_c_myArrayInt32_DataPort incoming data port
    * @param api_c_myArrayStruct_DataPort incoming data port
    * @param api_c_myStructArray_DataPort incoming data port
    */
  def put_concrete_inputs(In_myArrayInt32_StateVar: Gubmo_Structs_Arrays.MyArrayInt32,
                          In_myArrayStruct_StateVar: Gubmo_Structs_Arrays.MyArrayStruct,
                          In_myStructArray_StateVar: Gubmo_Structs_Arrays.MyStructArray_i,
                          api_c_myArrayInt32_EventDataPort: Option[Gubmo_Structs_Arrays.MyArrayInt32],
                          api_c_myArrayStruct_EventDataPort: Option[Gubmo_Structs_Arrays.MyArrayStruct],
                          api_c_myStructArray_EventDataPort: Option[Gubmo_Structs_Arrays.MyStructArray_i],
                          api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays.MyArrayInt32,
                          api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays.MyArrayStruct,
                          api_c_myStructArray_DataPort: Gubmo_Structs_Arrays.MyStructArray_i): Unit = {
    put_In_myArrayInt32_StateVar(In_myArrayInt32_StateVar)
    put_In_myArrayStruct_StateVar(In_myArrayStruct_StateVar)
    put_In_myStructArray_StateVar(In_myStructArray_StateVar)
    put_c_myArrayInt32_EventDataPort(api_c_myArrayInt32_EventDataPort)
    put_c_myArrayStruct_EventDataPort(api_c_myArrayStruct_EventDataPort)
    put_c_myStructArray_EventDataPort(api_c_myStructArray_EventDataPort)
    put_c_myArrayInt32_DataPort(api_c_myArrayInt32_DataPort)
    put_c_myArrayStruct_DataPort(api_c_myArrayStruct_DataPort)
    put_c_myStructArray_DataPort(api_c_myStructArray_DataPort)
  }

  // setter for state variable
  def put_In_myArrayInt32_StateVar(value: Gubmo_Structs_Arrays.MyArrayInt32): Unit = {
    ConsumerThr_i_consumer_consumer.myArrayInt32_StateVar = value
  }

  // setter for state variable
  def put_In_myArrayStruct_StateVar(value: Gubmo_Structs_Arrays.MyArrayStruct): Unit = {
    ConsumerThr_i_consumer_consumer.myArrayStruct_StateVar = value
  }

  // setter for state variable
  def put_In_myStructArray_StateVar(value: Gubmo_Structs_Arrays.MyStructArray_i): Unit = {
    ConsumerThr_i_consumer_consumer.myStructArray_StateVar = value
  }

  // setter for incoming event data port
  def put_c_myArrayInt32_EventDataPort(value: Option[Gubmo_Structs_Arrays.MyArrayInt32]): Unit = {
    value match {
      case Some(v) => Art.insertInInfrastructurePort(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayInt32_EventDataPort_Id, Gubmo_Structs_Arrays.MyArrayInt32_Payload(v))
      case _ =>
    }
  }

  // setter for incoming event data port
  def put_c_myArrayStruct_EventDataPort(value: Option[Gubmo_Structs_Arrays.MyArrayStruct]): Unit = {
    value match {
      case Some(v) => Art.insertInInfrastructurePort(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayStruct_EventDataPort_Id, Gubmo_Structs_Arrays.MyArrayStruct_Payload(v))
      case _ =>
    }
  }

  // setter for incoming event data port
  def put_c_myStructArray_EventDataPort(value: Option[Gubmo_Structs_Arrays.MyStructArray_i]): Unit = {
    value match {
      case Some(v) => Art.insertInInfrastructurePort(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myStructArray_EventDataPort_Id, Gubmo_Structs_Arrays.MyStructArray_i_Payload(v))
      case _ =>
    }
  }

  // setter for incoming data port
  def put_c_myArrayInt32_DataPort(value: Gubmo_Structs_Arrays.MyArrayInt32): Unit = {
    Art.insertInInfrastructurePort(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayInt32_DataPort_Id, Gubmo_Structs_Arrays.MyArrayInt32_Payload(value))
  }

  // setter for incoming data port
  def put_c_myArrayStruct_DataPort(value: Gubmo_Structs_Arrays.MyArrayStruct): Unit = {
    Art.insertInInfrastructurePort(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayStruct_DataPort_Id, Gubmo_Structs_Arrays.MyArrayStruct_Payload(value))
  }

  // setter for incoming data port
  def put_c_myStructArray_DataPort(value: Gubmo_Structs_Arrays.MyStructArray_i): Unit = {
    Art.insertInInfrastructurePort(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myStructArray_DataPort_Id, Gubmo_Structs_Arrays.MyStructArray_i_Payload(value))
  }

  def fetchContainer(): sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer_PostState_Container_PS = {
    if (runtimeMonitorStream.contains(Arch.Sys_i_Instance_consumer_consumer.id)) {
      val (_, postContainer_) = runtimeMonitorStream.get(Arch.Sys_i_Instance_consumer_consumer.id).get
      return postContainer_.asInstanceOf[sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer_PostState_Container_PS]
    }
    else {
      assert(F, s"No post state recorded for ${Arch.Sys_i_Instance_consumer_consumer.name}")
      halt(s"No post state recorded for ${Arch.Sys_i_Instance_consumer_consumer.name}")
    }
  }

  def check_concrete_outputs(myArrayInt32_StateVar: Gubmo_Structs_Arrays.MyArrayInt32,
                             myArrayStruct_StateVar: Gubmo_Structs_Arrays.MyArrayStruct,
                             myStructArray_StateVar: Gubmo_Structs_Arrays.MyStructArray_i): Unit = {
    var failureReasons: ISZ[ST] = ISZ()

    val actual_myArrayInt32_StateVar = get_myArrayInt32_StateVar()
    if (myArrayInt32_StateVar != actual_myArrayInt32_StateVar) {
      failureReasons = failureReasons :+ st"'myArrayInt32_StateVar' did not match expected.  Expected: $myArrayInt32_StateVar, Actual: $actual_myArrayInt32_StateVar"
    }
    val actual_myArrayStruct_StateVar = get_myArrayStruct_StateVar()
    if (myArrayStruct_StateVar != actual_myArrayStruct_StateVar) {
      failureReasons = failureReasons :+ st"'myArrayStruct_StateVar' did not match expected.  Expected: $myArrayStruct_StateVar, Actual: $actual_myArrayStruct_StateVar"
    }
    val actual_myStructArray_StateVar = get_myStructArray_StateVar()
    if (myStructArray_StateVar != actual_myStructArray_StateVar) {
      failureReasons = failureReasons :+ st"'myStructArray_StateVar' did not match expected.  Expected: $myStructArray_StateVar, Actual: $actual_myStructArray_StateVar"
    }

    assert(failureReasons.isEmpty, st"${(failureReasons, "\n")}".render)
  }

  // getter for state variable
  def get_myArrayInt32_StateVar(): Gubmo_Structs_Arrays.MyArrayInt32 = {
    return ConsumerThr_i_consumer_consumer.myArrayInt32_StateVar
  }

  // getter for state variable
  def get_myArrayStruct_StateVar(): Gubmo_Structs_Arrays.MyArrayStruct = {
    return ConsumerThr_i_consumer_consumer.myArrayStruct_StateVar
  }

  // getter for state variable
  def get_myStructArray_StateVar(): Gubmo_Structs_Arrays.MyStructArray_i = {
    return ConsumerThr_i_consumer_consumer.myStructArray_StateVar
  }
}