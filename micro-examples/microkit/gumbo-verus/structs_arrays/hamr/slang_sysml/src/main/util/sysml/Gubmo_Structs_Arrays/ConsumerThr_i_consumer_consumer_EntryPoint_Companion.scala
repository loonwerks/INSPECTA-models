// #Sireum

package sysml.Gubmo_Structs_Arrays

import org.sireum._
import art._
import sysml._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun

object ConsumerThr_i_consumer_consumer_EntryPoint_Companion {

  var preStateContainer_wL: Option[ConsumerThr_i_consumer_consumer_PreState_Container_PS] = None()

  def pre_initialise(): Unit = {
    // assume/require contracts cannot refer to incoming ports or
    // state variables so nothing to do here
  }

  def post_initialise(): Unit = {
    // block the component while its post-state values are retrieved
    val postStateContainer_wL =
      ConsumerThr_i_consumer_consumer_PostState_Container_PS(
        myArrayInt32_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myArrayInt32_StateVar,
        myArrayStruct_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myArrayStruct_StateVar,
        myStructArray_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myStructArray_StateVar)

    // the rest can now be performed via a different thread
    sysml.runtimemonitor.RuntimeMonitor.observeInitialisePostState(Arch.Sys_i_Instance_consumer_consumer.id, sysml.runtimemonitor.ObservationKind.Sys_i_Instance_consumer_consumer_postInit, postStateContainer_wL)
  }

  def pre_compute(): Unit = {
    // block the component while its pre-state values are retrieved
    preStateContainer_wL = Some(
      ConsumerThr_i_consumer_consumer_PreState_Container_PS(
        In_myArrayInt32_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myArrayInt32_StateVar, 
        In_myArrayStruct_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myArrayStruct_StateVar, 
        In_myStructArray_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myStructArray_StateVar, 
        api_c_myArrayInt32_EventDataPort = 
          if (Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayInt32_EventDataPort_Id).nonEmpty)
            Some(Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayInt32_EventDataPort_Id).get.asInstanceOf[Gubmo_Structs_Arrays.MyArrayInt32_Payload].value)
          else None(), 
        api_c_myArrayStruct_EventDataPort = 
          if (Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayStruct_EventDataPort_Id).nonEmpty)
            Some(Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayStruct_EventDataPort_Id).get.asInstanceOf[Gubmo_Structs_Arrays.MyArrayStruct_Payload].value)
          else None(), 
        api_c_myStructArray_EventDataPort = 
          if (Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myStructArray_EventDataPort_Id).nonEmpty)
            Some(Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myStructArray_EventDataPort_Id).get.asInstanceOf[Gubmo_Structs_Arrays.MyStructArray_i_Payload].value)
          else None(), 
        api_c_myArrayInt32_DataPort = Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayInt32_DataPort_Id).get.asInstanceOf[Gubmo_Structs_Arrays.MyArrayInt32_Payload].value, 
        api_c_myArrayStruct_DataPort = Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myArrayStruct_DataPort_Id).get.asInstanceOf[Gubmo_Structs_Arrays.MyArrayStruct_Payload].value, 
        api_c_myStructArray_DataPort = Art.observeInPortVariable(Arch.Sys_i_Instance_consumer_consumer.operational_api.c_myStructArray_DataPort_Id).get.asInstanceOf[Gubmo_Structs_Arrays.MyStructArray_i_Payload].value))

    // the rest can now be performed via a different thread
    sysml.runtimemonitor.RuntimeMonitor.observeComputePreState(Arch.Sys_i_Instance_consumer_consumer.id, sysml.runtimemonitor.ObservationKind.Sys_i_Instance_consumer_consumer_preCompute, preStateContainer_wL.asInstanceOf[Option[art.DataContent]])
  }

  def post_compute(): Unit = {
    // block the component while its post-state values are retrieved
    val postStateContainer_wL =
      ConsumerThr_i_consumer_consumer_PostState_Container_PS(
        myArrayInt32_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myArrayInt32_StateVar,
        myArrayStruct_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myArrayStruct_StateVar,
        myStructArray_StateVar = sysml.Gubmo_Structs_Arrays.ConsumerThr_i_consumer_consumer.myStructArray_StateVar)

    // the rest can now be performed via a different thread
    sysml.runtimemonitor.RuntimeMonitor.observeComputePrePostState(Arch.Sys_i_Instance_consumer_consumer.id, sysml.runtimemonitor.ObservationKind.Sys_i_Instance_consumer_consumer_postCompute, preStateContainer_wL.asInstanceOf[Option[art.DataContent]], postStateContainer_wL)
  }
}