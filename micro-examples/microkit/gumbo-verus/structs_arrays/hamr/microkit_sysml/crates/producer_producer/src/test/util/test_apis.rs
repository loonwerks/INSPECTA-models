// Do not edit this file as it will be overwritten if codegen is rerun

use crate::bridge::extern_c_api as extern_api;
use data::*;

use proptest::prelude::*;

/// container for component's incoming port values
pub struct PreStateContainer {
}

/// setter for component's incoming port values
pub fn put_concrete_inputs_container(container: PreStateContainer)
{

}

/// setter for component's incoming port values
pub fn put_concrete_inputs()
{

}

/// getter for OUT DataPort
pub fn get_p_myArrayInt32_DataPort() -> Gubmo_Structs_Arrays::MyArrayInt32
{
  return extern_api::OUT_p_myArrayInt32_DataPort.lock().unwrap_or_else(|e| e.into_inner()).expect("Not expecting None")
}

/// getter for OUT DataPort
pub fn get_p_myArrayStruct_DataPort() -> Gubmo_Structs_Arrays::MyArrayStruct
{
  return extern_api::OUT_p_myArrayStruct_DataPort.lock().unwrap_or_else(|e| e.into_inner()).expect("Not expecting None")
}

/// getter for OUT DataPort
pub fn get_p_myStructArray_DataPort() -> Gubmo_Structs_Arrays::MyStructArray_i
{
  return extern_api::OUT_p_myStructArray_DataPort.lock().unwrap_or_else(|e| e.into_inner()).expect("Not expecting None")
}

/// getter for OUT EventDataPort
pub fn get_p_myArrayInt32_EventDataPort() -> Option<Gubmo_Structs_Arrays::MyArrayInt32>
{
  return extern_api::OUT_p_myArrayInt32_EventDataPort.lock().unwrap_or_else(|e| e.into_inner()).clone()
}

/// getter for OUT EventDataPort
pub fn get_p_myArrayStruct_EventDataPort() -> Option<Gubmo_Structs_Arrays::MyArrayStruct>
{
  return extern_api::OUT_p_myArrayStruct_EventDataPort.lock().unwrap_or_else(|e| e.into_inner()).clone()
}

/// getter for OUT EventDataPort
pub fn get_p_myStructArray_EventDataPort() -> Option<Gubmo_Structs_Arrays::MyStructArray_i>
{
  return extern_api::OUT_p_myStructArray_EventDataPort.lock().unwrap_or_else(|e| e.into_inner()).clone()
}
