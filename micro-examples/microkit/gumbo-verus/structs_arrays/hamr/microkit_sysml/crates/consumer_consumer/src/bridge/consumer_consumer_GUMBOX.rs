// Do not edit this file as it will be overwritten if codegen is rerun

use data::*;

macro_rules! implies {
  ($lhs: expr, $rhs: expr) => {
    !$lhs || $rhs
  };
}

macro_rules! impliesL {
  ($lhs: expr, $rhs: expr) => {
    !$lhs | $rhs
  };
}

pub fn myArrayInt32_FunctionReturn(v: Gubmo_Structs_Arrays::MyArrayInt32) -> Gubmo_Structs_Arrays::MyArrayInt32
{
  v
}

pub fn myArrayInt32_FunctionParam(v: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=v.len() - 1).any(|i| v[i] == 0i32)
}

pub fn myArrayStruct_FunctionReturn(v: Gubmo_Structs_Arrays::MyArrayStruct) -> Gubmo_Structs_Arrays::MyArrayStruct
{
  v
}

pub fn myArrayStruct_FunctionParam(v: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=v.len() - 1).any(|i| v[i].fieldSInt32 == 0i32)
}

pub fn myStructArray_i_FunctionReturn(v: Gubmo_Structs_Arrays::MyStructArray_i) -> Gubmo_Structs_Arrays::MyStructArray_i
{
  v
}

pub fn myStructArray_i_FunctionParam(v: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=v.fieldArray.len() - 1).any(|i| v.fieldArray[i].fieldSInt32 == 0i32)
}

/// GUMBOX wrapper for the GUMBO spec function `test` that delegates to the developer-supplied GUMBOX
/// specification function that must have the following signature:
/// 
///   pub exec fn subclauseSpecFunction_Assume__developer_gumbox(a: Gubmo_Structs_Arrays::MyArrayInt32) -> (res: bool) { ... }
/// 
/// The semantics of the GUMBO spec function are entirely defined by the developer-supplied implementation.
pub fn subclauseSpecFunction_Assume(a: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  crate::component::consumer_consumer_app::subclauseSpecFunction_Assume__developer_gumbox(a)
}

/// GUMBOX wrapper for the GUMBO spec function `test` that delegates to the developer-supplied GUMBOX
/// specification function that must have the following signature:
/// 
///   pub exec fn subclauseSpecFunction_Guarantee__developer_gumbox(a: Gubmo_Structs_Arrays::MyArrayInt32) -> (res: bool) { ... }
/// 
/// The semantics of the GUMBO spec function are entirely defined by the developer-supplied implementation.
pub fn subclauseSpecFunction_Guarantee(a: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  crate::component::consumer_consumer_app::subclauseSpecFunction_Guarantee__developer_gumbox(a)
}

/** I-Assm: Integration constraint on consumer's incoming data port c_myArrayInt32_DataPort
  *
  * assume integrationArrayInt32_DataPort
  */
pub fn I_Assm_c_myArrayInt32_DataPort(c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  ((c_myArrayInt32_DataPort.len() == 10) &&
    (c_myArrayInt32_DataPort[0] == 1i32)) &
    GumboLib::normalLibraryFunction(c_myArrayInt32_DataPort)
}

/** I-Assm: Integration constraint on consumer's incoming event data port c_myArrayInt32_EventDataPort
  *
  * assume integrationArrayInt32_EventDataPort
  */
pub fn I_Assm_c_myArrayInt32_EventDataPort(c_myArrayInt32_EventDataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=c_myArrayInt32_EventDataPort.len() - 2).all(|i| c_myArrayInt32_EventDataPort[i] <= c_myArrayInt32_EventDataPort[i + 1])
}

/** I-Assm: Integration constraint on consumer's incoming event data port c_myArrayInt32_EventDataPort
  *
  * assume integrationArrayInt32_EventDataPort
  */
pub fn I_Assm_Guard_c_myArrayInt32_EventDataPort(c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>) -> bool
{
  implies!(
    c_myArrayInt32_EventDataPort.is_some(),
    I_Assm_c_myArrayInt32_EventDataPort(c_myArrayInt32_EventDataPort.unwrap())
  )
}

/** I-Assm: Integration constraint on consumer's incoming event data port c_myStructArray_EventDataPort
  *
  * assume integrationStructArray_EventDataPort
  */
pub fn I_Assm_c_myStructArray_EventDataPort(c_myStructArray_EventDataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=c_myStructArray_EventDataPort.fieldArray.len() - 2).all(|i| c_myStructArray_EventDataPort.fieldArray[i].fieldSInt32 <= c_myStructArray_EventDataPort.fieldArray[i + 1].fieldSInt32)
}

/** I-Assm: Integration constraint on consumer's incoming event data port c_myStructArray_EventDataPort
  *
  * assume integrationStructArray_EventDataPort
  */
pub fn I_Assm_Guard_c_myStructArray_EventDataPort(c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>) -> bool
{
  implies!(
    c_myStructArray_EventDataPort.is_some(),
    I_Assm_c_myStructArray_EventDataPort(c_myStructArray_EventDataPort.unwrap())
  )
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayInt32_StateVar_Assume
  * @param In_myArrayInt32_StateVar pre-state state variable
  */
pub fn compute_spec_isSorted_MyArrayInt32_StateVar_Assume_assume(In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=In_myArrayInt32_StateVar.len() - 2).all(|i| In_myArrayInt32_StateVar[i] <= In_myArrayInt32_StateVar[i + 1])
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayStruct_StateVar_Assume
  * @param In_myArrayStruct_StateVar pre-state state variable
  */
pub fn compute_spec_isSorted_MyArrayStruct_StateVar_Assume_assume(In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=In_myArrayStruct_StateVar.len() - 2).all(|i| In_myArrayStruct_StateVar[i].fieldSInt32 <= In_myArrayStruct_StateVar[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyStructArray_StateVar_Assume
  * @param In_myStructArray_StateVar pre-state state variable
  */
pub fn compute_spec_isSorted_MyStructArray_StateVar_Assume_assume(In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=In_myStructArray_StateVar.fieldArray.len() - 2).all(|i| In_myStructArray_StateVar.fieldArray[i].fieldSInt32 <= In_myStructArray_StateVar.fieldArray[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayInt32_Function_Assume
  *   Ensure operations on an array returned by a function work as expected
  * @param In_myArrayInt32_StateVar pre-state state variable
  */
pub fn compute_spec_isSorted_MyArrayInt32_Function_Assume_assume(In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=myArrayInt32_FunctionReturn(In_myArrayInt32_StateVar).len() - 2).all(|i| myArrayInt32_FunctionReturn(In_myArrayInt32_StateVar)[i] <= myArrayInt32_FunctionReturn(In_myArrayInt32_StateVar)[i + 1])
}

/** Compute Entrypoint Contract
  *
  * assumes myArrayInt32_FunctionParam_Assume
  *   ensure functions can operate on arrays
  * @param In_myArrayInt32_StateVar pre-state state variable
  */
pub fn compute_spec_myArrayInt32_FunctionParam_Assume_assume(In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  myArrayInt32_FunctionParam(In_myArrayInt32_StateVar)
}

/** Compute Entrypoint Contract
  *
  * assumes specFunctionAssumeTest
  * @param api_c_myArrayInt32_DataPort incoming data port
  */
pub fn compute_spec_specFunctionAssumeTest_assume(api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  subclauseSpecFunction_Assume(api_c_myArrayInt32_DataPort) &
    (GumboLib::normalLibraryFunction(api_c_myArrayInt32_DataPort) & GumboLib::librarySpecFunction_Assume(api_c_myArrayInt32_DataPort))
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayStruct_Function_Assume
  *   Ensure operations on an array returned by a function work as expected
  * @param In_myArrayStruct_StateVar pre-state state variable
  */
pub fn compute_spec_isSorted_MyArrayStruct_Function_Assume_assume(In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=myArrayStruct_FunctionReturn(In_myArrayStruct_StateVar).len() - 2).all(|i| myArrayStruct_FunctionReturn(In_myArrayStruct_StateVar)[i].fieldSInt32 <= myArrayStruct_FunctionReturn(In_myArrayStruct_StateVar)[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * assumes myArrayStruct_FunctionParam_Assume
  *   ensure functions can operate on arrays
  * @param In_myArrayStruct_StateVar pre-state state variable
  */
pub fn compute_spec_myArrayStruct_FunctionParam_Assume_assume(In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  myArrayStruct_FunctionParam(In_myArrayStruct_StateVar)
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyStructArray_i_Function_Assume
  *   Ensure operations on an array returned by a function work as expected
  * @param In_myStructArray_StateVar pre-state state variable
  */
pub fn compute_spec_isSorted_MyStructArray_i_Function_Assume_assume(In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=myStructArray_i_FunctionReturn(In_myStructArray_StateVar).fieldArray.len() - 2).all(|i| myStructArray_i_FunctionReturn(In_myStructArray_StateVar).fieldArray[i].fieldSInt32 <= myStructArray_i_FunctionReturn(In_myStructArray_StateVar).fieldArray[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * assumes myStructArray_i_FunctionParam_Assume
  *   ensure functions can operate on arrays
  * @param In_myStructArray_StateVar pre-state state variable
  */
pub fn compute_spec_myStructArray_i_FunctionParam_Assume_assume(In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  myStructArray_i_FunctionParam(In_myStructArray_StateVar)
}

/** Compute Entrypoint Contract
  *
  * assumes atLeastOneZero_MyArrayInt32_DataPort_Assume
  * @param api_c_myArrayInt32_DataPort incoming data port
  */
pub fn compute_spec_atLeastOneZero_MyArrayInt32_DataPort_Assume_assume(api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=api_c_myArrayInt32_DataPort.len() - 1).any(|i| api_c_myArrayInt32_DataPort[i] == 0i32)
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayInt32_DataPort_Assume
  * @param api_c_myArrayInt32_DataPort incoming data port
  */
pub fn compute_spec_isSorted_MyArrayInt32_DataPort_Assume_assume(api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=api_c_myArrayInt32_DataPort.len() - 2).all(|i| api_c_myArrayInt32_DataPort[i] <= api_c_myArrayInt32_DataPort[i + 1])
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayStruct_DataPort_Assume
  * @param api_c_myArrayStruct_DataPort incoming data port
  */
pub fn compute_spec_isSorted_MyArrayStruct_DataPort_Assume_assume(api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=api_c_myArrayStruct_DataPort.len() - 2).all(|i| api_c_myArrayStruct_DataPort[i].fieldSInt32 <= api_c_myArrayStruct_DataPort[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyStructArray_DataPort_Assume
  * @param api_c_myStructArray_DataPort incoming data port
  */
pub fn compute_spec_isSorted_MyStructArray_DataPort_Assume_assume(api_c_myStructArray_DataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=api_c_myStructArray_DataPort.fieldArray.len() - 2).all(|i| api_c_myStructArray_DataPort.fieldArray[i].fieldSInt32 <= api_c_myStructArray_DataPort.fieldArray[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayInt32_EventDataPort_Assume
  * @param api_c_myArrayInt32_EventDataPort incoming event data port
  */
pub fn compute_spec_isSorted_MyArrayInt32_EventDataPort_Assume_assume(api_c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>) -> bool
{
  implies!(
    api_c_myArrayInt32_EventDataPort.is_some(),
    (0..=api_c_myArrayInt32_EventDataPort.unwrap().len() - 2).all(|i| api_c_myArrayInt32_EventDataPort.unwrap()[i] <= api_c_myArrayInt32_EventDataPort.unwrap()[i + 1]))
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyArrayStruct_EventDataPort_Assume
  * @param api_c_myArrayStruct_EventDataPort incoming event data port
  */
pub fn compute_spec_isSorted_MyArrayStruct_EventDataPort_Assume_assume(api_c_myArrayStruct_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayStruct>) -> bool
{
  implies!(
    api_c_myArrayStruct_EventDataPort.is_some(),
    (0..=api_c_myArrayStruct_EventDataPort.unwrap().len() - 2).all(|i| api_c_myArrayStruct_EventDataPort.unwrap()[i].fieldSInt32 <= api_c_myArrayStruct_EventDataPort.unwrap()[i + 1].fieldSInt32))
}

/** Compute Entrypoint Contract
  *
  * assumes isSorted_MyStructArray_EventDataPort_Assume
  * @param api_c_myStructArray_EventDataPort incoming event data port
  */
pub fn compute_spec_isSorted_MyStructArray_EventDataPort_Assume_assume(api_c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>) -> bool
{
  implies!(
    api_c_myStructArray_EventDataPort.is_some(),
    (0..=api_c_myStructArray_EventDataPort.unwrap().fieldArray.len() - 2).all(|i| api_c_myStructArray_EventDataPort.unwrap().fieldArray[i].fieldSInt32 <= api_c_myStructArray_EventDataPort.unwrap().fieldArray[i + 1].fieldSInt32))
}

/** CEP-T-Assm: Top-level assume contracts for consumer's compute entrypoint
  *
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param In_myStructArray_StateVar pre-state state variable
  * @param api_c_myArrayInt32_EventDataPort incoming event data port
  * @param api_c_myArrayStruct_EventDataPort incoming event data port
  * @param api_c_myStructArray_EventDataPort incoming event data port
  * @param api_c_myArrayInt32_DataPort incoming data port
  * @param api_c_myArrayStruct_DataPort incoming data port
  * @param api_c_myStructArray_DataPort incoming data port
  */
pub fn compute_CEP_T_Assm(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  api_c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>,
  api_c_myArrayStruct_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayStruct>,
  api_c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>,
  api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32,
  api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays::MyArrayStruct,
  api_c_myStructArray_DataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  let r0: bool = compute_spec_isSorted_MyArrayInt32_StateVar_Assume_assume(In_myArrayInt32_StateVar);
  let r1: bool = compute_spec_isSorted_MyArrayStruct_StateVar_Assume_assume(In_myArrayStruct_StateVar);
  let r2: bool = compute_spec_isSorted_MyStructArray_StateVar_Assume_assume(In_myStructArray_StateVar);
  let r3: bool = compute_spec_isSorted_MyArrayInt32_Function_Assume_assume(In_myArrayInt32_StateVar);
  let r4: bool = compute_spec_myArrayInt32_FunctionParam_Assume_assume(In_myArrayInt32_StateVar);
  let r5: bool = compute_spec_specFunctionAssumeTest_assume(api_c_myArrayInt32_DataPort);
  let r6: bool = compute_spec_isSorted_MyArrayStruct_Function_Assume_assume(In_myArrayStruct_StateVar);
  let r7: bool = compute_spec_myArrayStruct_FunctionParam_Assume_assume(In_myArrayStruct_StateVar);
  let r8: bool = compute_spec_isSorted_MyStructArray_i_Function_Assume_assume(In_myStructArray_StateVar);
  let r9: bool = compute_spec_myStructArray_i_FunctionParam_Assume_assume(In_myStructArray_StateVar);
  let r10: bool = compute_spec_atLeastOneZero_MyArrayInt32_DataPort_Assume_assume(api_c_myArrayInt32_DataPort);
  let r11: bool = compute_spec_isSorted_MyArrayInt32_DataPort_Assume_assume(api_c_myArrayInt32_DataPort);
  let r12: bool = compute_spec_isSorted_MyArrayStruct_DataPort_Assume_assume(api_c_myArrayStruct_DataPort);
  let r13: bool = compute_spec_isSorted_MyStructArray_DataPort_Assume_assume(api_c_myStructArray_DataPort);
  let r14: bool = compute_spec_isSorted_MyArrayInt32_EventDataPort_Assume_assume(api_c_myArrayInt32_EventDataPort);
  let r15: bool = compute_spec_isSorted_MyArrayStruct_EventDataPort_Assume_assume(api_c_myArrayStruct_EventDataPort);
  let r16: bool = compute_spec_isSorted_MyStructArray_EventDataPort_Assume_assume(api_c_myStructArray_EventDataPort);

  return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8 && r9 && r10 && r11 && r12 && r13 && r14 && r15 && r16;
}

/** CEP-Pre: Compute Entrypoint Pre-Condition for consumer
  *
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param In_myStructArray_StateVar pre-state state variable
  * @param api_c_myArrayInt32_EventDataPort incoming event data port
  * @param api_c_myArrayStruct_EventDataPort incoming event data port
  * @param api_c_myStructArray_EventDataPort incoming event data port
  * @param api_c_myArrayInt32_DataPort incoming data port
  * @param api_c_myArrayStruct_DataPort incoming data port
  * @param api_c_myStructArray_DataPort incoming data port
  */
pub fn compute_CEP_Pre(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  api_c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>,
  api_c_myArrayStruct_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayStruct>,
  api_c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>,
  api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32,
  api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays::MyArrayStruct,
  api_c_myStructArray_DataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  // I-Assm-Guard: Integration constraints for consumer's incoming ports
  let r0: bool = I_Assm_c_myArrayInt32_DataPort(api_c_myArrayInt32_DataPort);
  let r1: bool = I_Assm_Guard_c_myArrayInt32_EventDataPort(api_c_myArrayInt32_EventDataPort);
  let r2: bool = I_Assm_Guard_c_myStructArray_EventDataPort(api_c_myStructArray_EventDataPort);

  // CEP-Assm: assume clauses of consumer's compute entrypoint
  let r3: bool = compute_CEP_T_Assm(In_myArrayInt32_StateVar, In_myArrayStruct_StateVar, In_myStructArray_StateVar, api_c_myArrayInt32_EventDataPort, api_c_myArrayStruct_EventDataPort, api_c_myStructArray_EventDataPort, api_c_myArrayInt32_DataPort, api_c_myArrayStruct_DataPort, api_c_myStructArray_DataPort);

  return r0 && r1 && r2 && r3;
}

/** Compute Entrypoint Contract
  *
  * guarantee noChange_MyArrayInt32_StateVar_Guarantee
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param myArrayInt32_StateVar post-state state variable
  */
pub fn compute_spec_noChange_MyArrayInt32_StateVar_Guarantee_guarantee(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  In_myArrayInt32_StateVar[0] == myArrayInt32_StateVar[0]
}

/** Compute Entrypoint Contract
  *
  * guarantee noChange_MyArrayStruct_StateVar_Guarantee
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param myArrayStruct_StateVar post-state state variable
  */
pub fn compute_spec_noChange_MyArrayStruct_StateVar_Guarantee_guarantee(
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  In_myArrayStruct_StateVar[0].fieldSInt32 == myArrayStruct_StateVar[0].fieldSInt32
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayInt32_StateVar_Guarantee
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param myArrayInt32_StateVar post-state state variable
  */
pub fn compute_spec_isSorted_MyArrayInt32_StateVar_Guarantee_guarantee(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=myArrayInt32_StateVar.len() - 2).all(|i| In_myArrayInt32_StateVar[i] <= myArrayInt32_StateVar[i + 1])
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayStruct_StateVar_Guarantee
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param myArrayStruct_StateVar post-state state variable
  */
pub fn compute_spec_isSorted_MyArrayStruct_StateVar_Guarantee_guarantee(
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=myArrayStruct_StateVar.len() - 2).all(|i| In_myArrayStruct_StateVar[i].fieldSInt32 <= myArrayStruct_StateVar[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyStructArray_StateVar_Guarantee
  * @param In_myStructArray_StateVar pre-state state variable
  * @param myStructArray_StateVar post-state state variable
  */
pub fn compute_spec_isSorted_MyStructArray_StateVar_Guarantee_guarantee(
  In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=myStructArray_StateVar.fieldArray.len() - 2).all(|i| In_myStructArray_StateVar.fieldArray[i].fieldSInt32 <= myStructArray_StateVar.fieldArray[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayInt32_Function_Guarantee
  *   Ensure operations on an array returned by a function work as expected
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param myArrayInt32_StateVar post-state state variable
  */
pub fn compute_spec_isSorted_MyArrayInt32_Function_Guarantee_guarantee(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=myArrayInt32_FunctionReturn(myArrayInt32_StateVar).len() - 2).all(|i| myArrayInt32_FunctionReturn(In_myArrayInt32_StateVar)[i] <= myArrayInt32_FunctionReturn(myArrayInt32_StateVar)[i + 1])
}

/** Compute Entrypoint Contract
  *
  * guarantee myArrayInt32_FunctionParam_Guarantee
  *   ensure functions can operate on arrays
  * @param In_myArrayInt32_StateVar pre-state state variable
  */
pub fn compute_spec_myArrayInt32_FunctionParam_Guarantee_guarantee(In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  myArrayInt32_FunctionParam(In_myArrayInt32_StateVar)
}

/** Compute Entrypoint Contract
  *
  * guarantee librarySpecFunctionTest
  * @param api_c_myArrayInt32_DataPort incoming data port
  */
pub fn compute_spec_librarySpecFunctionTest_guarantee(api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  subclauseSpecFunction_Assume(api_c_myArrayInt32_DataPort) &
    (subclauseSpecFunction_Guarantee(api_c_myArrayInt32_DataPort) &
      (GumboLib::normalLibraryFunction(api_c_myArrayInt32_DataPort) & GumboLib::librarySpecFunction_Guarantee(api_c_myArrayInt32_DataPort)))
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayStruct_Function_Guarantee
  *   Ensure operations on an array returned by a function work as expected
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param myArrayStruct_StateVar post-state state variable
  */
pub fn compute_spec_isSorted_MyArrayStruct_Function_Guarantee_guarantee(
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=myArrayStruct_FunctionReturn(myArrayStruct_StateVar).len() - 2).all(|i| myArrayStruct_FunctionReturn(In_myArrayStruct_StateVar)[i].fieldSInt32 <= myArrayStruct_FunctionReturn(myArrayStruct_StateVar)[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * guarantee myArrayStruct_FunctionParam_Guarantee
  *   ensure functions can operate on arrays
  * @param In_myArrayStruct_StateVar pre-state state variable
  */
pub fn compute_spec_myArrayStruct_FunctionParam_Guarantee_guarantee(In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  myArrayStruct_FunctionParam(In_myArrayStruct_StateVar)
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyStructArray_i_Function_Guarantee
  *   Ensure operations on an array returned by a function work as expected
  * @param In_myStructArray_StateVar pre-state state variable
  * @param myStructArray_StateVar post-state state variable
  */
pub fn compute_spec_isSorted_MyStructArray_i_Function_Guarantee_guarantee(
  In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=myStructArray_i_FunctionReturn(myStructArray_StateVar).fieldArray.len() - 2).all(|i| myStructArray_i_FunctionReturn(In_myStructArray_StateVar).fieldArray[i].fieldSInt32 <= myStructArray_i_FunctionReturn(myStructArray_StateVar).fieldArray[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * guarantee myStructArray_i_FunctionParam_Guarantee
  *   ensure functions can operate on arrays
  * @param In_myStructArray_StateVar pre-state state variable
  */
pub fn compute_spec_myStructArray_i_FunctionParam_Guarantee_guarantee(In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  myStructArray_i_FunctionParam(In_myStructArray_StateVar)
}

/** Compute Entrypoint Contract
  *
  * guarantee atLeastOneZero_MyArrayInt32_DataPort_Guarantee
  * @param api_c_myArrayInt32_DataPort incoming data port
  */
pub fn compute_spec_atLeastOneZero_MyArrayInt32_DataPort_Guarantee_guarantee(api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=api_c_myArrayInt32_DataPort.len() - 1).any(|i| api_c_myArrayInt32_DataPort[i] == 0i32)
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayInt32_DataPort_Guarantee
  * @param api_c_myArrayInt32_DataPort incoming data port
  */
pub fn compute_spec_isSorted_MyArrayInt32_DataPort_Guarantee_guarantee(api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32) -> bool
{
  (0..=api_c_myArrayInt32_DataPort.len() - 2).all(|i| api_c_myArrayInt32_DataPort[i] <= api_c_myArrayInt32_DataPort[i + 1])
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayStruct_DataPort_Guarantee
  * @param api_c_myArrayStruct_DataPort incoming data port
  */
pub fn compute_spec_isSorted_MyArrayStruct_DataPort_Guarantee_guarantee(api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays::MyArrayStruct) -> bool
{
  (0..=api_c_myArrayStruct_DataPort.len() - 2).all(|i| api_c_myArrayStruct_DataPort[i].fieldSInt32 <= api_c_myArrayStruct_DataPort[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyStructArray_DataPort_Guarantee
  * @param api_c_myStructArray_DataPort incoming data port
  */
pub fn compute_spec_isSorted_MyStructArray_DataPort_Guarantee_guarantee(api_c_myStructArray_DataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  (0..=api_c_myStructArray_DataPort.fieldArray.len() - 2).all(|i| api_c_myStructArray_DataPort.fieldArray[i].fieldSInt32 <= api_c_myStructArray_DataPort.fieldArray[i + 1].fieldSInt32)
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayInt32_EventDataPort_Guarantee
  * @param api_c_myArrayInt32_EventDataPort incoming event data port
  */
pub fn compute_spec_isSorted_MyArrayInt32_EventDataPort_Guarantee_guarantee(api_c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>) -> bool
{
  implies!(
    api_c_myArrayInt32_EventDataPort.is_some(),
    (0..=api_c_myArrayInt32_EventDataPort.unwrap().len() - 2).all(|i| api_c_myArrayInt32_EventDataPort.unwrap()[i] <= api_c_myArrayInt32_EventDataPort.unwrap()[i + 1]))
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyArrayStruct_EventDataPort_Guarantee
  * @param api_c_myArrayStruct_EventDataPort incoming event data port
  */
pub fn compute_spec_isSorted_MyArrayStruct_EventDataPort_Guarantee_guarantee(api_c_myArrayStruct_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayStruct>) -> bool
{
  implies!(
    api_c_myArrayStruct_EventDataPort.is_some(),
    (0..=api_c_myArrayStruct_EventDataPort.unwrap().len() - 2).all(|i| api_c_myArrayStruct_EventDataPort.unwrap()[i].fieldSInt32 <= api_c_myArrayStruct_EventDataPort.unwrap()[i + 1].fieldSInt32))
}

/** Compute Entrypoint Contract
  *
  * guarantee isSorted_MyStructArray_EventDataPort_Guarantee
  * @param api_c_myStructArray_EventDataPort incoming event data port
  */
pub fn compute_spec_isSorted_MyStructArray_EventDataPort_Guarantee_guarantee(api_c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>) -> bool
{
  implies!(
    api_c_myStructArray_EventDataPort.is_some(),
    (0..=api_c_myStructArray_EventDataPort.unwrap().fieldArray.len() - 2).all(|i| api_c_myStructArray_EventDataPort.unwrap().fieldArray[i].fieldSInt32 <= api_c_myStructArray_EventDataPort.unwrap().fieldArray[i + 1].fieldSInt32))
}

/** CEP-T-Guar: Top-level guarantee contracts for consumer's compute entrypoint
  *
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param In_myStructArray_StateVar pre-state state variable
  * @param myArrayInt32_StateVar post-state state variable
  * @param myArrayStruct_StateVar post-state state variable
  * @param myStructArray_StateVar post-state state variable
  * @param api_c_myArrayInt32_EventDataPort incoming event data port
  * @param api_c_myArrayStruct_EventDataPort incoming event data port
  * @param api_c_myStructArray_EventDataPort incoming event data port
  * @param api_c_myArrayInt32_DataPort incoming data port
  * @param api_c_myArrayStruct_DataPort incoming data port
  * @param api_c_myStructArray_DataPort incoming data port
  */
pub fn compute_CEP_T_Guar(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  api_c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>,
  api_c_myArrayStruct_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayStruct>,
  api_c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>,
  api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32,
  api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays::MyArrayStruct,
  api_c_myStructArray_DataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  let r0: bool = compute_spec_noChange_MyArrayInt32_StateVar_Guarantee_guarantee(In_myArrayInt32_StateVar, myArrayInt32_StateVar);
  let r1: bool = compute_spec_noChange_MyArrayStruct_StateVar_Guarantee_guarantee(In_myArrayStruct_StateVar, myArrayStruct_StateVar);
  let r2: bool = compute_spec_isSorted_MyArrayInt32_StateVar_Guarantee_guarantee(In_myArrayInt32_StateVar, myArrayInt32_StateVar);
  let r3: bool = compute_spec_isSorted_MyArrayStruct_StateVar_Guarantee_guarantee(In_myArrayStruct_StateVar, myArrayStruct_StateVar);
  let r4: bool = compute_spec_isSorted_MyStructArray_StateVar_Guarantee_guarantee(In_myStructArray_StateVar, myStructArray_StateVar);
  let r5: bool = compute_spec_isSorted_MyArrayInt32_Function_Guarantee_guarantee(In_myArrayInt32_StateVar, myArrayInt32_StateVar);
  let r6: bool = compute_spec_myArrayInt32_FunctionParam_Guarantee_guarantee(In_myArrayInt32_StateVar);
  let r7: bool = compute_spec_librarySpecFunctionTest_guarantee(api_c_myArrayInt32_DataPort);
  let r8: bool = compute_spec_isSorted_MyArrayStruct_Function_Guarantee_guarantee(In_myArrayStruct_StateVar, myArrayStruct_StateVar);
  let r9: bool = compute_spec_myArrayStruct_FunctionParam_Guarantee_guarantee(In_myArrayStruct_StateVar);
  let r10: bool = compute_spec_isSorted_MyStructArray_i_Function_Guarantee_guarantee(In_myStructArray_StateVar, myStructArray_StateVar);
  let r11: bool = compute_spec_myStructArray_i_FunctionParam_Guarantee_guarantee(In_myStructArray_StateVar);
  let r12: bool = compute_spec_atLeastOneZero_MyArrayInt32_DataPort_Guarantee_guarantee(api_c_myArrayInt32_DataPort);
  let r13: bool = compute_spec_isSorted_MyArrayInt32_DataPort_Guarantee_guarantee(api_c_myArrayInt32_DataPort);
  let r14: bool = compute_spec_isSorted_MyArrayStruct_DataPort_Guarantee_guarantee(api_c_myArrayStruct_DataPort);
  let r15: bool = compute_spec_isSorted_MyStructArray_DataPort_Guarantee_guarantee(api_c_myStructArray_DataPort);
  let r16: bool = compute_spec_isSorted_MyArrayInt32_EventDataPort_Guarantee_guarantee(api_c_myArrayInt32_EventDataPort);
  let r17: bool = compute_spec_isSorted_MyArrayStruct_EventDataPort_Guarantee_guarantee(api_c_myArrayStruct_EventDataPort);
  let r18: bool = compute_spec_isSorted_MyStructArray_EventDataPort_Guarantee_guarantee(api_c_myStructArray_EventDataPort);

  return r0 && r1 && r2 && r3 && r4 && r5 && r6 && r7 && r8 && r9 && r10 && r11 && r12 && r13 && r14 && r15 && r16 && r17 && r18;
}

/** CEP-Post: Compute Entrypoint Post-Condition for consumer
  *
  * @param In_myArrayInt32_StateVar pre-state state variable
  * @param In_myArrayStruct_StateVar pre-state state variable
  * @param In_myStructArray_StateVar pre-state state variable
  * @param myArrayInt32_StateVar post-state state variable
  * @param myArrayStruct_StateVar post-state state variable
  * @param myStructArray_StateVar post-state state variable
  * @param api_c_myArrayInt32_EventDataPort incoming event data port
  * @param api_c_myArrayStruct_EventDataPort incoming event data port
  * @param api_c_myStructArray_EventDataPort incoming event data port
  * @param api_c_myArrayInt32_DataPort incoming data port
  * @param api_c_myArrayStruct_DataPort incoming data port
  * @param api_c_myStructArray_DataPort incoming data port
  */
pub fn compute_CEP_Post(
  In_myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  In_myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  In_myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  myArrayInt32_StateVar: Gubmo_Structs_Arrays::MyArrayInt32,
  myArrayStruct_StateVar: Gubmo_Structs_Arrays::MyArrayStruct,
  myStructArray_StateVar: Gubmo_Structs_Arrays::MyStructArray_i,
  api_c_myArrayInt32_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayInt32>,
  api_c_myArrayStruct_EventDataPort: Option<Gubmo_Structs_Arrays::MyArrayStruct>,
  api_c_myStructArray_EventDataPort: Option<Gubmo_Structs_Arrays::MyStructArray_i>,
  api_c_myArrayInt32_DataPort: Gubmo_Structs_Arrays::MyArrayInt32,
  api_c_myArrayStruct_DataPort: Gubmo_Structs_Arrays::MyArrayStruct,
  api_c_myStructArray_DataPort: Gubmo_Structs_Arrays::MyStructArray_i) -> bool
{
  // CEP-Guar: guarantee clauses of consumer's compute entrypoint
  let r0: bool = compute_CEP_T_Guar(In_myArrayInt32_StateVar, In_myArrayStruct_StateVar, In_myStructArray_StateVar, myArrayInt32_StateVar, myArrayStruct_StateVar, myStructArray_StateVar, api_c_myArrayInt32_EventDataPort, api_c_myArrayStruct_EventDataPort, api_c_myStructArray_EventDataPort, api_c_myArrayInt32_DataPort, api_c_myArrayStruct_DataPort, api_c_myStructArray_DataPort);

  return r0;
}
