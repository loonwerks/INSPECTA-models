#![cfg(test)]

// Do not edit this file as it will be overwritten if codegen is rerun

use crate::bridge::extern_c_api as extern_api;
use data::*;

use proptest::prelude::*;

use crate::bridge::consumer_consumer_GUMBOX as GUMBOX;

pub struct PreStateContainer {
  pub api_myStruct: Option<Aadl_Datatypes_System::MyStruct_i>,
  pub api_MyArrayStruct1: Option<Aadl_Datatypes_System::MyArrayStruct>,
  pub api_MyArrayInt32: Option<Aadl_Datatypes_System::MyArrayInt32>
}

pub fn put_concrete_inputs_container(container: PreStateContainer)
{
  put_myStruct(container.api_myStruct);
  put_MyArrayStruct1(container.api_MyArrayStruct1);
  put_MyArrayInt32(container.api_MyArrayInt32);
}

pub fn put_concrete_inputs(
  myStruct: Option<Aadl_Datatypes_System::MyStruct_i>,
  MyArrayStruct1: Option<Aadl_Datatypes_System::MyArrayStruct>,
  MyArrayInt32: Option<Aadl_Datatypes_System::MyArrayInt32>)
{
  put_myStruct(myStruct);
  put_MyArrayStruct1(MyArrayStruct1);
  put_MyArrayInt32(MyArrayInt32);
}

/// setter for IN EventDataPort
pub fn put_myStruct(value: Option<Aadl_Datatypes_System::MyStruct_i>)
{
  *extern_api::IN_myStruct.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_MyArrayStruct1(value: Option<Aadl_Datatypes_System::MyArrayStruct>)
{
  *extern_api::IN_MyArrayStruct1.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_MyArrayInt32(value: Option<Aadl_Datatypes_System::MyArrayInt32>)
{
  *extern_api::IN_MyArrayInt32.lock().unwrap() = value
}

pub fn option_strategy_default
  <T: Clone + std::fmt::Debug, 
   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>
{
  option_strategy_bias(1, base)
}

pub fn option_strategy_bias
  <T: Clone + std::fmt::Debug, 
   S:  Strategy<Value = T>> (
  bias: u32,
  base: S) -> impl Strategy<Value = Option<T>>
{
  prop_oneof![
    bias => base.prop_map(Some),
    1 => Just(None),
  ]
}

pub fn Aadl_Datatypes_System_MyEnum_strategy_default() -> impl Strategy<Value = Aadl_Datatypes_System::MyEnum>
{
  Aadl_Datatypes_System_MyEnum_strategy_cust(1, 1)
}

pub fn Aadl_Datatypes_System_MyEnum_strategy_cust(
  On_bias: u32,
  Off_bias: u32) -> impl Strategy<Value = Aadl_Datatypes_System::MyEnum>
{
  prop_oneof![
    On_bias => Just(Aadl_Datatypes_System::MyEnum::On),
    Off_bias => Just(Aadl_Datatypes_System::MyEnum::Off)
  ]
}

pub fn Aadl_Datatypes_System_MyStruct2_i_strategy_default() -> impl Strategy<Value = Aadl_Datatypes_System::MyStruct2_i>
{
  Aadl_Datatypes_System_MyStruct2_i_strategy_cust(
    any::<i32>()
  )
}

pub fn Aadl_Datatypes_System_MyStruct2_i_strategy_cust<fieldSInt32_i32_strategy: Strategy<Value = i32>> (fieldSInt32_strategy: fieldSInt32_i32_strategy) -> impl Strategy<Value = Aadl_Datatypes_System::MyStruct2_i>
{
  (fieldSInt32_strategy).prop_map(|(fieldSInt32)| {
    Aadl_Datatypes_System::MyStruct2_i { fieldSInt32 }
  })
}

pub fn Aadl_Datatypes_System_MyArrayInt32_strategy_default() -> impl Strategy<Value = Aadl_Datatypes_System::MyArrayInt32>
{
  Aadl_Datatypes_System_MyArrayInt32_strategy_cust(any::<i32>())
}

pub fn Aadl_Datatypes_System_MyArrayInt32_strategy_cust<i32_strategy: Strategy<Value = i32>> (base_strategy: i32_strategy) -> impl Strategy<Value = Aadl_Datatypes_System::MyArrayInt32>
{
  proptest::collection::vec(base_strategy, Aadl_Datatypes_System::Aadl_Datatypes_System_MyArrayInt32_DIM_0)
    .prop_map(|v| {
      let boxed: Box<[i32; Aadl_Datatypes_System::Aadl_Datatypes_System_MyArrayInt32_DIM_0]> = v.into_boxed_slice().try_into().unwrap();
      *boxed
  })
}

pub fn Aadl_Datatypes_System_MyArrayStruct_strategy_default() -> impl Strategy<Value = Aadl_Datatypes_System::MyArrayStruct>
{
  Aadl_Datatypes_System_MyArrayStruct_strategy_cust(Aadl_Datatypes_System_MyStruct2_i_strategy_default())
}

pub fn Aadl_Datatypes_System_MyArrayStruct_strategy_cust<Aadl_Datatypes_System_MyStruct2_i_strategy: Strategy<Value = Aadl_Datatypes_System::MyStruct2_i>> (base_strategy: Aadl_Datatypes_System_MyStruct2_i_strategy) -> impl Strategy<Value = Aadl_Datatypes_System::MyArrayStruct>
{
  proptest::collection::vec(base_strategy, Aadl_Datatypes_System::Aadl_Datatypes_System_MyArrayStruct_DIM_0)
    .prop_map(|v| {
      let boxed: Box<[Aadl_Datatypes_System::MyStruct2_i; Aadl_Datatypes_System::Aadl_Datatypes_System_MyArrayStruct_DIM_0]> = v.into_boxed_slice().try_into().unwrap();
      *boxed
  })
}

pub fn Aadl_Datatypes_System_MyStruct_i_strategy_default() -> impl Strategy<Value = Aadl_Datatypes_System::MyStruct_i>
{
  Aadl_Datatypes_System_MyStruct_i_strategy_cust(
    any::<i64>(),
    Aadl_Datatypes_System_MyEnum_strategy_default(),
    Aadl_Datatypes_System_MyStruct2_i_strategy_default(),
    Aadl_Datatypes_System_MyArrayStruct_strategy_default()
  )
}

pub fn Aadl_Datatypes_System_MyStruct_i_strategy_cust
  <fieldInt64_i64_strategy: Strategy<Value = i64>, 
   fieldEnum_Aadl_Datatypes_System_MyEnum_strategy: Strategy<Value = Aadl_Datatypes_System::MyEnum>, 
   fieldRec_Aadl_Datatypes_System_MyStruct2_i_strategy: Strategy<Value = Aadl_Datatypes_System::MyStruct2_i>, 
   fieldArray_Aadl_Datatypes_System_MyArrayStruct_strategy: Strategy<Value = Aadl_Datatypes_System::MyArrayStruct>> (
  fieldInt64_strategy: fieldInt64_i64_strategy,
  fieldEnum_strategy: fieldEnum_Aadl_Datatypes_System_MyEnum_strategy,
  fieldRec_strategy: fieldRec_Aadl_Datatypes_System_MyStruct2_i_strategy,
  fieldArray_strategy: fieldArray_Aadl_Datatypes_System_MyArrayStruct_strategy) -> impl Strategy<Value = Aadl_Datatypes_System::MyStruct_i>
{
  (fieldInt64_strategy, fieldEnum_strategy, fieldRec_strategy, fieldArray_strategy).prop_map(|(fieldInt64, fieldEnum, fieldRec, fieldArray)| {
    Aadl_Datatypes_System::MyStruct_i { fieldInt64, fieldEnum, fieldRec, fieldArray }
  })
}

pub enum HarnessResult {
  RejectedPrecondition,
  FailedPostcondition(TestCaseError),
  Passed,
}

/** Contract-based test harness for the initialize entry point
  */
pub fn testInitializeCB() -> HarnessResult
{
  // [InvokeEntryPoint]: Invoke the entry point
  crate::consumer_consumer_initialize();

  return HarnessResult::Passed
}

#[macro_export]
macro_rules!
testInitializeCB_macro {
  (
    $test_name: ident,
    config: $config:expr
  ) => {
    proptest!{
      #![proptest_config($config)]
      #[test]
      #[serial]
      fn $test_name(empty in ::proptest::strategy::Just(())) {
        match $crate::bridge::test_api::testInitializeCB() {
          $crate::bridge::test_api::HarnessResult::RejectedPrecondition => {
            unreachable!("This branch is infeasible")
          }
          $crate::bridge::test_api::HarnessResult::FailedPostcondition(e) => {
            return Err(e)
          }
          $crate::bridge::test_api::HarnessResult::Passed => { }
        }
      }
    }
  };
}

/** Contract-based test harness for the compute entry point
  *
  * @param api_MyArrayInt32 incoming event data port
  * @param api_MyArrayStruct1 incoming event data port
  * @param api_myStruct incoming event data port
  */
pub fn testComputeCB(
  api_MyArrayInt32: Option<Aadl_Datatypes_System::MyArrayInt32>,
  api_MyArrayStruct1: Option<Aadl_Datatypes_System::MyArrayStruct>,
  api_myStruct: Option<Aadl_Datatypes_System::MyStruct_i>) -> HarnessResult
{
  // Initialize the app
  crate::consumer_consumer_initialize();

  // [CheckPre]: check/filter based on pre-condition.
  if !GUMBOX::compute_CEP_Pre (api_MyArrayInt32, api_MyArrayStruct1, api_myStruct) {
    return HarnessResult::RejectedPrecondition;
  }

  // [PutInPorts]: Set values on the input ports
  put_MyArrayInt32(api_MyArrayInt32);
  put_MyArrayStruct1(api_MyArrayStruct1);
  put_myStruct(api_myStruct);

  // [InvokeEntryPoint]: Invoke the entry point
  crate::consumer_consumer_timeTriggered();

  return HarnessResult::Passed
}

/** Contract-based test harness for the compute entry point
  */
pub fn testComputeCB_container(container: PreStateContainer) -> HarnessResult
{
  return testComputeCB(container.api_MyArrayInt32, container.api_MyArrayStruct1, container.api_myStruct)
}

#[macro_export]
macro_rules!
testComputeCB_macro {
  (
    $test_name: ident,
    config: $config:expr,
    api_MyArrayInt32: $api_MyArrayInt32_strat:expr,
    api_MyArrayStruct1: $api_MyArrayStruct1_strat:expr,
    api_myStruct: $api_myStruct_strat:expr
  ) => {
    proptest!{
      #![proptest_config($config)]
      #[test]
      #[serial]
      fn $test_name(
        (api_MyArrayInt32, api_MyArrayStruct1, api_myStruct)
        in ($api_MyArrayInt32_strat, $api_MyArrayStruct1_strat, $api_myStruct_strat)
      ) {
        match$crate::bridge::test_api::testComputeCB(api_MyArrayInt32, api_MyArrayStruct1, api_myStruct) {
          $crate::bridge::test_api::HarnessResult::RejectedPrecondition => {
            return Err(proptest::test_runner::TestCaseError::reject(
              "Precondition failed: invalid input combination",
            ))
          }
          $crate::bridge::test_api::HarnessResult::FailedPostcondition(e) => {
            return Err(e)
          }
          $crate::bridge::test_api::HarnessResult::Passed => { }
        }
      }
    }
  };
}

#[macro_export]
macro_rules!
testComputeCBwLV_macro {
  (
    $test_name: ident,
    config: $config:expr,
    api_MyArrayInt32: $api_MyArrayInt32_strat:expr,
    api_MyArrayStruct1: $api_MyArrayStruct1_strat:expr,
    api_myStruct: $api_myStruct_strat:expr
  ) => {
    proptest!{
      #![proptest_config($config)]
      #[test]
      #[serial]
      fn $test_name(
        (api_MyArrayInt32, api_MyArrayStruct1, api_myStruct)
        in ($api_MyArrayInt32_strat, $api_MyArrayStruct1_strat, $api_myStruct_strat)
      ) {
        match $crate::bridge::test_api::testComputeCBwLV(api_MyArrayInt32, api_MyArrayStruct1, api_myStruct) {
          $crate::bridge::test_api::HarnessResult::RejectedPrecondition => {
            return Err(proptest::test_runner::TestCaseError::reject(
              "Precondition failed: invalid input combination",
            ))
          }
          $crate::bridge::test_api::HarnessResult::FailedPostcondition(e) => {
            return Err(e)
          }
          $crate::bridge::test_api::HarnessResult::Passed => { }
        }
      }
    }
  };
}