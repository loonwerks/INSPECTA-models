// #Sireum

package base.Gumbo_Structs_Arrays

import org.sireum._
import base._
import base.Gumbo_Structs_Arrays.MyArrayInt32.I05910D
import org.sireum.S32._
import base.Gumbo_Structs_Arrays.MyArrayStruct.I9442F9
import org.sireum.S8._
import org.sireum.S16._
import org.sireum.S64._
import org.sireum.U8._
import org.sireum.U16._
import org.sireum.U32._
import org.sireum.U64._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
object ConsumerThr_i_consumer_consumer_GumboX {
  /** Compute Entrypoint Contract
    *
    * assume atLeastOneZero_ArrayInt32
    * @param api_MyArrayInt32 incoming event data port
    */
  @strictpure def compute_spec_atLeastOneZero_ArrayInt32_assume(
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32]): B =
    api_MyArrayInt32.nonEmpty ___>: ∃(0 until api_MyArrayInt32.get.value.size)(i => api_MyArrayInt32.get.value(I05910D(i)) == s32"0")

  /** Compute Entrypoint Contract
    *
    * assume isSorted_ArrayInt32
    * @param api_MyArrayInt32 incoming event data port
    */
  @strictpure def compute_spec_isSorted_ArrayInt32_assume(
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32]): B =
    api_MyArrayInt32.nonEmpty ___>: ∀(0 to api_MyArrayInt32.get.value.size - 2)(i => api_MyArrayInt32.get.value(I05910D(i)) <= api_MyArrayInt32.get.value(I05910D(i + 1)))

  /** Compute Entrypoint Contract
    *
    * assume atLeastOneZero_StructArray
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_spec_atLeastOneZero_StructArray_assume(
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    api_myStructArray.nonEmpty ___>: ∃(0 until api_myStructArray.get.fieldArray.value.size)(i => api_myStructArray.get.fieldArray.value(I9442F9(i)).fieldSInt32 == s32"0")

  /** Compute Entrypoint Contract
    *
    * assume isSorted_StructArray
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_spec_isSorted_StructArray_assume(
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    api_myStructArray.nonEmpty ___>: ∀(0 until api_myStructArray.get.fieldArray.value.size - 1)(i => api_myStructArray.get.fieldArray.value(I9442F9(i)).fieldSInt32 <= api_myStructArray.get.fieldArray.value(I9442F9(i + 1)).fieldSInt32)

  /** Compute Entrypoint Contract
    *
    * assume atLeastOneZero_ArrayStruct
    * @param api_MyArrayStruct incoming event data port
    */
  @strictpure def compute_spec_atLeastOneZero_ArrayStruct_assume(
      api_MyArrayStruct: Option[Gumbo_Structs_Arrays.MyArrayStruct]): B =
    api_MyArrayStruct.nonEmpty ___>: ∃(0 until api_MyArrayStruct.get.value.size)(i => api_MyArrayStruct.get.value(I9442F9(i)).fieldSInt32 == s32"0")

  /** Compute Entrypoint Contract
    *
    * assume isSorted_ArrayStruct
    *   Demonstrate that the trigger will be attached to the *first indexed use* of the quantified variable 
    *   inside an expression, not merely the first textual occurrence of the quantifier variable.
    * @param api_MyArrayStruct incoming event data port
    */
  @strictpure def compute_spec_isSorted_ArrayStruct_assume(
      api_MyArrayStruct: Option[Gumbo_Structs_Arrays.MyArrayStruct]): B =
    api_MyArrayStruct.nonEmpty ___>: ∀(0 to api_MyArrayStruct.get.value.size - 2)(i => if (i >= 0) api_MyArrayStruct.get.value(I9442F9(i)).fieldSInt32 <= api_MyArrayStruct.get.value(I9442F9(i + 1)).fieldSInt32 else T)

  /** Compute Entrypoint Contract
    *
    * assume assume_valid_velocity
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_spec_assume_valid_velocity_assume(
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    api_myStructArray.nonEmpty ___>:
      ConsumerThr_i_consumer_consumer.square(api_myStructArray.get.fieldInt64) + ConsumerThr_i_consumer_consumer.square(api_myStructArray.get.fieldInt64) <= ConsumerThr_i_consumer_consumer.square(GL.GUMBO__Library.MAX_SPEED())

  /** CEP-T-Assm: Top-level assume contracts for consumer's compute entrypoint
    *
    * @param api_MyArrayInt32 incoming event data port
    * @param api_MyArrayStruct incoming event data port
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_CEP_T_Assm (
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32],
      api_MyArrayStruct: Option[Gumbo_Structs_Arrays.MyArrayStruct],
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    compute_spec_atLeastOneZero_ArrayInt32_assume(api_MyArrayInt32) &
    compute_spec_isSorted_ArrayInt32_assume(api_MyArrayInt32) &
    compute_spec_atLeastOneZero_StructArray_assume(api_myStructArray) &
    compute_spec_isSorted_StructArray_assume(api_myStructArray) &
    compute_spec_atLeastOneZero_ArrayStruct_assume(api_MyArrayStruct) &
    compute_spec_isSorted_ArrayStruct_assume(api_MyArrayStruct) &
    compute_spec_assume_valid_velocity_assume(api_myStructArray)

  /** CEP-Pre: Compute Entrypoint Pre-Condition for consumer
    *
    * @param api_MyArrayInt32 incoming event data port
    * @param api_MyArrayStruct incoming event data port
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_CEP_Pre (
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32],
      api_MyArrayStruct: Option[Gumbo_Structs_Arrays.MyArrayStruct],
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    (// D-Inv-Guard: Datatype invariants for the types associated with consumer's state variables and incoming ports
     Gumbo_Structs_Arrays.MyArrayInt32.D_Inv_Guard_MyArrayInt32(api_MyArrayInt32) & 
     Gumbo_Structs_Arrays.MyArrayStruct.D_Inv_Guard_MyArrayStruct(api_MyArrayStruct) & 

     // CEP-Assm: assume clauses of consumer's compute entrypoint
     compute_CEP_T_Assm (api_MyArrayInt32, api_MyArrayStruct, api_myStructArray))

  /** CEP-Pre: Compute Entrypoint Pre-Condition for consumer via container
    *
    * @param pre Container holding the value of incoming ports and the pre-state values of state variables
    */
  @strictpure def compute_CEP_Pre_Container(pre: ConsumerThr_i_consumer_consumer_PreState_Container_PS): B =
    compute_CEP_Pre(
      api_MyArrayInt32 = pre.api_MyArrayInt32,
      api_MyArrayStruct = pre.api_MyArrayStruct,
      api_myStructArray = pre.api_myStructArray)

  /** Compute Entrypoint Contract
    *
    * guarantee conversions
    *   Exercise all base conversions
    */
  @strictpure def compute_spec_conversions_guarantee(
      ): B =
    ConsumerThr_i_consumer_consumer.convertB(T) && ConsumerThr_i_consumer_consumer.convertS8(s8"1") &&
      ConsumerThr_i_consumer_consumer.convertS16(s16"1") &&
      ConsumerThr_i_consumer_consumer.convertS32(s32"1") &&
      ConsumerThr_i_consumer_consumer.convertS64(s64"1") &&
      ConsumerThr_i_consumer_consumer.convertU8(u8"1") &&
      ConsumerThr_i_consumer_consumer.convertU16(u16"1") &&
      ConsumerThr_i_consumer_consumer.convertU32(u32"1") &&
      ConsumerThr_i_consumer_consumer.convertU64(u64"1")

  /** Compute Entrypoint Contract
    *
    * guarantee guarantee_valid_velocity
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_spec_guarantee_valid_velocity_guarantee(
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    api_myStructArray.nonEmpty ___>:
      ConsumerThr_i_consumer_consumer.square(api_myStructArray.get.fieldInt64) + ConsumerThr_i_consumer_consumer.square(api_myStructArray.get.fieldInt64) <= ConsumerThr_i_consumer_consumer.square(GL.GUMBO__Library.MAX_SPEED())

  /** Compute Entrypoint Contract
    *
    * guarantee all_zero
    * @param api_MyArrayInt32 incoming event data port
    */
  @strictpure def compute_spec_all_zero_guarantee(
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32]): B =
    (api_MyArrayInt32.nonEmpty ___>: ∀(0 until api_MyArrayInt32.get.value.size)(i => ConsumerThr_i_consumer_consumer.test(api_MyArrayInt32.get.value(I05910D(i))) & T)) __>:
      T

  /** CEP-T-Guar: Top-level guarantee contracts for consumer's compute entrypoint
    *
    * @param api_MyArrayInt32 incoming event data port
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_CEP_T_Guar (
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32],
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    compute_spec_conversions_guarantee() &
    compute_spec_guarantee_valid_velocity_guarantee(api_myStructArray) &
    compute_spec_all_zero_guarantee(api_MyArrayInt32)

  /** CEP-Post: Compute Entrypoint Post-Condition for consumer
    *
    * @param api_MyArrayInt32 incoming event data port
    * @param api_MyArrayStruct incoming event data port
    * @param api_myStructArray incoming event data port
    */
  @strictpure def compute_CEP_Post (
      api_MyArrayInt32: Option[Gumbo_Structs_Arrays.MyArrayInt32],
      api_MyArrayStruct: Option[Gumbo_Structs_Arrays.MyArrayStruct],
      api_myStructArray: Option[Gumbo_Structs_Arrays.MyStructArray_i]): B =
    (// D-Inv-Guard: Datatype invariants for the types associated with consumer's state variables and outgoing ports
     Gumbo_Structs_Arrays.MyArrayInt32.D_Inv_Guard_MyArrayInt32(api_MyArrayInt32) & 
     Gumbo_Structs_Arrays.MyArrayStruct.D_Inv_Guard_MyArrayStruct(api_MyArrayStruct) & 

     // CEP-Guar: guarantee clauses of consumer's compute entrypoint
     compute_CEP_T_Guar (api_MyArrayInt32, api_myStructArray))

  /** CEP-Post: Compute Entrypoint Post-Condition for consumer via containers
    *
    * @param pre Container holding the values of incoming ports and the pre-state values of state variables
    * @param post Container holding the values of outgoing ports and the post-state values of state variables
    */
  @strictpure def compute_CEP_Post_Container(
      pre: ConsumerThr_i_consumer_consumer_PreState_Container_PS,
      post: ConsumerThr_i_consumer_consumer_PostState_Container_PS): B =
    compute_CEP_Post(
      api_MyArrayInt32 = pre.api_MyArrayInt32,
      api_MyArrayStruct = pre.api_MyArrayStruct,
      api_myStructArray = pre.api_myStructArray)
}
