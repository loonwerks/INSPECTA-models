#![cfg(test)]

// Do not edit this file as it will be overwritten if codegen is rerun

use crate::bridge::extern_c_api as extern_api;
use data::*;

use proptest::prelude::*;

pub struct PreStateContainer {
  pub api_myBoolean: Option<bool>,
  pub api_myCharacter: Option<u8>,
  pub api_myString: Option<Base_Types::String>,
  pub api_myInt8: Option<i8>,
  pub api_myInt16: Option<i16>,
  pub api_myInt32: Option<i32>,
  pub api_myInt64: Option<i64>,
  pub api_myUInt8: Option<u8>,
  pub api_myUInt16: Option<u16>,
  pub api_myUInt32: Option<u32>,
  pub api_myUInt64: Option<u64>,
  pub api_myFloat32: Option<f32>,
  pub api_myFloat64: Option<f64>,
  pub api_myEnum: Option<Aadl_Datatypes::MyEnum>,
  pub api_myStruct: Option<Aadl_Datatypes::MyStruct_i>,
  pub api_myArray1: Option<Aadl_Datatypes::MyArrayOneDim>
}

pub fn put_concrete_inputs_container(container: PreStateContainer)
{
  put_myBoolean(container.api_myBoolean);
  put_myCharacter(container.api_myCharacter);
  put_myString(container.api_myString);
  put_myInt8(container.api_myInt8);
  put_myInt16(container.api_myInt16);
  put_myInt32(container.api_myInt32);
  put_myInt64(container.api_myInt64);
  put_myUInt8(container.api_myUInt8);
  put_myUInt16(container.api_myUInt16);
  put_myUInt32(container.api_myUInt32);
  put_myUInt64(container.api_myUInt64);
  put_myFloat32(container.api_myFloat32);
  put_myFloat64(container.api_myFloat64);
  put_myEnum(container.api_myEnum);
  put_myStruct(container.api_myStruct);
  put_myArray1(container.api_myArray1);
}

pub fn put_concrete_inputs(
  myBoolean: Option<bool>,
  myCharacter: Option<u8>,
  myString: Option<Base_Types::String>,
  myInt8: Option<i8>,
  myInt16: Option<i16>,
  myInt32: Option<i32>,
  myInt64: Option<i64>,
  myUInt8: Option<u8>,
  myUInt16: Option<u16>,
  myUInt32: Option<u32>,
  myUInt64: Option<u64>,
  myFloat32: Option<f32>,
  myFloat64: Option<f64>,
  myEnum: Option<Aadl_Datatypes::MyEnum>,
  myStruct: Option<Aadl_Datatypes::MyStruct_i>,
  myArray1: Option<Aadl_Datatypes::MyArrayOneDim>)
{
  put_myBoolean(myBoolean);
  put_myCharacter(myCharacter);
  put_myString(myString);
  put_myInt8(myInt8);
  put_myInt16(myInt16);
  put_myInt32(myInt32);
  put_myInt64(myInt64);
  put_myUInt8(myUInt8);
  put_myUInt16(myUInt16);
  put_myUInt32(myUInt32);
  put_myUInt64(myUInt64);
  put_myFloat32(myFloat32);
  put_myFloat64(myFloat64);
  put_myEnum(myEnum);
  put_myStruct(myStruct);
  put_myArray1(myArray1);
}

/// setter for IN EventDataPort
pub fn put_myBoolean(value: Option<bool>)
{
  *extern_api::IN_myBoolean.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myCharacter(value: Option<u8>)
{
  *extern_api::IN_myCharacter.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myString(value: Option<Base_Types::String>)
{
  *extern_api::IN_myString.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myInt8(value: Option<i8>)
{
  *extern_api::IN_myInt8.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myInt16(value: Option<i16>)
{
  *extern_api::IN_myInt16.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myInt32(value: Option<i32>)
{
  *extern_api::IN_myInt32.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myInt64(value: Option<i64>)
{
  *extern_api::IN_myInt64.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myUInt8(value: Option<u8>)
{
  *extern_api::IN_myUInt8.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myUInt16(value: Option<u16>)
{
  *extern_api::IN_myUInt16.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myUInt32(value: Option<u32>)
{
  *extern_api::IN_myUInt32.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myUInt64(value: Option<u64>)
{
  *extern_api::IN_myUInt64.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myFloat32(value: Option<f32>)
{
  *extern_api::IN_myFloat32.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myFloat64(value: Option<f64>)
{
  *extern_api::IN_myFloat64.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myEnum(value: Option<Aadl_Datatypes::MyEnum>)
{
  *extern_api::IN_myEnum.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myStruct(value: Option<Aadl_Datatypes::MyStruct_i>)
{
  *extern_api::IN_myStruct.lock().unwrap() = value
}

/// setter for IN EventDataPort
pub fn put_myArray1(value: Option<Aadl_Datatypes::MyArrayOneDim>)
{
  *extern_api::IN_myArray1.lock().unwrap() = value
}

pub fn option_strategy_default
  <T: Clone + std::fmt::Debug, 
   S:  Strategy<Value = T>> (base: S) -> impl Strategy<Value = Option<T>>
{
  option_strategy_bias(1, base)
}

pub fn option_strategy_bias
  <T: Clone + std::fmt::Debug, 
   S:  Strategy<Value = T>> (
  bias: u32,
  base: S) -> impl Strategy<Value = Option<T>>
{
  prop_oneof![
    bias => base.prop_map(Some),
    1 => Just(None),
  ]
}

pub fn Aadl_Datatypes_MyEnum_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyEnum>
{
  Aadl_Datatypes_MyEnum_strategy_cust(1, 1)
}

pub fn Aadl_Datatypes_MyEnum_strategy_cust(
  On_bias: u32,
  Off_bias: u32) -> impl Strategy<Value = Aadl_Datatypes::MyEnum>
{
  prop_oneof![
    On_bias => Just(Aadl_Datatypes::MyEnum::On),
    Off_bias => Just(Aadl_Datatypes::MyEnum::Off)
  ]
}

pub fn Aadl_Datatypes_MyStruct2_i_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyStruct2_i>
{
  Aadl_Datatypes_MyStruct2_i_strategy_cust(
    any::<u8>()
  )
}

pub fn Aadl_Datatypes_MyStruct2_i_strategy_cust<fieldSChar_u8_strategy: Strategy<Value = u8>> (fieldSChar_strategy: fieldSChar_u8_strategy) -> impl Strategy<Value = Aadl_Datatypes::MyStruct2_i>
{
  (fieldSChar_strategy).prop_map(|(fieldSChar)| {
    Aadl_Datatypes::MyStruct2_i { fieldSChar }
  })
}

pub fn Base_Types_String_strategy_default() -> impl Strategy<Value = Base_Types::String>
{
  Base_Types_String_strategy_cust(any::<u8>())
}

pub fn Base_Types_String_strategy_cust<u8_strategy: Strategy<Value = u8>> (base_strategy: u8_strategy) -> impl Strategy<Value = Base_Types::String>
{
  proptest::collection::vec(base_strategy, Base_Types::Base_Types_String_DIM_0)
    .prop_map(|v| {
      let boxed: Box<[u8; Base_Types::Base_Types_String_DIM_0]> = v.into_boxed_slice().try_into().unwrap();
      *boxed
  })
}

pub fn Aadl_Datatypes_MyArrayOneDim_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyArrayOneDim>
{
  Aadl_Datatypes_MyArrayOneDim_strategy_cust(any::<i32>())
}

pub fn Aadl_Datatypes_MyArrayOneDim_strategy_cust<i32_strategy: Strategy<Value = i32>> (base_strategy: i32_strategy) -> impl Strategy<Value = Aadl_Datatypes::MyArrayOneDim>
{
  proptest::collection::vec(base_strategy, Aadl_Datatypes::Aadl_Datatypes_MyArrayOneDim_DIM_0)
    .prop_map(|v| {
      let boxed: Box<[i32; Aadl_Datatypes::Aadl_Datatypes_MyArrayOneDim_DIM_0]> = v.into_boxed_slice().try_into().unwrap();
      *boxed
  })
}

pub fn Aadl_Datatypes_MyStruct_i_strategy_default() -> impl Strategy<Value = Aadl_Datatypes::MyStruct_i>
{
  Aadl_Datatypes_MyStruct_i_strategy_cust(
    any::<i64>(),
    Base_Types_String_strategy_default(),
    Aadl_Datatypes_MyEnum_strategy_default(),
    Aadl_Datatypes_MyStruct2_i_strategy_default(),
    Aadl_Datatypes_MyArrayOneDim_strategy_default()
  )
}

pub fn Aadl_Datatypes_MyStruct_i_strategy_cust
  <fieldInt64_i64_strategy: Strategy<Value = i64>, 
   fieldStr_Base_Types_String_strategy: Strategy<Value = Base_Types::String>, 
   fieldEnum_Aadl_Datatypes_MyEnum_strategy: Strategy<Value = Aadl_Datatypes::MyEnum>, 
   fieldRec_Aadl_Datatypes_MyStruct2_i_strategy: Strategy<Value = Aadl_Datatypes::MyStruct2_i>, 
   fieldArray_Aadl_Datatypes_MyArrayOneDim_strategy: Strategy<Value = Aadl_Datatypes::MyArrayOneDim>> (
  fieldInt64_strategy: fieldInt64_i64_strategy,
  fieldStr_strategy: fieldStr_Base_Types_String_strategy,
  fieldEnum_strategy: fieldEnum_Aadl_Datatypes_MyEnum_strategy,
  fieldRec_strategy: fieldRec_Aadl_Datatypes_MyStruct2_i_strategy,
  fieldArray_strategy: fieldArray_Aadl_Datatypes_MyArrayOneDim_strategy) -> impl Strategy<Value = Aadl_Datatypes::MyStruct_i>
{
  (fieldInt64_strategy, fieldStr_strategy, fieldEnum_strategy, fieldRec_strategy, fieldArray_strategy).prop_map(|(fieldInt64, fieldStr, fieldEnum, fieldRec, fieldArray)| {
    Aadl_Datatypes::MyStruct_i { fieldInt64, fieldStr, fieldEnum, fieldRec, fieldArray }
  })
}