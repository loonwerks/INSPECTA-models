*** Begin Patch
*** Update File: GumboTransformers.py
@@
 def validate_sysml(sysml_text: str, jar_path: str = "MCSysMLv2.jar") -> None: #ToDo: Use SysMl v2 Hammer parser.
@@
     finally:
         os.unlink(tmp_name)
+
+def validate_sysml_sireum(sysml_text: str, sireum_home: str | None = None) -> None:
+    """
+    Validate SysML v2 content using the Sireum IVE command‑line interface.
+
+    This helper writes the provided SysML v2 text to a temporary file and then
+    attempts to invoke the Sireum CLI to parse it.  It first tries to
+    construct the path to the Sireum executable from the provided
+    ``sireum_home`` argument.  If ``sireum_home`` is not supplied, it falls
+    back to the ``SIREUM_HOME`` environment variable.  As a last resort, it
+    searches the system ``PATH`` for a ``sireum`` executable.
+
+    **Note:** This function assumes that Sireum has been installed on the
+    machine and that its CLI supports a subcommand sequence of
+    ``hamr sysml parse`` to perform SysML v2 parsing.  If your version of
+    Sireum uses a different command, update the ``cmd`` list below
+    accordingly.
+
+    :param sysml_text: The SysML v2 model text to be validated.
+    :param sireum_home: Optional explicit path to the Sireum installation
+        directory.  When provided, the function attempts to execute
+        ``<sireum_home>/bin/sireum`` (``.bat`` on Windows).
+    """
+    import subprocess
+    import tempfile
+    import os
+    import shutil
+
+    # Write the SysML model to a temporary file so Sireum can consume it.
+    with tempfile.NamedTemporaryFile("w", suffix=".sysml", delete=False) as fh:
+        fh.write(sysml_text)
+        fh.flush()
+        tmp_name = fh.name
+
+    try:
+        executable: str | None = None
+        # Determine the Sireum executable based on sireum_home
+        if sireum_home:
+            candidate = os.path.join(sireum_home, "bin", "sireum")
+            if os.name == "nt":
+                candidate += ".bat"
+            if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
+                executable = candidate
+
+        # Fall back to SIREUM_HOME environment variable
+        if not executable:
+            env_home = os.environ.get("SIREUM_HOME")
+            if env_home:
+                candidate = os.path.join(env_home, "bin", "sireum")
+                if os.name == "nt":
+                    candidate += ".bat"
+                if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
+                    executable = candidate
+
+        # Last resort: look for sireum on PATH
+        if not executable:
+            executable = shutil.which("sireum")
+
+        if not executable:
+            print(
+                "Sireum CLI not found. Please install Sireum IVE and set the SIREUM_HOME environment variable.",
+            )
+            return
+
+        # Compose the command.  Adjust this if your Sireum version exposes a
+        # different SysML parsing entry point.
+        cmd = [executable, "hamr", "sysml", "parse", tmp_name]
+        try:
+            result = subprocess.run(
+                cmd,
+                capture_output=True,
+                text=True,
+                timeout=120,
+            )
+        except FileNotFoundError:
+            print(
+                "Failed to execute Sireum CLI. Ensure that Sireum is installed and accessible.",
+            )
+            return
+        except subprocess.TimeoutExpired:
+            print("Sireum validation timed out.")
+            return
+
+        if result.returncode == 0:
+            print("\n=== Sireum SysML v2 Parser Output ===")
+            print(result.stdout.strip())
+            print("Sireum validation succeeded")
+        else:
+            print("\nSireum validation failed")
+            # Print stderr to aid debugging
+            err_out = result.stderr.strip()
+            if err_out:
+                print(err_out)
+    finally:
+        # Clean up the temporary file
+        os.unlink(tmp_name)
@@
-def process_sysml_file(path: str, *, validate: bool = True, debug: bool = False) -> None:
+def process_sysml_file(path: str, *, validate: bool = True, debug: bool = False, sireum: bool = False, sireum_home: str | None = None) -> None:
@@
-    if validate:
-        validate_sysml(new_text)
+    if validate:
+        if sireum:
+            validate_sysml_sireum(new_text, sireum_home=sireum_home)
+        else:
+            validate_sysml(new_text)
@@ def main() -> None:
     parser_cli.add_argument(
         "--show",
         action="store_true",
         help="Print the translated SysML text",
     )
+    parser_cli.add_argument(
+        "--sireum",
+        action="store_true",
+        help="Validate the translated SysML using the Sireum IVE parser instead of the default MontiCore parser.",
+    )
+    parser_cli.add_argument(
+        "--sireum-home",
+        metavar="PATH",
+        help="Optional path to the Sireum installation directory used to locate the sireum executable.",
+    )
@@ def main() -> None:
-    process_sysml_file(
-        args.input,
-        validate=not args.no_validate,
-        debug=args.show
-    )
+    process_sysml_file(
+        args.input,
+        validate=not args.no_validate,
+        debug=args.show,
+        sireum=args.sireum,
+        sireum_home=args.sireum_home,
+    )
*** End Patch
